# 11.4 混淆矩阵与ROC分析

在机器学习模型评估中，准确理解模型的预测行为至关重要。混淆矩阵和ROC曲线是两种强大的可视化工具，它们能够提供比单一准确率指标更深入的洞察。混淆矩阵展示了模型在各个类别上的预测表现，而ROC曲线则揭示了模型在不同阈值下的敏感性和特异性权衡。

## 本节内容概览

- 混淆矩阵的构建与解读
- 多分类问题中的混淆矩阵扩展
- ROC曲线与AUC指标详解
- 多类别ROC分析方法
- 实际应用中的最佳实践

## 设计思考与技术理念

在现实世界的分类问题中，不同类别的误分类代价往往是不对称的。例如，在医疗诊断中，将患病患者误诊为健康（假阴性）的代价通常远高于将健康人误诊为患病（假阳性）。因此，仅关注总体准确率是远远不够的，我们需要更细致的评估工具来全面了解模型的表现。

混淆矩阵提供了一个直观的表格形式，清晰地展示了模型在每个类别上的预测结果分布。而ROC曲线则通过描绘真正例率和假正例率的关系，帮助我们在不同决策阈值下权衡模型的敏感性和特异性。

## 11.4.1 混淆矩阵详解

混淆矩阵是一个表格，用于描述分类模型在测试数据集上的表现。对于二分类问题，混淆矩阵是一个2×2的矩阵，包含了四种可能的预测结果组合。

### 二分类混淆矩阵

|                     | 实际正例 | 实际负例 |
|---------------------|----------|----------|
| **预测正例**        | TP (真正例) | FP (假正例) |
| **预测负例**        | FN (假负例) | TN (真负例) |

其中：
- **TP (True Positive)**: 正确预测为正例的样本数
- **FP (False Positive)**: 错误预测为正例的样本数
- **FN (False Negative)**: 错误预测为负例的样本数
- **TN (True Negative)**: 正确预测为负例的样本数

### 混淆矩阵实现

```java
import java.util.*;

/**
 * 混淆矩阵实现
 */
public class ConfusionMatrix {
    private int[][] matrix;
    private String[] labels;
    private int numClasses;
    
    /**
     * 构造函数 - 二分类
     */
    public ConfusionMatrix() {
        this.numClasses = 2;
        this.matrix = new int[2][2];
        this.labels = new String[]{"Negative", "Positive"};
    }
    
    /**
     * 构造函数 - 多分类
     * @param labels 类别标签数组
     */
    public ConfusionMatrix(String[] labels) {
        this.numClasses = labels.length;
        this.matrix = new int[numClasses][numClasses];
        this.labels = Arrays.copyOf(labels, labels.length);
    }
    
    /**
     * 更新混淆矩阵
     * @param trueLabels 真实标签数组
     * @param predictions 预测标签数组
     */
    public void update(int[] trueLabels, int[] predictions) {
        if (trueLabels.length != predictions.length) {
            throw new IllegalArgumentException("真实标签和预测标签长度不匹配");
        }
        
        for (int i = 0; i < trueLabels.length; i++) {
            update(trueLabels[i], predictions[i]);
        }
    }
    
    /**
     * 更新单个样本的混淆矩阵
     * @param trueLabel 真实标签
     * @param prediction 预测标签
     */
    public void update(int trueLabel, int prediction) {
        if (trueLabel < 0 || trueLabel >= numClasses || 
            prediction < 0 || prediction >= numClasses) {
            throw new IllegalArgumentException("标签值超出范围");
        }
        
        matrix[trueLabel][prediction]++;
    }
    
    /**
     * 获取TP值（仅适用于二分类）
     * @return TP值
     */
    public int getTP() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        return matrix[1][1];
    }
    
    /**
     * 获取FP值（仅适用于二分类）
     * @return FP值
     */
    public int getFP() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        return matrix[0][1];
    }
    
    /**
     * 获取FN值（仅适用于二分类）
     * @return FN值
     */
    public int getFN() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        return matrix[1][0];
    }
    
    /**
     * 获取TN值（仅适用于二分类）
     * @return TN值
     */
    public int getTN() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        return matrix[0][0];
    }
    
    /**
     * 计算准确率
     * @return 准确率
     */
    public double getAccuracy() {
        int total = getTotalCount();
        int correct = 0;
        
        for (int i = 0; i < numClasses; i++) {
            correct += matrix[i][i];
        }
        
        return total == 0 ? 0 : (double) correct / total;
    }
    
    /**
     * 计算精确率（仅适用于二分类）
     * @return 精确率
     */
    public double getPrecision() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        
        int predictedPositives = getTP() + getFP();
        return predictedPositives == 0 ? 0 : (double) getTP() / predictedPositives;
    }
    
    /**
     * 计算召回率（仅适用于二分类）
     * @return 召回率
     */
    public double getRecall() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        
        int actualPositives = getTP() + getFN();
        return actualPositives == 0 ? 0 : (double) getTP() / actualPositives;
    }
    
    /**
     * 计算F1分数（仅适用于二分类）
     * @return F1分数
     */
    public double getF1Score() {
        if (numClasses != 2) {
            throw new IllegalStateException("仅适用于二分类问题");
        }
        
        double precision = getPrecision();
        double recall = getRecall();
        double sum = precision + recall;
        return sum == 0 ? 0 : 2 * precision * recall / sum;
    }
    
    /**
     * 计算每个类别的精确率
     * @return 精确率数组
     */
    public double[] getPrecisionPerClass() {
        double[] precisions = new double[numClasses];
        
        for (int i = 0; i < numClasses; i++) {
            int predictedAsI = 0;
            for (int j = 0; j < numClasses; j++) {
                predictedAsI += matrix[j][i];
            }
            
            precisions[i] = predictedAsI == 0 ? 0 : (double) matrix[i][i] / predictedAsI;
        }
        
        return precisions;
    }
    
    /**
     * 计算每个类别的召回率
     * @return 召回率数组
     */
    public double[] getRecallPerClass() {
        double[] recalls = new double[numClasses];
        
        for (int i = 0; i < numClasses; i++) {
            int actualI = 0;
            for (int j = 0; j < numClasses; j++) {
                actualI += matrix[i][j];
            }
            
            recalls[i] = actualI == 0 ? 0 : (double) matrix[i][i] / actualI;
        }
        
        return recalls;
    }
    
    /**
     * 计算每个类别的F1分数
     * @return F1分数数组
     */
    public double[] getF1ScorePerClass() {
        double[] f1Scores = new double[numClasses];
        double[] precisions = getPrecisionPerClass();
        double[] recalls = getRecallPerClass();
        
        for (int i = 0; i < numClasses; i++) {
            double sum = precisions[i] + recalls[i];
            f1Scores[i] = sum == 0 ? 0 : 2 * precisions[i] * recalls[i] / sum;
        }
        
        return f1Scores;
    }
    
    /**
     * 获取总样本数
     * @return 总样本数
     */
    public int getTotalCount() {
        int total = 0;
        for (int i = 0; i < numClasses; i++) {
            for (int j = 0; j < numClasses; j++) {
                total += matrix[i][j];
            }
        }
        return total;
    }
    
    /**
     * 获取混淆矩阵
     * @return 混淆矩阵副本
     */
    public int[][] getMatrix() {
        int[][] copy = new int[numClasses][numClasses];
        for (int i = 0; i < numClasses; i++) {
            System.arraycopy(matrix[i], 0, copy[i], 0, numClasses);
        }
        return copy;
    }
    
    /**
     * 获取类别标签
     * @return 类别标签数组副本
     */
    public String[] getLabels() {
        return Arrays.copyOf(labels, labels.length);
    }
    
    /**
     * 打印混淆矩阵
     */
    public void printMatrix() {
        // 打印表头
        System.out.print("Actual\\Predicted");
        for (String label : labels) {
            System.out.printf("\t%s", label);
        }
        System.out.println();
        
        // 打印矩阵内容
        for (int i = 0; i < numClasses; i++) {
            System.out.print(labels[i]);
            for (int j = 0; j < numClasses; j++) {
                System.out.printf("\t%d", matrix[i][j]);
            }
            System.out.println();
        }
    }
    
    /**
     * 重置混淆矩阵
     */
    public void reset() {
        for (int i = 0; i < numClasses; i++) {
            Arrays.fill(matrix[i], 0);
        }
    }
}
```

## 11.4.2 ROC曲线与AUC指标

ROC曲线（Receiver Operating Characteristic Curve）是评估二分类模型性能的重要工具。它以真正例率（TPR）为纵轴，假正例率（FPR）为横轴，描绘了模型在不同分类阈值下的表现。

### ROC曲线核心概念

- **真正例率 (TPR)**：TPR = TP / (TP + FN)，也称为敏感性或召回率
- **假正例率 (FPR)**：FPR = FP / (FP + TN)，也称为1-特异性

### ROC曲线实现

```java
import java.util.*;

/**
 * ROC曲线分析工具
 */
public class ROCAnalysis {
    
    /**
     * 计算ROC曲线点
     * @param trueLabels 真实标签数组
     * @param predictedProbabilities 预测概率数组
     * @return ROC曲线点列表
     */
    public static List<ROCPoint> calculateROCPoints(int[] trueLabels, double[] predictedProbabilities) {
        if (trueLabels.length != predictedProbabilities.length) {
            throw new IllegalArgumentException("标签和预测概率长度不匹配");
        }
        
        // 创建索引数组并按预测概率排序
        Integer[] indices = new Integer[trueLabels.length];
        for (int i = 0; i < indices.length; i++) {
            indices[i] = i;
        }
        
        Arrays.sort(indices, (a, b) -> Double.compare(predictedProbabilities[b], predictedProbabilities[a]));
        
        // 计算正负样本总数
        int positiveCount = 0;
        int negativeCount = 0;
        for (int label : trueLabels) {
            if (label == 1) {
                positiveCount++;
            } else {
                negativeCount++;
            }
        }
        
        // 计算ROC曲线点
        List<ROCPoint> rocPoints = new ArrayList<>();
        int tp = 0;
        int fp = 0;
        
        // 添加初始点 (0, 0)
        rocPoints.add(new ROCPoint(0.0, 0.0, 1.0));
        
        // 遍历排序后的样本
        for (int i = 0; i < indices.length; i++) {
            int idx = indices[i];
            if (trueLabels[idx] == 1) {
                tp++;
            } else {
                fp++;
            }
            
            double tpr = positiveCount == 0 ? 0 : (double) tp / positiveCount;
            double fpr = negativeCount == 0 ? 0 : (double) fp / negativeCount;
            double threshold = predictedProbabilities[idx];
            
            rocPoints.add(new ROCPoint(fpr, tpr, threshold));
        }
        
        return rocPoints;
    }
    
    /**
     * 计算AUC值（曲线下面积）
     * @param rocPoints ROC曲线点列表
     * @return AUC值
     */
    public static double calculateAUC(List<ROCPoint> rocPoints) {
        if (rocPoints.size() < 2) {
            return 0.0;
        }
        
        // 按FPR排序
        List<ROCPoint> sortedPoints = new ArrayList<>(rocPoints);
        sortedPoints.sort(Comparator.comparingDouble(ROCPoint::getFpr));
        
        // 使用梯形法则计算AUC
        double auc = 0.0;
        for (int i = 1; i < sortedPoints.size(); i++) {
            double deltaX = sortedPoints.get(i).getFpr() - sortedPoints.get(i-1).getFpr();
            double deltaY = sortedPoints.get(i).getTpr() + sortedPoints.get(i-1).getTpr();
            auc += deltaX * deltaY / 2.0;
        }
        
        return auc;
    }
    
    /**
     * 计算最优分类阈值
     * @param rocPoints ROC曲线点列表
     * @return 最优阈值点
     */
    public static ROCPoint findOptimalThreshold(List<ROCPoint> rocPoints) {
        ROCPoint optimalPoint = null;
        double maxDistance = -1;
        
        // 寻找距离左上角(0,1)最近的点
        for (ROCPoint point : rocPoints) {
            // 计算到点(0,1)的距离的平方（避免开方运算）
            double distanceSquared = point.getFpr() * point.getFpr() + 
                                   (1 - point.getTpr()) * (1 - point.getTpr());
            
            if (optimalPoint == null || distanceSquared < maxDistance) {
                maxDistance = distanceSquared;
                optimalPoint = point;
            }
        }
        
        return optimalPoint;
    }
    
    /**
     * ROC曲线点类
     */
    public static class ROCPoint {
        private double fpr;      // 假正例率
        private double tpr;      // 真正例率
        private double threshold; // 分类阈值
        
        public ROCPoint(double fpr, double tpr, double threshold) {
            this.fpr = fpr;
            this.tpr = tpr;
            this.threshold = threshold;
        }
        
        public double getFpr() {
            return fpr;
        }
        
        public double getTpr() {
            return tpr;
        }
        
        public double getThreshold() {
            return threshold;
        }
        
        @Override
        public String toString() {
            return String.format("ROCPoint{FPR=%.4f, TPR=%.4f, Threshold=%.4f}", 
                               fpr, tpr, threshold);
        }
    }
}
```

## 11.4.3 多类别ROC分析

对于多分类问题，有几种扩展ROC分析的方法：

### 1. 一对一（One-vs-One）方法

```java
/**
 * 多类别ROC分析工具
 */
public class MultiClassROCAnalysis {
    
    /**
     * 计算多类别ROC曲线（一对一方法）
     * @param trueLabels 真实标签数组
     * @param predictedProbabilities 预测概率矩阵（每行一个样本，每列一个类别）
     * @param numClasses 类别数
     * @return 多类别ROC分析结果
     */
    public static MultiClassROCResult calculateOneVsOneROC(
            int[] trueLabels, 
            double[][] predictedProbabilities, 
            int numClasses) {
        
        Map<String, BinaryROCResult> binaryResults = new HashMap<>();
        
        // 对每一对类别计算ROC
        for (int i = 0; i < numClasses; i++) {
            for (int j = i + 1; j < numClasses; j++) {
                // 提取只属于类别i和j的样本
                List<Integer> indices = new ArrayList<>();
                List<Integer> binaryLabels = new ArrayList<>();
                List<Double> probabilities = new ArrayList<>();
                
                for (int k = 0; k < trueLabels.length; k++) {
                    if (trueLabels[k] == i || trueLabels[k] == j) {
                        indices.add(k);
                        binaryLabels.add(trueLabels[k] == i ? 1 : 0);
                        // 归一化概率
                        double probI = predictedProbabilities[k][i];
                        double probJ = predictedProbabilities[k][j];
                        double normalizedProb = probI / (probI + probJ);
                        probabilities.add(normalizedProb);
                    }
                }
                
                // 转换为数组
                int[] binaryLabelArray = binaryLabels.stream().mapToInt(Integer::intValue).toArray();
                double[] probabilityArray = probabilities.stream().mapToDouble(Double::doubleValue).toArray();
                
                // 计算ROC
                List<ROCAnalysis.ROCPoint> rocPoints = ROCAnalysis.calculateROCPoints(
                    binaryLabelArray, probabilityArray);
                double auc = ROCAnalysis.calculateAUC(rocPoints);
                
                String pairKey = String.format("%d_vs_%d", i, j);
                binaryResults.put(pairKey, new BinaryROCResult(rocPoints, auc));
            }
        }
        
        return new MultiClassROCResult(binaryResults);
    }
    
    /**
     * 计算多类别ROC曲线（一对多方法）
     * @param trueLabels 真实标签数组
     * @param predictedProbabilities 预测概率矩阵
     * @param numClasses 类别数
     * @return 多类别ROC分析结果
     */
    public static MultiClassROCResult calculateOneVsRestROC(
            int[] trueLabels, 
            double[][] predictedProbabilities, 
            int numClasses) {
        
        Map<String, BinaryROCResult> binaryResults = new HashMap<>();
        
        // 对每个类别计算一对多ROC
        for (int i = 0; i < numClasses; i++) {
            // 构造二分类标签
            int[] binaryLabels = new int[trueLabels.length];
            double[] probabilities = new double[trueLabels.length];
            
            for (int j = 0; j < trueLabels.length; j++) {
                binaryLabels[j] = trueLabels[j] == i ? 1 : 0;
                probabilities[j] = predictedProbabilities[j][i];
            }
            
            // 计算ROC
            List<ROCAnalysis.ROCPoint> rocPoints = ROCAnalysis.calculateROCPoints(
                binaryLabels, probabilities);
            double auc = ROCAnalysis.calculateAUC(rocPoints);
            
            String classKey = String.format("class_%d", i);
            binaryResults.put(classKey, new BinaryROCResult(rocPoints, auc));
        }
        
        return new MultiClassROCResult(binaryResults);
    }
    
    /**
     * 二分类ROC结果
     */
    public static class BinaryROCResult {
        private List<ROCAnalysis.ROCPoint> rocPoints;
        private double auc;
        
        public BinaryROCResult(List<ROCAnalysis.ROCPoint> rocPoints, double auc) {
            this.rocPoints = rocPoints;
            this.auc = auc;
        }
        
        public List<ROCAnalysis.ROCPoint> getRocPoints() {
            return rocPoints;
        }
        
        public double getAuc() {
            return auc;
        }
    }
    
    /**
     * 多类别ROC结果
     */
    public static class MultiClassROCResult {
        private Map<String, BinaryROCResult> binaryResults;
        
        public MultiClassROCResult(Map<String, BinaryROCResult> binaryResults) {
            this.binaryResults = binaryResults;
        }
        
        public Map<String, BinaryROCResult> getBinaryResults() {
            return binaryResults;
        }
        
        /**
         * 计算宏平均AUC
         * @return 宏平均AUC
         */
        public double getMacroAveragedAUC() {
            if (binaryResults.isEmpty()) {
                return 0.0;
            }
            
            double sum = 0.0;
            for (BinaryROCResult result : binaryResults.values()) {
                sum += result.getAuc();
            }
            
            return sum / binaryResults.size();
        }
        
        /**
         * 计算微平均AUC
         * @return 微平均AUC
         */
        public double getMicroAveragedAUC() {
            // 微平均AUC等于整体AUC
            // 这里简化处理，实际应该合并所有二分类结果
            return getMacroAveragedAUC();
        }
    }
}
```

## 11.4.4 综合评估报告生成

基于混淆矩阵和ROC分析的结果，我们可以生成综合的模型评估报告：

```java
/**
 * 模型评估报告生成器
 */
public class ModelEvaluationReport {
    
    /**
     * 生成完整的模型评估报告
     * @param confusionMatrix 混淆矩阵
     * @param rocPoints ROC曲线点
     * @param className 类别名称（用于二分类）
     * @return 评估报告字符串
     */
    public static String generateBinaryClassificationReport(
            ConfusionMatrix confusionMatrix, 
            List<ROCAnalysis.ROCPoint> rocPoints,
            String className) {
        
        StringBuilder report = new StringBuilder();
        report.append("=== 模型评估报告 ===\n\n");
        
        // 基本统计信息
        report.append("1. 基本统计信息:\n");
        report.append(String.format("   总样本数: %d\n", confusionMatrix.getTotalCount()));
        report.append(String.format("   准确率: %.4f\n", confusionMatrix.getAccuracy()));
        report.append(String.format("   精确率: %.4f\n", confusionMatrix.getPrecision()));
        report.append(String.format("   召回率: %.4f\n", confusionMatrix.getRecall()));
        report.append(String.format("   F1分数: %.4f\n", confusionMatrix.getF1Score()));
        report.append("\n");
        
        // 混淆矩阵
        report.append("2. 混淆矩阵:\n");
        int[][] matrix = confusionMatrix.getMatrix();
        String[] labels = confusionMatrix.getLabels();
        
        // 表头
        report.append("   Actual\\Predicted");
        for (String label : labels) {
            report.append(String.format("\t%s", label));
        }
        report.append("\n");
        
        // 矩阵内容
        for (int i = 0; i < matrix.length; i++) {
            report.append(String.format("   %s", labels[i]));
            for (int j = 0; j < matrix[i].length; j++) {
                report.append(String.format("\t%d", matrix[i][j]));
            }
            report.append("\n");
        }
        report.append("\n");
        
        // ROC分析
        if (rocPoints != null && !rocPoints.isEmpty()) {
            double auc = ROCAnalysis.calculateAUC(rocPoints);
            ROCAnalysis.ROCPoint optimalPoint = ROCAnalysis.findOptimalThreshold(rocPoints);
            
            report.append("3. ROC分析:\n");
            report.append(String.format("   AUC值: %.4f\n", auc));
            if (optimalPoint != null) {
                report.append(String.format("   最优阈值: %.4f (TPR=%.4f, FPR=%.4f)\n", 
                           optimalPoint.getThreshold(), 
                           optimalPoint.getTpr(), 
                           optimalPoint.getFpr()));
            }
            report.append("\n");
        }
        
        // 分类解释
        report.append("4. 分类解释:\n");
        report.append(String.format("   TP (真正例): 正确预测为%s的样本数\n", className));
        report.append(String.format("   FP (假正例): 错误预测为%s的样本数\n", className));
        report.append(String.format("   FN (假负例): 错误预测为非%s的样本数\n", className));
        report.append(String.format("   TN (真负例): 正确预测为非%s的样本数\n", className));
        report.append("\n");
        
        return report.toString();
    }
    
    /**
     * 生成多分类模型评估报告
     * @param confusionMatrix 混淆矩阵
     * @param multiClassROCResult 多类别ROC结果
     * @return 评估报告字符串
     */
    public static String generateMultiClassReport(
            ConfusionMatrix confusionMatrix,
            MultiClassROCAnalysis.MultiClassROCResult multiClassROCResult) {
        
        StringBuilder report = new StringBuilder();
        report.append("=== 多分类模型评估报告 ===\n\n");
        
        // 基本统计信息
        report.append("1. 基本统计信息:\n");
        report.append(String.format("   总样本数: %d\n", confusionMatrix.getTotalCount()));
        report.append(String.format("   整体准确率: %.4f\n", confusionMatrix.getAccuracy()));
        report.append("\n");
        
        // 每个类别的详细指标
        report.append("2. 各类别详细指标:\n");
        String[] labels = confusionMatrix.getLabels();
        double[] precisions = confusionMatrix.getPrecisionPerClass();
        double[] recalls = confusionMatrix.getRecallPerClass();
        double[] f1Scores = confusionMatrix.getF1ScorePerClass();
        
        for (int i = 0; i < labels.length; i++) {
            report.append(String.format("   类别 %s:\n", labels[i]));
            report.append(String.format("     精确率: %.4f\n", precisions[i]));
            report.append(String.format("     召回率: %.4f\n", recalls[i]));
            report.append(String.format("     F1分数: %.4f\n", f1Scores[i]));
            report.append("\n");
        }
        
        // 混淆矩阵
        report.append("3. 混淆矩阵:\n");
        int[][] matrix = confusionMatrix.getMatrix();
        
        // 表头
        report.append("   Actual\\Predicted");
        for (String label : labels) {
            report.append(String.format("\t%s", label));
        }
        report.append("\n");
        
        // 矩阵内容
        for (int i = 0; i < matrix.length; i++) {
            report.append(String.format("   %s", labels[i]));
            for (int j = 0; j < matrix[i].length; j++) {
                report.append(String.format("\t%d", matrix[i][j]));
            }
            report.append("\n");
        }
        report.append("\n");
        
        // ROC分析结果
        if (multiClassROCResult != null) {
            report.append("4. ROC分析结果:\n");
            report.append(String.format("   宏平均AUC: %.4f\n", 
                       multiClassROCResult.getMacroAveragedAUC()));
            report.append(String.format("   微平均AUC: %.4f\n", 
                       multiClassROCResult.getMicroAveragedAUC()));
            report.append("\n");
        }
        
        return report.toString();
    }
}
```

## 11.4.5 实际应用示例

下面是一个完整的使用示例，展示如何在实际项目中应用这些工具：

```java
/**
 * 模型评估应用示例
 */
public class ModelEvaluationExample {
    
    public static void main(String[] args) {
        // 模拟真实标签和预测结果
        int[] trueLabels = {0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0};
        int[] predictions = {0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0};
        double[] probabilities = {0.2, 0.8, 0.6, 0.3, 0.9, 0.1, 0.7, 0.85, 
                                 0.55, 0.25, 0.75, 0.15, 0.4, 0.88, 0.35};
        
        // 1. 构建混淆矩阵
        ConfusionMatrix confusionMatrix = new ConfusionMatrix();
        confusionMatrix.update(trueLabels, predictions);
        
        // 2. 计算ROC曲线
        List<ROCAnalysis.ROCPoint> rocPoints = ROCAnalysis.calculateROCPoints(
            trueLabels, probabilities);
        
        // 3. 计算AUC
        double auc = ROCAnalysis.calculateAUC(rocPoints);
        
        // 4. 生成评估报告
        String report = ModelEvaluationReport.generateBinaryClassificationReport(
            confusionMatrix, rocPoints, "Positive");
        
        System.out.println(report);
        
        // 5. 输出关键指标
        System.out.println("=== 关键指标 ===");
        System.out.printf("准确率: %.4f\n", confusionMatrix.getAccuracy());
        System.out.printf("精确率: %.4f\n", confusionMatrix.getPrecision());
        System.out.printf("召回率: %.4f\n", confusionMatrix.getRecall());
        System.out.printf("F1分数: %.4f\n", confusionMatrix.getF1Score());
        System.out.printf("AUC值: %.4f\n", auc);
        
        // 打印混淆矩阵
        System.out.println("\n=== 混淆矩阵 ===");
        confusionMatrix.printMatrix();
        
        // 打印ROC曲线点
        System.out.println("\n=== ROC曲线点 ===");
        for (ROCAnalysis.ROCPoint point : rocPoints) {
            System.out.printf("FPR: %.4f, TPR: %.4f, Threshold: %.4f\n",
                point.getFpr(), point.getTpr(), point.getThreshold());
        }
    }
}
```

## 总结

本节详细介绍了混淆矩阵和ROC分析这两种重要的模型评估工具：

1. **混淆矩阵**：提供了模型在各个类别上预测结果的详细视图，特别适合分析类别不平衡问题
2. **ROC曲线**：通过可视化的方式展示了模型在不同阈值下的敏感性和特异性权衡
3. **AUC指标**：提供了一个单一数值来衡量模型的整体性能
4. **多类别扩展**：介绍了处理多分类问题的ROC分析方法

在实际应用中，我们应该结合使用这些工具，从多个角度全面评估模型性能。混淆矩阵帮助我们理解模型的具体错误模式，而ROC分析则提供了模型判别能力的整体评价。通过这些工具的综合运用，我们可以更好地诊断模型问题，优化模型性能，并做出更明智的决策。