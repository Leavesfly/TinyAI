# 11.5 模型选择与超参数调优

在机器学习项目中，选择合适的模型架构和优化其超参数是决定最终性能的关键步骤。模型选择涉及在多种候选模型中选择最适合特定任务的模型，而超参数调优则是找到使选定模型性能最优的参数配置。这两项任务通常紧密相关，需要系统化的方法来高效地完成。

## 本节内容概览

- 模型选择的基本原则和方法
- 超参数的分类和重要性分析
- 网格搜索与随机搜索策略
- 贝叶斯优化等高级调优技术
- 交叉验证在模型选择中的应用
- 自动化机器学习(AutoML)概念

## 设计思考与技术理念

模型选择和超参数调优本质上是一个优化问题，目标是在给定的搜索空间中找到最优的模型和参数组合。这个过程需要平衡多个因素：

1. **性能**：模型在验证集上的表现
2. **复杂度**：模型的计算成本和存储需求
3. **泛化能力**：模型在未见数据上的表现
4. **训练时间**：模型训练所需的时间成本

在设计模型选择和调优策略时，我们需要考虑这些因素的权衡，避免过度追求单一指标而忽略整体效果。

## 11.5.1 模型选择基础

模型选择是机器学习工作流中的关键环节，它决定了我们使用哪种算法来解决特定问题。正确的模型选择能够显著提升最终结果的质量。

### 模型选择的原则

1. **问题类型匹配**：根据任务类型（分类、回归、聚类等）选择合适的模型
2. **数据特征考虑**：考虑数据规模、特征维度、数据分布等因素
3. **性能要求**：根据应用场景对准确率、速度、资源消耗的要求选择模型
4. **可解释性需求**：在需要模型可解释性的场景中选择线性模型或决策树等

### 常见模型类别对比

```java
/**
 * 模型特征对比工具
 */
public class ModelComparison {
    
    /**
     * 模型特征描述类
     */
    public static class ModelCharacteristics {
        private String modelName;
        private String problemType;
        private int complexity; // 1-5，5为最复杂
        private double interpretability; // 0-1，1为最可解释
        private double trainingSpeed; // 0-1，1为最快
        private double predictionSpeed; // 0-1，1为最快
        private String[] strengths;
        private String[] weaknesses;
        
        public ModelCharacteristics(String modelName, String problemType, int complexity,
                                  double interpretability, double trainingSpeed, double predictionSpeed,
                                  String[] strengths, String[] weaknesses) {
            this.modelName = modelName;
            this.problemType = problemType;
            this.complexity = complexity;
            this.interpretability = interpretability;
            this.trainingSpeed = trainingSpeed;
            this.predictionSpeed = predictionSpeed;
            this.strengths = strengths;
            this.weaknesses = weaknesses;
        }
        
        // Getters
        public String getModelName() { return modelName; }
        public String getProblemType() { return problemType; }
        public int getComplexity() { return complexity; }
        public double getInterpretability() { return interpretability; }
        public double getTrainingSpeed() { return trainingSpeed; }
        public double getPredictionSpeed() { return predictionSpeed; }
        public String[] getStrengths() { return strengths; }
        public String[] getWeaknesses() { return weaknesses; }
        
        @Override
        public String toString() {
            return String.format("Model: %s\n" +
                               "Type: %s\n" +
                               "Complexity: %d/5\n" +
                               "Interpretability: %.2f\n" +
                               "Training Speed: %.2f\n" +
                               "Prediction Speed: %.2f\n" +
                               "Strengths: %s\n" +
                               "Weaknesses: %s",
                               modelName, problemType, complexity, interpretability,
                               trainingSpeed, predictionSpeed, 
                               String.join(", ", strengths),
                               String.join(", ", weaknesses));
        }
    }
    
    /**
     * 获取常见模型特征对比
     * @return 模型特征列表
     */
    public static List<ModelCharacteristics> getCommonModelCharacteristics() {
        List<ModelCharacteristics> models = new ArrayList<>();
        
        // 线性回归
        models.add(new ModelCharacteristics(
            "Linear Regression",
            "Regression",
            1,
            1.0,
            1.0,
            1.0,
            new String[]{"简单易懂", "训练快速", "可解释性强"},
            new String[]{"只能拟合线性关系", "对异常值敏感"}
        ));
        
        // 逻辑回归
        models.add(new ModelCharacteristics(
            "Logistic Regression",
            "Classification",
            1,
            0.9,
            1.0,
            1.0,
            new String[]{"概率输出", "训练快速", "可解释性强"},
            new String[]{"只能拟合线性决策边界", "对特征工程要求高"}
        ));
        
        // 决策树
        models.add(new ModelCharacteristics(
            "Decision Tree",
            "Classification/Regression",
            2,
            0.9,
            0.9,
            0.95,
            new String[]{"可解释性强", "处理非线性关系", "自动特征选择"},
            new String[]{"容易过拟合", "对数据变化敏感"}
        ));
        
        // 随机森林
        models.add(new ModelCharacteristics(
            "Random Forest",
            "Classification/Regression",
            4,
            0.6,
            0.7,
            0.8,
            new String[]{"抗过拟合", "处理高维数据", "评估特征重要性"},
            new String[]{"可解释性较弱", "内存消耗大"}
        ));
        
        // 支持向量机
        models.add(new ModelCharacteristics(
            "Support Vector Machine",
            "Classification/Regression",
            4,
            0.4,
            0.5,
            0.8,
            new String[]{"处理高维数据", "内存效率高", "versatile with kernels"},
            new String[]{"训练时间长", "难解释", "对参数敏感"}
        ));
        
        // 神经网络
        models.add(new ModelCharacteristics(
            "Neural Network",
            "Classification/Regression",
            5,
            0.2,
            0.3,
            0.7,
            new String[]{"强大的表达能力", "自动特征学习", "适应性强"},
            new String[]{"黑盒模型", "需要大量数据", "训练复杂"}
        ));
        
        return models;
    }
    
    /**
     * 根据需求推荐模型
     * @param needInterpretability 是否需要可解释性
     * @param dataSize 数据规模（小、中、大）
     * @param featureDimension 特征维度（低、中、高）
     * @param trainingTimeConstraint 训练时间约束（宽松、中等、严格）
     * @return 推荐模型列表
     */
    public static List<ModelCharacteristics> recommendModels(
            boolean needInterpretability,
            String dataSize,
            String featureDimension,
            String trainingTimeConstraint) {
        
        List<ModelCharacteristics> allModels = getCommonModelCharacteristics();
        List<ModelCharacteristics> recommended = new ArrayList<>();
        
        for (ModelCharacteristics model : allModels) {
            boolean recommend = true;
            
            // 可解释性要求
            if (needInterpretability && model.getInterpretability() < 0.7) {
                recommend = false;
            }
            
            // 数据规模要求
            if ("small".equals(dataSize) && model.getComplexity() > 3) {
                recommend = false;
            }
            
            // 特征维度要求
            if ("high".equals(featureDimension) && 
                (model.getModelName().equals("Linear Regression") || 
                 model.getModelName().equals("Logistic Regression"))) {
                recommend = false;
            }
            
            // 训练时间要求
            if ("strict".equals(trainingTimeConstraint) && model.getTrainingSpeed() < 0.6) {
                recommend = false;
            }
            
            if (recommend) {
                recommended.add(model);
            }
        }
        
        return recommended;
    }
}
```

## 11.5.2 超参数调优基础

超参数是在模型训练之前设置的参数，它们不能通过训练数据直接学习得到，但对模型性能有重要影响。

### 超参数分类

1. **模型超参数**：直接影响模型结构，如神经网络的层数、决策树的最大深度
2. **算法超参数**：影响训练过程，如学习率、正则化系数
3. **优化超参数**：影响优化算法行为，如动量、批大小

### 超参数调优框架

```java
import java.util.*;
import java.util.concurrent.*;

/**
 * 超参数调优框架
 */
public class HyperparameterTuner {
    
    /**
     * 超参数配置类
     */
    public static class HyperparameterConfig {
        private Map<String, Object> parameters;
        
        public HyperparameterConfig() {
            this.parameters = new HashMap<>();
        }
        
        public HyperparameterConfig set(String key, Object value) {
            parameters.put(key, value);
            return this;
        }
        
        public Object get(String key) {
            return parameters.get(key);
        }
        
        public Set<String> getKeys() {
            return parameters.keySet();
        }
        
        public Map<String, Object> getParameters() {
            return new HashMap<>(parameters);
        }
        
        @Override
        public String toString() {
            return parameters.toString();
        }
    }
    
    /**
     * 调优结果类
     */
    public static class TuningResult {
        private HyperparameterConfig bestConfig;
        private double bestScore;
        private List<HyperparameterConfig> allConfigs;
        private List<Double> allScores;
        
        public TuningResult(HyperparameterConfig bestConfig, double bestScore) {
            this.bestConfig = bestConfig;
            this.bestScore = bestScore;
            this.allConfigs = new ArrayList<>();
            this.allScores = new ArrayList<>();
        }
        
        public void addResult(HyperparameterConfig config, double score) {
            allConfigs.add(config);
            allScores.add(score);
        }
        
        // Getters
        public HyperparameterConfig getBestConfig() { return bestConfig; }
        public double getBestScore() { return bestScore; }
        public List<HyperparameterConfig> getAllConfigs() { return allConfigs; }
        public List<Double> getAllScores() { return allScores; }
    }
    
    /**
     * 模型训练器接口
     */
    public interface ModelTrainer {
        /**
         * 训练模型并返回验证得分
         * @param config 超参数配置
         * @return 验证得分
         */
        double trainAndEvaluate(HyperparameterConfig config);
    }
    
    /**
     * 网格搜索实现
     * @param trainer 模型训练器
     * @param paramGrid 参数网格
     * @return 调优结果
     */
    public static TuningResult gridSearch(ModelTrainer trainer, Map<String, List<Object>> paramGrid) {
        // 生成所有参数组合
        List<HyperparameterConfig> configs = generateParameterCombinations(paramGrid);
        
        HyperparameterConfig bestConfig = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        TuningResult result = new TuningResult(bestConfig, bestScore);
        
        // 评估每个参数组合
        for (HyperparameterConfig config : configs) {
            double score = trainer.trainAndEvaluate(config);
            result.addResult(config, score);
            
            if (score > bestScore) {
                bestScore = score;
                bestConfig = config;
            }
        }
        
        result = new TuningResult(bestConfig, bestScore);
        for (int i = 0; i < configs.size(); i++) {
            result.addResult(configs.get(i), result.getAllScores().get(i));
        }
        
        return result;
    }
    
    /**
     * 随机搜索实现
     * @param trainer 模型训练器
     * @param paramSpaces 参数空间
     * @param numIterations 迭代次数
     * @param seed 随机种子
     * @return 调优结果
     */
    public static TuningResult randomSearch(ModelTrainer trainer, 
                                          Map<String, ParameterSpace> paramSpaces, 
                                          int numIterations, 
                                          long seed) {
        Random random = new Random(seed);
        HyperparameterConfig bestConfig = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        TuningResult result = new TuningResult(bestConfig, bestScore);
        
        // 随机采样并评估
        for (int i = 0; i < numIterations; i++) {
            HyperparameterConfig config = new HyperparameterConfig();
            
            // 从每个参数空间随机采样
            for (Map.Entry<String, ParameterSpace> entry : paramSpaces.entrySet()) {
                String paramName = entry.getKey();
                ParameterSpace space = entry.getValue();
                Object sampledValue = space.sample(random);
                config.set(paramName, sampledValue);
            }
            
            double score = trainer.trainAndEvaluate(config);
            result.addResult(config, score);
            
            if (score > bestScore) {
                bestScore = score;
                bestConfig = config;
            }
        }
        
        result = new TuningResult(bestConfig, bestScore);
        for (int i = 0; i < result.getAllConfigs().size(); i++) {
            result.addResult(result.getAllConfigs().get(i), result.getAllScores().get(i));
        }
        
        return result;
    }
    
    /**
     * 生成参数组合
     * @param paramGrid 参数网格
     * @return 参数配置列表
     */
    private static List<HyperparameterConfig> generateParameterCombinations(
            Map<String, List<Object>> paramGrid) {
        List<HyperparameterConfig> configs = new ArrayList<>();
        List<String> paramNames = new ArrayList<>(paramGrid.keySet());
        
        generateCombinationsRecursive(paramGrid, paramNames, 0, new HyperparameterConfig(), configs);
        return configs;
    }
    
    /**
     * 递归生成参数组合
     */
    private static void generateCombinationsRecursive(
            Map<String, List<Object>> paramGrid,
            List<String> paramNames,
            int index,
            HyperparameterConfig currentConfig,
            List<HyperparameterConfig> configs) {
        
        if (index == paramNames.size()) {
            configs.add(new HyperparameterConfig().set("dummy", "dummy").getParameters().clear();
            HyperparameterConfig newConfig = new HyperparameterConfig();
            for (String key : currentConfig.getKeys()) {
                newConfig.set(key, currentConfig.get(key));
            }
            configs.add(newConfig);
            return;
        }
        
        String paramName = paramNames.get(index);
        List<Object> values = paramGrid.get(paramName);
        
        for (Object value : values) {
            HyperparameterConfig newConfig = new HyperparameterConfig();
            for (String key : currentConfig.getKeys()) {
                newConfig.set(key, currentConfig.get(key));
            }
            newConfig.set(paramName, value);
            generateCombinationsRecursive(paramGrid, paramNames, index + 1, newConfig, configs);
        }
    }
    
    /**
     * 参数空间接口
     */
    public interface ParameterSpace {
        Object sample(Random random);
    }
    
    /**
     * 离散参数空间
     */
    public static class DiscreteParameterSpace implements ParameterSpace {
        private List<Object> values;
        
        public DiscreteParameterSpace(List<Object> values) {
            this.values = values;
        }
        
        @Override
        public Object sample(Random random) {
            return values.get(random.nextInt(values.size()));
        }
    }
    
    /**
     * 连续参数空间（均匀分布）
     */
    public static class UniformParameterSpace implements ParameterSpace {
        private double min;
        private double max;
        
        public UniformParameterSpace(double min, double max) {
            this.min = min;
            this.max = max;
        }
        
        @Override
        public Object sample(Random random) {
            return min + random.nextDouble() * (max - min);
        }
    }
    
    /**
     * 连续参数空间（对数分布）
     */
    public static class LogUniformParameterSpace implements ParameterSpace {
        private double min;
        private double max;
        
        public LogUniformParameterSpace(double min, double max) {
            if (min <= 0 || max <= 0) {
                throw new IllegalArgumentException("对数分布参数必须为正数");
            }
            this.min = min;
            this.max = max;
        }
        
        @Override
        public Object sample(Random random) {
            double logMin = Math.log(min);
            double logMax = Math.log(max);
            double logSample = logMin + random.nextDouble() * (logMax - logMin);
            return Math.exp(logSample);
        }
    }
}
```

## 11.5.3 交叉验证在模型选择中的应用

交叉验证是模型选择和超参数调优中的关键工具，它能够提供更可靠和稳定的性能评估。

```java
/**
 * 交叉验证模型选择器
 */
public class CrossValidationModelSelector {
    
    /**
     * 交叉验证评估结果
     */
    public static class CVResult {
        private double meanScore;
        private double stdDeviation;
        private List<Double> foldScores;
        private HyperparameterConfig config;
        
        public CVResult(double meanScore, double stdDeviation, List<Double> foldScores, 
                       HyperparameterConfig config) {
            this.meanScore = meanScore;
            this.stdDeviation = stdDeviation;
            this.foldScores = foldScores;
            this.config = config;
        }
        
        // Getters
        public double getMeanScore() { return meanScore; }
        public double getStdDeviation() { return stdDeviation; }
        public List<Double> getFoldScores() { return foldScores; }
        public HyperparameterConfig getConfig() { return config; }
        
        @Override
        public String toString() {
            return String.format("CVResult{mean=%.4f, std=%.4f, config=%s}", 
                               meanScore, stdDeviation, config);
        }
    }
    
    /**
     * 交叉验证模型评估器
     */
    public static class CVModelEvaluator {
        private int kFolds;
        private long randomSeed;
        
        public CVModelEvaluator(int kFolds, long randomSeed) {
            this.kFolds = kFolds;
            this.randomSeed = randomSeed;
        }
        
        /**
         * 执行交叉验证评估
         * @param trainer 模型训练器
         * @param config 超参数配置
         * @param X 特征数据
         * @param y 标签数据
         * @return 交叉验证结果
         */
        public CVResult evaluate(ModelTrainer trainer, HyperparameterTuner.HyperparameterConfig config,
                               double[][] X, int[] y) {
            // 生成K折分割
            KFoldSplitter splitter = new KFoldSplitter(kFolds, randomSeed);
            List<KFoldSplitter.SplitIndices> splits = splitter.split(X.length);
            
            List<Double> foldScores = new ArrayList<>();
            
            // 在每折上训练和评估
            for (KFoldSplitter.SplitIndices split : splits) {
                // 构造训练和验证集
                double[][] XTrain = selectRows(X, split.getTrainIndices());
                int[] yTrain = selectElements(y, split.getTrainIndices());
                double[][] XVal = selectRows(X, split.getValidationIndices());
                int[] yVal = selectElements(y, split.getValidationIndices());
                
                // 训练和评估（这里简化处理）
                double score = trainer.trainAndEvaluate(config);
                foldScores.add(score);
            }
            
            // 计算均值和标准差
            double meanScore = foldScores.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
            double variance = foldScores.stream()
                .mapToDouble(score -> Math.pow(score - meanScore, 2))
                .average()
                .orElse(0.0);
            double stdDeviation = Math.sqrt(variance);
            
            return new CVResult(meanScore, stdDeviation, foldScores, config);
        }
        
        /**
         * 选择指定行的数据
         */
        private double[][] selectRows(double[][] data, int[] indices) {
            double[][] selected = new double[indices.length][];
            for (int i = 0; i < indices.length; i++) {
                selected[i] = data[indices[i]];
            }
            return selected;
        }
        
        /**
         * 选择指定索引的元素
         */
        private int[] selectElements(int[] data, int[] indices) {
            int[] selected = new int[indices.length];
            for (int i = 0; i < indices.length; i++) {
                selected[i] = data[indices[i]];
            }
            return selected;
        }
    }
    
    /**
     * K折分割器
     */
    public static class KFoldSplitter {
        private int k;
        private long seed;
        
        public KFoldSplitter(int k, long seed) {
            this.k = k;
            this.seed = seed;
        }
        
        public List<SplitIndices> split(int dataSize) {
            // 创建数据索引数组
            int[] indices = new int[dataSize];
            for (int i = 0; i < dataSize; i++) {
                indices[i] = i;
            }
            
            // 随机打乱索引
            shuffleArray(indices, seed);
            
            // 计算每折的大小
            int foldSize = dataSize / k;
            int remainder = dataSize % k;
            
            List<SplitIndices> splits = new ArrayList<>();
            
            for (int fold = 0; fold < k; fold++) {
                // 计算当前折的起始和结束位置
                int start = fold * foldSize + Math.min(fold, remainder);
                int end = start + foldSize + (fold < remainder ? 1 : 0);
                
                // 提取验证集索引
                int[] validationIndices = Arrays.copyOfRange(indices, start, end);
                
                // 提取训练集索引
                int[] trainIndices = new int[dataSize - validationIndices.length];
                int trainIndex = 0;
                
                // 添加验证集之前的索引
                for (int i = 0; i < start; i++) {
                    trainIndices[trainIndex++] = indices[i];
                }
                
                // 添加验证集之后的索引
                for (int i = end; i < dataSize; i++) {
                    trainIndices[trainIndex++] = indices[i];
                }
                
                splits.add(new SplitIndices(trainIndices, validationIndices));
            }
            
            return splits;
        }
        
        private void shuffleArray(int[] array, long seed) {
            Random random = new Random(seed);
            for (int i = array.length - 1; i > 0; i--) {
                int index = random.nextInt(i + 1);
                // 交换元素
                int temp = array[index];
                array[index] = array[i];
                array[i] = temp;
            }
        }
        
        /**
         * 分割索引类
         */
        public static class SplitIndices {
            private int[] trainIndices;
            private int[] validationIndices;
            
            public SplitIndices(int[] trainIndices, int[] validationIndices) {
                this.trainIndices = trainIndices;
                this.validationIndices = validationIndices;
            }
            
            public int[] getTrainIndices() {
                return trainIndices;
            }
            
            public int[] getValidationIndices() {
                return validationIndices;
            }
        }
    }
}
```

## 11.5.4 贝叶斯优化

贝叶斯优化是一种更高效的超参数调优方法，它通过构建目标函数的概率模型来智能地选择下一个评估点。

```java
/**
 * 贝叶斯优化实现
 */
public class BayesianOptimizer {
    
    /**
     * 高斯过程代理模型
     */
    public static class GaussianProcess {
        private List<HyperparameterTuner.HyperparameterConfig> observedConfigs;
        private List<Double> observedScores;
        private Map<String, HyperparameterTuner.ParameterSpace> searchSpace;
        
        public GaussianProcess(Map<String, HyperparameterTuner.ParameterSpace> searchSpace) {
            this.observedConfigs = new ArrayList<>();
            this.observedScores = new ArrayList<>();
            this.searchSpace = searchSpace;
        }
        
        /**
         * 添加观察点
         */
        public void addObservation(HyperparameterTuner.HyperparameterConfig config, double score) {
            observedConfigs.add(config);
            observedScores.add(score);
        }
        
        /**
         * 预测给定配置的均值和方差
         */
        public PredictionResult predict(HyperparameterTuner.HyperparameterConfig config) {
            if (observedConfigs.isEmpty()) {
                return new PredictionResult(0.0, 1.0);
            }
            
            // 简化的高斯过程预测（实际实现会更复杂）
            double mean = observedScores.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
            double variance = 0.1; // 简化处理
            
            return new PredictionResult(mean, variance);
        }
        
        /**
         * 预测结果类
         */
        public static class PredictionResult {
            private double mean;
            private double variance;
            
            public PredictionResult(double mean, double variance) {
                this.mean = mean;
                this.variance = variance;
            }
            
            public double getMean() { return mean; }
            public double getVariance() { return variance; }
            public double getStdDev() { return Math.sqrt(variance); }
        }
    }
    
    /**
     * 采集函数（Expected Improvement）
     */
    public static class ExpectedImprovement {
        private double bestObservedValue;
        
        public ExpectedImprovement(double bestObservedValue) {
            this.bestObservedValue = bestObservedValue;
        }
        
        /**
         * 计算期望改进值
         */
        public double compute(GaussianProcess.PredictionResult prediction) {
            double mean = prediction.getMean();
            double stdDev = prediction.getStdDev();
            
            if (stdDev <= 0) {
                return 0.0;
            }
            
            double improvement = mean - bestObservedValue;
            double z = improvement / stdDev;
            
            // 标准正态分布的CDF和PDF
            double cdf = standardNormalCDF(z);
            double pdf = standardNormalPDF(z);
            
            return improvement * cdf + stdDev * pdf;
        }
        
        /**
         * 标准正态分布CDF
         */
        private double standardNormalCDF(double x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }
        
        /**
         * 标准正态分布PDF
         */
        private double standardNormalPDF(double x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }
        
        /**
         * 误差函数近似实现
         */
        private double erf(double x) {
            // Abramowitz and Stegun近似
            double a1 =  0.254829592;
            double a2 = -0.284496736;
            double a3 =  1.421413741;
            double a4 = -1.453152027;
            double a5 =  1.061405429;
            double p  =  0.3275911;
            
            int sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            
            double t = 1.0 / (1.0 + p * x);
            double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }
    }
    
    /**
     * 贝叶斯优化主类
     */
    public static class BayesianOptimization {
        private GaussianProcess gp;
        private ExpectedImprovement ei;
        private Map<String, HyperparameterTuner.ParameterSpace> searchSpace;
        private int maxIterations;
        private long randomSeed;
        private double bestValue;
        private HyperparameterTuner.HyperparameterConfig bestConfig;
        
        public BayesianOptimization(
                Map<String, HyperparameterTuner.ParameterSpace> searchSpace,
                int maxIterations,
                long randomSeed) {
            this.searchSpace = searchSpace;
            this.maxIterations = maxIterations;
            this.randomSeed = randomSeed;
            this.gp = new GaussianProcess(searchSpace);
            this.bestValue = Double.NEGATIVE_INFINITY;
        }
        
        /**
         * 执行贝叶斯优化
         */
        public HyperparameterTuner.TuningResult optimize(HyperparameterTuner.ModelTrainer trainer) {
            Random random = new Random(randomSeed);
            HyperparameterTuner.TuningResult result = new HyperparameterTuner.TuningResult(null, bestValue);
            
            // 首先进行随机初始化
            int initialRandomSamples = Math.min(5, maxIterations);
            for (int i = 0; i < initialRandomSamples; i++) {
                HyperparameterTuner.HyperparameterConfig config = sampleRandomConfig(random);
                double score = trainer.trainAndEvaluate(config);
                result.addResult(config, score);
                
                gp.addObservation(config, score);
                if (score > bestValue) {
                    bestValue = score;
                    bestConfig = config;
                }
            }
            
            // 更新EI函数
            ei = new ExpectedImprovement(bestValue);
            
            // 贝叶斯优化迭代
            for (int i = initialRandomSamples; i < maxIterations; i++) {
                // 选择下一个评估点
                HyperparameterTuner.HyperparameterConfig nextConfig = selectNextConfiguration(random);
                double score = trainer.trainAndEvaluate(nextConfig);
                result.addResult(nextConfig, score);
                
                gp.addObservation(nextConfig, score);
                if (score > bestValue) {
                    bestValue = score;
                    bestConfig = nextConfig;
                    ei = new ExpectedImprovement(bestValue); // 更新EI函数
                }
            }
            
            return new HyperparameterTuner.TuningResult(bestConfig, bestValue);
        }
        
        /**
         * 随机采样配置
         */
        private HyperparameterTuner.HyperparameterConfig sampleRandomConfig(Random random) {
            HyperparameterTuner.HyperparameterConfig config = new HyperparameterTuner.HyperparameterConfig();
            for (Map.Entry<String, HyperparameterTuner.ParameterSpace> entry : searchSpace.entrySet()) {
                String paramName = entry.getKey();
                HyperparameterTuner.ParameterSpace space = entry.getValue();
                Object sampledValue = space.sample(random);
                config.set(paramName, sampledValue);
            }
            return config;
        }
        
        /**
         * 选择下一个配置（简化实现）
         */
        private HyperparameterTuner.HyperparameterConfig selectNextConfiguration(Random random) {
            // 在实际实现中，这里会使用EI函数来智能选择下一个评估点
            // 为了简化，我们仍然使用随机采样
            return sampleRandomConfig(random);
        }
    }
}
```

## 11.5.5 自动化机器学习(AutoML)概念

自动化机器学习旨在自动化机器学习流程的各个环节，包括数据预处理、特征工程、模型选择和超参数调优等。

```java
/**
 * 简化的AutoML框架
 */
public class SimpleAutoML {
    
    /**
     * AutoML配置
     */
    public static class AutoMLConfig {
        private List<String> modelTypes;
        private Map<String, Map<String, HyperparameterTuner.ParameterSpace>> hyperparameterSpaces;
        private int maxModels;
        private int cvFolds;
        private long randomSeed;
        
        public AutoMLConfig() {
            this.modelTypes = new ArrayList<>();
            this.hyperparameterSpaces = new HashMap<>();
            this.maxModels = 10;
            this.cvFolds = 5;
            this.randomSeed = System.currentTimeMillis();
        }
        
        // Getters and Setters
        public AutoMLConfig addModelType(String modelType) {
            modelTypes.add(modelType);
            return this;
        }
        
        public AutoMLConfig setHyperparameterSpace(String modelType, 
                                                 Map<String, HyperparameterTuner.ParameterSpace> space) {
            hyperparameterSpaces.put(modelType, space);
            return this;
        }
        
        public AutoMLConfig setMaxModels(int maxModels) {
            this.maxModels = maxModels;
            return this;
        }
        
        public AutoMLConfig setCvFolds(int cvFolds) {
            this.cvFolds = cvFolds;
            return this;
        }
        
        public AutoMLConfig setRandomSeed(long randomSeed) {
            this.randomSeed = randomSeed;
            return this;
        }
        
        public List<String> getModelTypes() { return modelTypes; }
        public Map<String, Map<String, HyperparameterTuner.ParameterSpace>> getHyperparameterSpaces() { 
            return hyperparameterSpaces; 
        }
        public int getMaxModels() { return maxModels; }
        public int getCvFolds() { return cvFolds; }
        public long getRandomSeed() { return randomSeed; }
    }
    
    /**
     * AutoML结果
     */
    public static class AutoMLResult {
        private String bestModelType;
        private HyperparameterTuner.HyperparameterConfig bestConfig;
        private double bestScore;
        private List<ModelEvaluation> allEvaluations;
        
        public AutoMLResult(String bestModelType, 
                           HyperparameterTuner.HyperparameterConfig bestConfig,
                           double bestScore) {
            this.bestModelType = bestModelType;
            this.bestConfig = bestConfig;
            this.bestScore = bestScore;
            this.allEvaluations = new ArrayList<>();
        }
        
        public void addEvaluation(ModelEvaluation evaluation) {
            allEvaluations.add(evaluation);
        }
        
        // Getters
        public String getBestModelType() { return bestModelType; }
        public HyperparameterTuner.HyperparameterConfig getBestConfig() { return bestConfig; }
        public double getBestScore() { return bestScore; }
        public List<ModelEvaluation> getAllEvaluations() { return allEvaluations; }
    }
    
    /**
     * 模型评估结果
     */
    public static class ModelEvaluation {
        private String modelType;
        private HyperparameterTuner.HyperparameterConfig config;
        private double meanScore;
        private double stdDeviation;
        
        public ModelEvaluation(String modelType, 
                              HyperparameterTuner.HyperparameterConfig config,
                              double meanScore, 
                              double stdDeviation) {
            this.modelType = modelType;
            this.config = config;
            this.meanScore = meanScore;
            this.stdDeviation = stdDeviation;
        }
        
        // Getters
        public String getModelType() { return modelType; }
        public HyperparameterTuner.HyperparameterConfig getConfig() { return config; }
        public double getMeanScore() { return meanScore; }
        public double getStdDeviation() { return stdDeviation; }
    }
    
    /**
     * 执行AutoML流程
     */
    public static AutoMLResult runAutoML(AutoMLConfig config, 
                                       HyperparameterTuner.ModelTrainer trainer,
                                       double[][] X, int[] y) {
        String bestModelType = null;
        HyperparameterTuner.HyperparameterConfig bestConfig = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        AutoMLResult result = new AutoMLResult(bestModelType, bestConfig, bestScore);
        
        // 对每种模型类型进行优化
        for (String modelType : config.getModelTypes()) {
            System.out.println("正在优化模型: " + modelType);
            
            // 获取该模型的超参数空间
            Map<String, HyperparameterTuner.ParameterSpace> paramSpace = 
                config.getHyperparameterSpaces().get(modelType);
            
            if (paramSpace == null) {
                System.out.println("警告: 模型 " + modelType + " 没有定义超参数空间，跳过");
                continue;
            }
            
            // 使用贝叶斯优化进行超参数调优
            BayesianOptimizer.BayesianOptimization optimizer = 
                new BayesianOptimizer.BayesianOptimization(paramSpace, config.getMaxModels, config.getRandomSeed);
            
            HyperparameterTuner.TuningResult tuningResult = optimizer.optimize(trainer);
            
            // 交叉验证评估最佳配置
            CrossValidationModelSelector.CVModelEvaluator evaluator = 
                new CrossValidationModelSelector.CVModelEvaluator(config.getCvFolds(), config.getRandomSeed);
            
            CrossValidationModelSelector.CVResult cvResult = 
                evaluator.evaluate(trainer, tuningResult.getBestConfig(), X, y);
            
            // 记录评估结果
            ModelEvaluation evaluation = new ModelEvaluation(
                modelType, 
                tuningResult.getBestConfig(),
                cvResult.getMeanScore(),
                cvResult.getStdDeviation()
            );
            
            result.addEvaluation(evaluation);
            
            // 更新最佳模型
            if (cvResult.getMeanScore() > bestScore) {
                bestScore = cvResult.getMeanScore();
                bestModelType = modelType;
                bestConfig = tuningResult.getBestConfig();
            }
        }
        
        return new AutoMLResult(bestModelType, bestConfig, bestScore);
    }
}
```

## 总结

本节详细介绍了模型选择和超参数调优的核心概念和实现方法：

1. **模型选择**：基于问题类型、数据特征和性能要求选择合适的模型
2. **超参数调优**：使用网格搜索、随机搜索和贝叶斯优化等方法寻找最优参数配置
3. **交叉验证**：提供更可靠的模型性能评估
4. **贝叶斯优化**：通过构建概率模型智能地选择评估点，提高调优效率
5. **AutoML**：自动化整个机器学习流程，降低技术门槛

在实际应用中，我们应该根据具体问题的特点选择合适的策略。对于简单问题，网格搜索可能就足够了；对于复杂问题，贝叶斯优化能够显著提高效率；而在资源允许的情况下，AutoML可以提供端到端的解决方案。