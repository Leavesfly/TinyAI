# 17.6 综合项目：智能问答系统

> **设计思想**：通过完整的项目实践，整合RAG系统与知识管理的各项技术，构建功能完整的智能问答系统

## 项目概述

在本章的前几节中，我们学习了检索增强生成（RAG）的核心技术，包括RAG原理、文档向量化与相似度计算、知识图谱构建与维护、多模态检索以及智能推理等关键技术。为了将这些技术整合应用，本项目将指导读者构建一个完整的智能问答系统。

该系统将结合文本、图像和代码等多种模态的信息，利用知识图谱增强问答能力，并通过多步骤推理解决复杂问题，为用户提供准确、全面和智能的问答服务。

## 项目目标

完成本项目后，你将：

- ✅ **实现完整的RAG系统**：掌握检索器和生成器的集成实现
- ✅ **构建多模态问答能力**：具备处理文本、图像、代码等多模态查询的能力
- ✅ **实现知识图谱增强**：掌握知识图谱在问答系统中的应用
- ✅ **构建智能推理机制**：具备复杂问题的多步骤推理解决能力
- ✅ **实现系统优化**：掌握问答系统的性能优化和用户体验优化
- ✅ **具备系统部署能力**：能够将问答系统部署到生产环境

## 项目架构设计

### 系统架构

```mermaid
graph TB
    subgraph "输入层"
        A[文本查询<br/>Natural Language]
        B[图像查询<br/>Image Input]
        C[代码查询<br/>Code Query]
        D[多模态查询<br/>Multimodal Input]
    end
    
    subgraph "处理层"
        E[查询理解<br/>Query Understanding]
        F[多模态向量化<br/>Multimodal Embedding]
        G[知识检索<br/>Knowledge Retrieval]
        H[知识图谱<br/>Knowledge Graph]
        I[推理引擎<br/>Reasoning Engine]
        J[答案生成<br/>Answer Generation]
    end
    
    subgraph "存储层"
        K[向量数据库<br/>Vector Database]
        L[文档存储<br/>Document Store]
        M[知识图谱存储<br/>Graph Database]
        N[缓存系统<br/>Cache System]
    end
    
    subgraph "输出层"
        O[文本答案<br/>Text Response]
        P[可视化答案<br/>Visual Response]
        Q[结构化答案<br/>Structured Response]
    end
    
    A --> E
    B --> E
    C --> E
    D --> E
    E --> F
    F --> G
    G --> K
    G --> L
    H --> M
    I --> H
    J --> I
    K --> G
    L --> G
    M --> H
    N --> G
    G --> J
    H --> J
    I --> J
    J --> O
    J --> P
    J --> Q
```

## 核心实现

### 1. 智能问答系统主类

```java
public class IntelligentQAService {
    private MultimodalRetriever multimodalRetriever;
    private KnowledgeGraphEnhancer knowledgeGraphEnhancer;
    private IntelligentReasoner intelligentReasoner;
    private AnswerGenerator answerGenerator;
    private CacheManager cacheManager;
    private Configuration config;
    private Logger logger;
    
    public IntelligentQAService(Configuration config) {
        this.config = config;
        this.logger = Logger.getLogger("IntelligentQAService");
        initializeComponents();
    }
    
    private void initializeComponents() {
        try {
            // 初始化多模态检索器
            this.multimodalRetriever = new MultimodalRetriever(config);
            
            // 初始化知识图谱增强器
            this.knowledgeGraphEnhancer = new KnowledgeGraphEnhancer(config);
            
            // 初始化智能推理器
            this.intelligentReasoner = new IntelligentReasoner(config);
            
            // 初始化答案生成器
            this.answerGenerator = new AnswerGenerator(config);
            
            // 初始化缓存管理器
            this.cacheManager = new CacheManager(config);
            
            logger.info("Intelligent QA Service components initialized successfully");
        } catch (Exception e) {
            logger.severe("Failed to initialize Intelligent QA Service: " + e.getMessage());
            throw new RuntimeException("Initialization failed", e);
        }
    }
    
    public QAAnswer answerQuestion(QAQuery query) {
        long startTime = System.currentTimeMillis();
        String queryId = generateQueryId();
        
        try {
            // 1. 查询缓存
            QAAnswer cachedAnswer = cacheManager.getAnswer(query);
            if (cachedAnswer != null && !cachedAnswer.isExpired()) {
                logger.info("Cache hit for query: " + query.getQueryText());
                cachedAnswer.setSource("cache");
                return cachedAnswer;
            }
            
            // 2. 查询理解
            ProcessedQuery processedQuery = understandQuery(query);
            
            // 3. 多模态检索
            RetrievalResult retrievalResult = multimodalRetriever.retrieve(processedQuery);
            
            // 4. 知识图谱增强
            EnhancedRetrievalResult enhancedResult = 
                knowledgeGraphEnhancer.enhance(retrievalResult);
            
            // 5. 智能推理（如果需要）
            ReasoningResult reasoningResult = null;
            if (isComplexQuery(processedQuery)) {
                reasoningResult = intelligentReasoner.reason(processedQuery, enhancedResult);
            }
            
            // 6. 答案生成
            QAAnswer answer = answerGenerator.generate(
                processedQuery, enhancedResult, reasoningResult);
            
            // 7. 缓存答案
            cacheManager.cacheAnswer(query, answer);
            
            // 8. 记录日志
            long processingTime = System.currentTimeMillis() - startTime;
            logQueryProcessing(queryId, query, answer, processingTime);
            
            return answer;
        } catch (Exception e) {
            logger.severe("Error processing query: " + e.getMessage());
            return createErrorAnswer(e.getMessage());
        }
    }
    
    private ProcessedQuery understandQuery(QAQuery query) {
        // 查询理解逻辑
        QueryUnderstandingEngine understandingEngine = new QueryUnderstandingEngine();
        return understandingEngine.understand(query);
    }
    
    private boolean isComplexQuery(ProcessedQuery processedQuery) {
        // 判断是否为复杂查询，需要推理
        return processedQuery.getQueryType() == QueryType.CAUSAL || 
               processedQuery.getQueryType() == QueryType.PROCEDURAL ||
               processedQuery.getComplexity() > 70;
    }
    
    private String generateQueryId() {
        return "query_" + System.currentTimeMillis() + "_" + 
               Thread.currentThread().getId();
    }
    
    private void logQueryProcessing(String queryId, QAQuery query, 
                                  QAAnswer answer, long processingTime) {
        QueryLogEntry logEntry = new QueryLogEntry();
        logEntry.setQueryId(queryId);
        logEntry.setQueryText(query.getQueryText());
        logEntry.setAnswerText(answer.getAnswerText());
        logEntry.setProcessingTime(processingTime);
        logEntry.setSource(answer.getSource());
        logEntry.setConfidence(answer.getConfidence());
        logEntry.setTimestamp(System.currentTimeMillis());
        
        logger.info("Query processed - ID: " + queryId + 
                   ", Time: " + processingTime + "ms" +
                   ", Source: " + answer.getSource() +
                   ", Confidence: " + answer.getConfidence());
    }
    
    private QAAnswer createErrorAnswer(String errorMessage) {
        QAAnswer errorAnswer = new QAAnswer();
        errorAnswer.setAnswerText("抱歉，处理您的查询时遇到错误: " + errorMessage);
        errorAnswer.setConfidence("low");
        errorAnswer.setSource("system");
        errorAnswer.setError(true);
        return errorAnswer;
    }
    
    public void indexDocument(IndexableDocument document) {
        try {
            multimodalRetriever.indexDocument(document);
            knowledgeGraphEnhancer.updateKnowledgeGraph(document);
            logger.info("Document indexed successfully: " + document.getId());
        } catch (Exception e) {
            logger.severe("Failed to index document: " + e.getMessage());
            throw new RuntimeException("Document indexing failed", e);
        }
    }
    
    public SystemStats getSystemStats() {
        SystemStats stats = new SystemStats();
        stats.setTotalQueriesProcessed(cacheManager.getTotalQueries());
        stats.setCacheHitRate(cacheManager.getHitRate());
        stats.setAverageResponseTime(multimodalRetriever.getAverageResponseTime());
        stats.setTotalDocumentsIndexed(multimodalRetriever.getDocumentCount());
        stats.setKnowledgeGraphSize(knowledgeGraphEnhancer.getGraphSize());
        return stats;
    }
    
    public void clearCache() {
        cacheManager.clear();
        logger.info("Cache cleared");
    }
    
    public void shutdown() {
        try {
            multimodalRetriever.shutdown();
            knowledgeGraphEnhancer.shutdown();
            intelligentReasoner.shutdown();
            cacheManager.shutdown();
            logger.info("Intelligent QA Service shutdown completed");
        } catch (Exception e) {
            logger.severe("Error during shutdown: " + e.getMessage());
        }
    }
}

// 配置类
class Configuration {
    private Map<String, Object> properties;
    
    public Configuration() {
        this.properties = new HashMap<>();
        // 设置默认配置
        setProperty("cache.enabled", true);
        setProperty("cache.ttl", 3600000); // 1小时
        setProperty("retriever.topK", 10);
        setProperty("embedding.dimension", 512);
        setProperty("reasoning.maxSteps", 20);
    }
    
    public void setProperty(String key, Object value) {
        properties.put(key, value);
    }
    
    public <T> T getProperty(String key, Class<T> type) {
        Object value = properties.get(key);
        if (value != null && type.isInstance(value)) {
            return type.cast(value);
        }
        return null;
    }
    
    public <T> T getProperty(String key, T defaultValue) {
        Object value = properties.get(key);
        if (value != null) {
            try {
                return (T) value;
            } catch (ClassCastException e) {
                return defaultValue;
            }
        }
        return defaultValue;
    }
}
```

### 2. 查询处理模块

```java
public class QueryUnderstandingEngine {
    private TextPreprocessor textPreprocessor;
    private EntityRecognizer entityRecognizer;
    private IntentClassifier intentClassifier;
    private ComplexityAnalyzer complexityAnalyzer;
    
    public QueryUnderstandingEngine() {
        this.textPreprocessor = new TextPreprocessor();
        this.entityRecognizer = new EntityRecognizer();
        this.intentClassifier = new IntentClassifier();
        this.complexityAnalyzer = new ComplexityAnalyzer();
    }
    
    public ProcessedQuery understand(QAQuery query) {
        ProcessedQuery processedQuery = new ProcessedQuery();
        processedQuery.setOriginalQuery(query);
        
        // 1. 文本预处理
        String processedText = textPreprocessor.preprocess(query.getQueryText());
        processedQuery.setProcessedText(processedText);
        
        // 2. 实体识别
        List<RecognizedEntity> entities = entityRecognizer.recognize(processedText);
        processedQuery.setEntities(entities);
        
        // 3. 意图分类
        QueryIntent intent = intentClassifier.classify(processedText);
        processedQuery.setIntent(intent);
        
        // 4. 复杂度分析
        int complexity = complexityAnalyzer.analyze(processedText, entities);
        processedQuery.setComplexity(complexity);
        
        // 5. 查询类型识别
        QueryType queryType = identifyQueryType(processedText, intent);
        processedQuery.setQueryType(queryType);
        
        // 6. 关键词提取
        List<String> keywords = extractKeywords(processedText);
        processedQuery.setKeywords(keywords);
        
        return processedQuery;
    }
    
    private QueryType identifyQueryType(String text, QueryIntent intent) {
        String lowerText = text.toLowerCase();
        
        if (lowerText.contains("为什么") || lowerText.contains("原因")) {
            return QueryType.CAUSAL;
        } else if (lowerText.contains("如何") || lowerText.contains("步骤")) {
            return QueryType.PROCEDURAL;
        } else if (lowerText.contains("是否") || lowerText.contains("吗")) {
            return QueryType.EVALUATIVE;
        } else if (intent == QueryIntent.COMPARISON) {
            return QueryType.COMPARATIVE;
        } else {
            return QueryType.FACTUAL;
        }
    }
    
    private List<String> extractKeywords(String text) {
        // 简化的关键词提取
        List<String> keywords = new ArrayList<>();
        String[] words = text.split("\\s+");
        for (String word : words) {
            if (word.length() > 2) {
                keywords.add(word.toLowerCase());
            }
        }
        return keywords;
    }
}

// QA查询类
class QAQuery {
    private String queryText;
    private QueryModality modality;
    private Map<String, Object> context;
    private String sessionId;
    private long timestamp;
    
    public QAQuery(String queryText) {
        this.queryText = queryText;
        this.modality = QueryModality.TEXT;
        this.context = new HashMap<>();
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters and Setters
    public String getQueryText() { return queryText; }
    public void setQueryText(String queryText) { this.queryText = queryText; }
    
    public QueryModality getModality() { return modality; }
    public void setModality(QueryModality modality) { this.modality = modality; }
    
    public Map<String, Object> getContext() { return context; }
    public void addContext(String key, Object value) { this.context.put(key, value); }
    
    public String getSessionId() { return sessionId; }
    public void setSessionId(String sessionId) { this.sessionId = sessionId; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

enum QueryModality {
    TEXT, IMAGE, CODE, MULTIMODAL
}

// 处理后的查询类
class ProcessedQuery {
    private QAQuery originalQuery;
    private String processedText;
    private List<RecognizedEntity> entities;
    private QueryIntent intent;
    private QueryType queryType;
    private int complexity;
    private List<String> keywords;
    
    public ProcessedQuery() {
        this.entities = new ArrayList<>();
        this.keywords = new ArrayList<>();
    }
    
    // Getters and Setters
    public QAQuery getOriginalQuery() { return originalQuery; }
    public void setOriginalQuery(QAQuery originalQuery) { this.originalQuery = originalQuery; }
    
    public String getProcessedText() { return processedText; }
    public void setProcessedText(String processedText) { this.processedText = processedText; }
    
    public List<RecognizedEntity> getEntities() { return entities; }
    public void setEntities(List<RecognizedEntity> entities) { this.entities = entities; }
    
    public QueryIntent getIntent() { return intent; }
    public void setIntent(QueryIntent intent) { this.intent = intent; }
    
    public QueryType getQueryType() { return queryType; }
    public void setQueryType(QueryType queryType) { this.queryType = queryType; }
    
    public int getComplexity() { return complexity; }
    public void setComplexity(int complexity) { this.complexity = complexity; }
    
    public List<String> getKeywords() { return keywords; }
    public void setKeywords(List<String> keywords) { this.keywords = keywords; }
}

enum QueryIntent {
    INFORMATIONAL, PROCEDURAL, COMPARISON, EVALUATIVE, CREATIVE
}

enum QueryType {
    FACTUAL, CAUSAL, PROCEDURAL, COMPARATIVE, EVALUATIVE
}
```

### 3. 多模态检索模块

```java
public class MultimodalRetriever {
    private MultimodalEmbedder embedder;
    private MultimodalVectorDatabase vectorDB;
    private DocumentStore documentStore;
    private TextPreprocessor textPreprocessor;
    private ImagePreprocessor imagePreprocessor;
    private CodePreprocessor codePreprocessor;
    private Configuration config;
    private Logger logger;
    private AtomicLong totalQueries;
    private AtomicLong totalResponseTime;
    
    public MultimodalRetriever(Configuration config) {
        this.config = config;
        this.logger = Logger.getLogger("MultimodalRetriever");
        this.totalQueries = new AtomicLong(0);
        this.totalResponseTime = new AtomicLong(0);
        initializeComponents();
    }
    
    private void initializeComponents() {
        try {
            this.embedder = new MultimodalEmbedder(config);
            this.vectorDB = new MultimodalVectorDatabase(config);
            this.documentStore = new DocumentStore(config);
            this.textPreprocessor = new TextPreprocessor();
            this.imagePreprocessor = new ImagePreprocessor();
            this.codePreprocessor = new CodePreprocessor();
            
            logger.info("Multimodal Retriever initialized successfully");
        } catch (Exception e) {
            logger.severe("Failed to initialize Multimodal Retriever: " + e.getMessage());
            throw new RuntimeException("Initialization failed", e);
        }
    }
    
    public RetrievalResult retrieve(ProcessedQuery query) {
        long startTime = System.currentTimeMillis();
        totalQueries.incrementAndGet();
        
        try {
            // 1. 构建多模态查询数据
            MultimodalData queryData = buildQueryData(query);
            
            // 2. 向量化查询
            float[] queryVector = embedder.embed(queryData);
            
            // 3. 向量检索
            int topK = config.getProperty("retriever.topK", 10);
            List<VectorSearchResult> searchResults = vectorDB.search(queryVector, topK);
            
            // 4. 获取文档内容
            List<RetrievedDocument> documents = fetchDocuments(searchResults);
            
            // 5. 重排序
            List<RetrievedDocument> rankedDocuments = rerankDocuments(documents, query);
            
            // 6. 构建检索结果
            RetrievalResult result = new RetrievalResult();
            result.setDocuments(rankedDocuments);
            result.setQueryVector(queryVector);
            
            // 记录响应时间
            long responseTime = System.currentTimeMillis() - startTime;
            totalResponseTime.addAndGet(responseTime);
            
            return result;
        } catch (Exception e) {
            logger.severe("Retrieval failed: " + e.getMessage());
            throw new RuntimeException("Retrieval failed", e);
        }
    }
    
    private MultimodalData buildQueryData(ProcessedQuery query) {
        MultimodalData data = new MultimodalData();
        
        QAQuery originalQuery = query.getOriginalQuery();
        switch (originalQuery.getModality()) {
            case TEXT:
                String processedText = textPreprocessor.preprocess(originalQuery.getQueryText());
                data.addData(ModalityType.TEXT, processedText);
                break;
            case IMAGE:
                // 处理图像查询
                break;
            case CODE:
                // 处理代码查询
                break;
            case MULTIMODAL:
                // 处理多模态查询
                break;
        }
        
        return data;
    }
    
    private List<RetrievedDocument> fetchDocuments(List<VectorSearchResult> searchResults) {
        List<RetrievedDocument> documents = new ArrayList<>();
        
        for (VectorSearchResult result : searchResults) {
            try {
                IndexableDocument doc = documentStore.getDocument(result.getDocumentId());
                if (doc != null) {
                    RetrievedDocument retrievedDoc = new RetrievedDocument();
                    retrievedDoc.setId(doc.getId());
                    retrievedDoc.setContent(doc.getContent());
                    retrievedDoc.setMetadata(doc.getMetadata());
                    retrievedDoc.setSimilarity(result.getSimilarity());
                    documents.add(retrievedDoc);
                }
            } catch (Exception e) {
                logger.warning("Failed to fetch document: " + result.getDocumentId());
            }
        }
        
        return documents;
    }
    
    private List<RetrievedDocument> rerankDocuments(List<RetrievedDocument> documents, 
                                                  ProcessedQuery query) {
        // 基于相关性和新鲜度重排序
        documents.sort((doc1, doc2) -> {
            double score1 = calculateRelevanceScore(doc1, query) * 0.7 + 
                           calculateFreshnessScore(doc1) * 0.3;
            double score2 = calculateRelevanceScore(doc2, query) * 0.7 + 
                           calculateFreshnessScore(doc2) * 0.3;
            return Double.compare(score2, score1); // 降序排列
        });
        
        return documents;
    }
    
    private double calculateRelevanceScore(RetrievedDocument doc, ProcessedQuery query) {
        // 计算文档与查询的相关性得分
        Set<String> queryKeywords = new HashSet<>(query.getKeywords());
        Set<String> docKeywords = extractKeywords(doc.getContent());
        
        // 计算关键词重叠
        int overlap = 0;
        for (String keyword : queryKeywords) {
            if (docKeywords.contains(keyword.toLowerCase())) {
                overlap++;
            }
        }
        
        return overlap / (double) Math.max(queryKeywords.size(), docKeywords.size());
    }
    
    private double calculateFreshnessScore(RetrievedDocument doc) {
        // 计算文档新鲜度得分
        Object timestampObj = doc.getMetadata().get("timestamp");
        if (timestampObj instanceof Long) {
            long docTimestamp = (Long) timestampObj;
            long currentTime = System.currentTimeMillis();
            long age = currentTime - docTimestamp;
            
            // 新鲜度得分：越新的文档得分越高
            return Math.exp(-age / (30.0 * 24 * 60 * 60 * 1000)); // 30天衰减
        }
        return 0.5; // 默认得分
    }
    
    private Set<String> extractKeywords(String text) {
        Set<String> keywords = new HashSet<>();
        String[] words = text.toLowerCase().split("\\W+");
        for (String word : words) {
            if (word.length() > 2) {
                keywords.add(word);
            }
        }
        return keywords;
    }
    
    public void indexDocument(IndexableDocument document) {
        try {
            // 1. 预处理文档
            IndexableDocument processedDoc = preprocessDocument(document);
            
            // 2. 向量化文档
            float[] vector = embedder.embed(processedDoc.getData());
            
            // 3. 存储文档
            documentStore.storeDocument(processedDoc);
            
            // 4. 存储向量
            vectorDB.addDocument(processedDoc.getId(), processedDoc.getData(), vector);
            
            logger.info("Document indexed: " + processedDoc.getId());
        } catch (Exception e) {
            logger.severe("Failed to index document: " + e.getMessage());
            throw new RuntimeException("Document indexing failed", e);
        }
    }
    
    private IndexableDocument preprocessDocument(IndexableDocument document) {
        IndexableDocument processedDoc = new IndexableDocument();
        processedDoc.setId(document.getId());
        processedDoc.setMetadata(new HashMap<>(document.getMetadata()));
        processedDoc.getMetadata().put("timestamp", System.currentTimeMillis());
        
        MultimodalData processedData = new MultimodalData();
        
        // 处理不同模态的数据
        for (Map.Entry<ModalityType, Object> entry : document.getData().getData().entrySet()) {
            ModalityType modality = entry.getKey();
            Object data = entry.getValue();
            
            switch (modality) {
                case TEXT:
                    if (data instanceof String) {
                        String processedText = textPreprocessor.preprocess((String) data);
                        processedData.addData(modality, processedText);
                    }
                    break;
                case IMAGE:
                    // 处理图像数据
                    processedData.addData(modality, data);
                    break;
                case CODE:
                    // 处理代码数据
                    processedData.addData(modality, data);
                    break;
            }
        }
        
        processedDoc.setData(processedData);
        processedDoc.setContent(document.getContent());
        
        return processedDoc;
    }
    
    public int getDocumentCount() {
        return vectorDB.size();
    }
    
    public double getAverageResponseTime() {
        long queries = totalQueries.get();
        return queries > 0 ? (double) totalResponseTime.get() / queries : 0.0;
    }
    
    public void shutdown() {
        try {
            vectorDB.close();
            documentStore.close();
            logger.info("Multimodal Retriever shutdown completed");
        } catch (Exception e) {
            logger.severe("Error during shutdown: " + e.getMessage());
        }
    }
}

// 可索引文档类
class IndexableDocument {
    private String id;
    private String content;
    private MultimodalData data;
    private Map<String, Object> metadata;
    
    public IndexableDocument() {
        this.metadata = new HashMap<>();
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    
    public MultimodalData getData() { return data; }
    public void setData(MultimodalData data) { this.data = data; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    public void addMetadata(String key, Object value) { this.metadata.put(key, value); }
}

// 检索结果类
class RetrievalResult {
    private List<RetrievedDocument> documents;
    private float[] queryVector;
    private long retrievalTime;
    
    public RetrievalResult() {
        this.documents = new ArrayList<>();
    }
    
    // Getters and Setters
    public List<RetrievedDocument> getDocuments() { return documents; }
    public void setDocuments(List<RetrievedDocument> documents) { this.documents = documents; }
    public void addDocument(RetrievedDocument document) { this.documents.add(document); }
    
    public float[] getQueryVector() { return queryVector; }
    public void setQueryVector(float[] queryVector) { this.queryVector = queryVector; }
    
    public long getRetrievalTime() { return retrievalTime; }
    public void setRetrievalTime(long retrievalTime) { this.retrievalTime = retrievalTime; }
}

// 检索到的文档类
class RetrievedDocument {
    private String id;
    private String content;
    private Map<String, Object> metadata;
    private double similarity;
    
    public RetrievedDocument() {
        this.metadata = new HashMap<>();
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    
    public double getSimilarity() { return similarity; }
    public void setSimilarity(double similarity) { this.similarity = similarity; }
}
```

### 4. 知识图谱增强模块

```java
public class KnowledgeGraphEnhancer {
    private KnowledgeGraph knowledgeGraph;
    private EntityLinker entityLinker;
    private RelationExtractor relationExtractor;
    private Configuration config;
    private Logger logger;
    
    public KnowledgeGraphEnhancer(Configuration config) {
        this.config = config;
        this.logger = Logger.getLogger("KnowledgeGraphEnhancer");
        initializeComponents();
    }
    
    private void initializeComponents() {
        try {
            this.knowledgeGraph = new KnowledgeGraph(config);
            this.entityLinker = new EntityLinker(knowledgeGraph);
            this.relationExtractor = new RelationExtractor();
            
            logger.info("Knowledge Graph Enhancer initialized successfully");
        } catch (Exception e) {
            logger.severe("Failed to initialize Knowledge Graph Enhancer: " + e.getMessage());
            throw new RuntimeException("Initialization failed", e);
        }
    }
    
    public EnhancedRetrievalResult enhance(RetrievalResult retrievalResult) {
        EnhancedRetrievalResult enhancedResult = new EnhancedRetrievalResult();
        enhancedResult.setBaseResult(retrievalResult);
        
        try {
            // 1. 实体链接
            List<LinkedEntity> linkedEntities = linkEntities(retrievalResult);
            enhancedResult.setLinkedEntities(linkedEntities);
            
            // 2. 关系抽取
            List<ExtractedRelation> relations = extractRelations(retrievalResult, linkedEntities);
            enhancedResult.setRelations(relations);
            
            // 3. 知识图谱查询
            List<GraphQueryResult> graphResults = queryKnowledgeGraph(linkedEntities);
            enhancedResult.setGraphResults(graphResults);
            
            // 4. 信息融合
           融合信息(enhancedResult);
            
            logger.info("Knowledge graph enhancement completed");
        } catch (Exception e) {
            logger.warning("Knowledge graph enhancement failed: " + e.getMessage());
            // 即使增强失败，也返回基础检索结果
            enhancedResult.setBaseResult(retrievalResult);
        }
        
        return enhancedResult;
    }
    
    private List<LinkedEntity> linkEntities(RetrievalResult retrievalResult) {
        List<LinkedEntity> linkedEntities = new ArrayList<>();
        
        // 从检索到的文档中提取实体并链接到知识图谱
        for (RetrievedDocument doc : retrievalResult.getDocuments()) {
            List<RecognizedEntity> entities = extractEntities(doc.getContent());
            for (RecognizedEntity entity : entities) {
                LinkedEntity linkedEntity = entityLinker.linkEntity(entity);
                if (linkedEntity != null) {
                    linkedEntities.add(linkedEntity);
                }
            }
        }
        
        return linkedEntities;
    }
    
    private List<ExtractedRelation> extractRelations(RetrievalResult retrievalResult, 
                                                   List<LinkedEntity> linkedEntities) {
        List<ExtractedRelation> relations = new ArrayList<>();
        
        // 从文档内容中抽取实体间的关系
        for (RetrievedDocument doc : retrievalResult.getDocuments()) {
            List<ExtractedRelation> docRelations = relationExtractor.extract(
                doc.getContent(), linkedEntities);
            relations.addAll(docRelations);
        }
        
        return relations;
    }
    
    private List<GraphQueryResult> queryKnowledgeGraph(List<LinkedEntity> linkedEntities) {
        List<GraphQueryResult> results = new ArrayList<>();
        
        // 基于链接的实体查询知识图谱
        for (LinkedEntity entity : linkedEntities) {
            try {
                GraphQueryResult result = knowledgeGraph.queryEntity(entity.getLinkedId());
                if (result != null) {
                    results.add(result);
                }
            } catch (Exception e) {
                logger.warning("Failed to query knowledge graph for entity: " + 
                              entity.getLinkedId());
            }
        }
        
        return results;
    }
    
    private void 融合信息(EnhancedRetrievalResult enhancedResult) {
        // 将知识图谱信息与检索结果融合
        // 这里简化处理，实际应用中应实现复杂的融合算法
        enhancedResult.setEnhanced(true);
    }
    
    private List<RecognizedEntity> extractEntities(String content) {
        // 简化的实体提取
        EntityRecognizer recognizer = new EntityRecognizer();
        return recognizer.recognize(content);
    }
    
    public void updateKnowledgeGraph(IndexableDocument document) {
        try {
            // 从文档中提取信息并更新知识图谱
            List<RecognizedEntity> entities = extractEntities(document.getContent());
            List<ExtractedRelation> relations = relationExtractor.extract(
                document.getContent(), entities);
            
            // 更新知识图谱
            for (RecognizedEntity entity : entities) {
                knowledgeGraph.addEntity(entity);
            }
            
            for (ExtractedRelation relation : relations) {
                knowledgeGraph.addRelation(relation);
            }
            
            logger.info("Knowledge graph updated with document: " + document.getId());
        } catch (Exception e) {
            logger.warning("Failed to update knowledge graph: " + e.getMessage());
        }
    }
    
    public int getGraphSize() {
        return knowledgeGraph.getNodeCount();
    }
    
    public void shutdown() {
        try {
            knowledgeGraph.close();
            logger.info("Knowledge Graph Enhancer shutdown completed");
        } catch (Exception e) {
            logger.severe("Error during shutdown: " + e.getMessage());
        }
    }
}

// 增强的检索结果类
class EnhancedRetrievalResult {
    private RetrievalResult baseResult;
    private List<LinkedEntity> linkedEntities;
    private List<ExtractedRelation> relations;
    private List<GraphQueryResult> graphResults;
    private boolean enhanced;
    
    public EnhancedRetrievalResult() {
        this.linkedEntities = new ArrayList<>();
        this.relations = new ArrayList<>();
        this.graphResults = new ArrayList<>();
    }
    
    // Getters and Setters
    public RetrievalResult getBaseResult() { return baseResult; }
    public void setBaseResult(RetrievalResult baseResult) { this.baseResult = baseResult; }
    
    public List<LinkedEntity> getLinkedEntities() { return linkedEntities; }
    public void setLinkedEntities(List<LinkedEntity> linkedEntities) { this.linkedEntities = linkedEntities; }
    
    public List<ExtractedRelation> getRelations() { return relations; }
    public void setRelations(List<ExtractedRelation> relations) { this.relations = relations; }
    
    public List<GraphQueryResult> getGraphResults() { return graphResults; }
    public void setGraphResults(List<GraphQueryResult> graphResults) { this.graphResults = graphResults; }
    
    public boolean isEnhanced() { return enhanced; }
    public void setEnhanced(boolean enhanced) { this.enhanced = enhanced; }
}

// 链接实体类
class LinkedEntity {
    private RecognizedEntity originalEntity;
    private String linkedId;
    private double confidence;
    private Map<String, Object> properties;
    
    public LinkedEntity(RecognizedEntity originalEntity) {
        this.originalEntity = originalEntity;
        this.properties = new HashMap<>();
    }
    
    // Getters and Setters
    public RecognizedEntity getOriginalEntity() { return originalEntity; }
    public void setOriginalEntity(RecognizedEntity originalEntity) { this.originalEntity = originalEntity; }
    
    public String getLinkedId() { return linkedId; }
    public void setLinkedId(String linkedId) { this.linkedId = linkedId; }
    
    public double getConfidence() { return confidence; }
    public void setConfidence(double confidence) { this.confidence = confidence; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { this.properties = properties; }
    public void addProperty(String key, Object value) { this.properties.put(key, value); }
}

// 图查询结果类
class GraphQueryResult {
    private String entityId;
    private Map<String, Object> properties;
    private List<GraphRelation> relations;
    
    public GraphQueryResult(String entityId) {
        this.entityId = entityId;
        this.properties = new HashMap<>();
        this.relations = new ArrayList<>();
    }
    
    // Getters and Setters
    public String getEntityId() { return entityId; }
    public void setEntityId(String entityId) { this.entityId = entityId; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { this.properties = properties; }
    
    public List<GraphRelation> getRelations() { return relations; }
    public void setRelations(List<GraphRelation> relations) { this.relations = relations; }
    public void addRelation(GraphRelation relation) { this.relations.add(relation); }
}

// 图关系类
class GraphRelation {
    private String subject;
    private String predicate;
    private String object;
    private double confidence;
    
    public GraphRelation(String subject, String predicate, String object) {
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.confidence = 1.0;
    }
    
    // Getters and Setters
    public String getSubject() { return subject; }
    public void setSubject(String subject) { this.subject = subject; }
    
    public String getPredicate() { return predicate; }
    public void setPredicate(String predicate) { this.predicate = predicate; }
    
    public String getObject() { return object; }
    public void setObject(String object) { this.object = object; }
    
    public double getConfidence() { return confidence; }
    public void setConfidence(double confidence) { this.confidence = confidence; }
}
```

### 5. 智能推理模块

``java
public class IntelligentReasoner {
    private ReasoningEngine reasoningEngine;
    private ContextManager contextManager;
    private Configuration config;
    private Logger logger;
    
    public IntelligentReasoner(Configuration config) {
        this.config = config;
        this.logger = Logger.getLogger("IntelligentReasoner");
        initializeComponents();
    }
    
    private void initializeComponents() {
        try {
            this.reasoningEngine = new ReasoningEngine(config);
            this.contextManager = new ContextManager();
            
            logger.info("Intelligent Reasoner initialized successfully");
        } catch (Exception e) {
            logger.severe("Failed to initialize Intelligent Reasoner: " + e.getMessage());
            throw new RuntimeException("Initialization failed", e);
        }
    }
    
    public ReasoningResult reason(ProcessedQuery query, EnhancedRetrievalResult retrievalResult) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. 构建推理上下文
            ReasoningContext context = buildReasoningContext(query, retrievalResult);
            
            // 2. 执行推理
            ReasoningResult result = reasoningEngine.reason(context);
            
            // 3. 验证推理结果
            ValidationResult validation = validateResult(result);
            if (!validation.isValid()) {
                // 如果验证失败，尝试改进结果
                result = improveResult(result, validation);
            }
            
            // 4. 记录推理时间
            long reasoningTime = System.currentTimeMillis() - startTime;
            result.setReasoningTime(reasoningTime);
            
            logger.info("Reasoning completed in " + reasoningTime + "ms");
            return result;
        } catch (Exception e) {
            logger.severe("Reasoning failed: " + e.getMessage());
            return createErrorResult(e.getMessage());
        }
    }
    
    private ReasoningContext buildReasoningContext(ProcessedQuery query, 
                                                 EnhancedRetrievalResult retrievalResult) {
        ReasoningContext context = new ReasoningContext();
        context.setQuery(query);
        context.setRetrievalResult(retrievalResult);
        
        // 添加上下文信息
        context.setContext(contextManager.getAllContext());
        
        // 设置推理参数
        int maxSteps = config.getProperty("reasoning.maxSteps", 20);
        context.setMaxSteps(maxSteps);
        
        return context;
    }
    
    private ValidationResult validateResult(ReasoningResult result) {
        ReasoningResultValidator validator = new ReasoningResultValidator();
        return validator.validateResult(result);
    }
    
    private ReasoningResult improveResult(ReasoningResult result, ValidationResult validation) {
        ReasoningResultValidator validator = new ReasoningResultValidator();
        validator.improveResult(result, validation);
        return result;
    }
    
    private ReasoningResult createErrorResult(String errorMessage) {
        ReasoningResult errorResult = new ReasoningResult();
        errorResult.setComplete(false);
        errorResult.setAnswer("推理过程中发生错误: " + errorMessage);
        errorResult.setError(true);
        return errorResult;
    }
    
    public void updateContext(String key, Object value) {
        contextManager.setContext(key, value);
    }
    
    public void clearContext() {
        contextManager.clearContext();
    }
    
    public void shutdown() {
        logger.info("Intelligent Reasoner shutdown completed");
    }
}

// 推理引擎
class ReasoningEngine {
    private KnowledgeBase knowledgeBase;
    private InferenceEngine inferenceEngine;
    private Configuration config;
    
    public ReasoningEngine(Configuration config) {
        this.config = config;
        initializeKnowledgeBase();
        this.inferenceEngine = new InferenceEngine();
    }
    
    private void initializeKnowledgeBase() {
        // 初始化知识库
        this.knowledgeBase = new InMemoryKnowledgeBase();
    }
    
    public ReasoningResult reason(ReasoningContext context) {
        ReasoningResult result = new ReasoningResult();
        
        try {
            // 1. 问题分析
            ProblemAnalysis analysis = analyzeProblem(context.getQuery());
            
            // 2. 问题分解
            List<SubProblem> subProblems = decomposeProblem(analysis);
            
            // 3. 构建推理链
            ReasoningChain chain = buildReasoningChain(subProblems, context);
            
            // 4. 执行推理
            executeReasoningChain(chain, context);
            
            // 5. 生成最终答案
            generateFinalAnswer(result, chain, context);
            
            result.setComplete(true);
        } catch (Exception e) {
            result.setComplete(false);
            result.setAnswer("推理执行失败: " + e.getMessage());
        }
        
        return result;
    }
    
    private ProblemAnalysis analyzeProblem(ProcessedQuery query) {
        ProblemAnalyzer analyzer = new ProblemAnalyzer(knowledgeBase);
        return analyzer.analyzeProblem(query.getProcessedText());
    }
    
    private List<SubProblem> decomposeProblem(ProblemAnalysis analysis) {
        ProblemAnalyzer analyzer = new ProblemAnalyzer(knowledgeBase);
        return analyzer.decomposeProblem(analysis);
    }
    
    private ReasoningChain buildReasoningChain(List<SubProblem> subProblems, 
                                             ReasoningContext context) {
        ReasoningChain chain = new ReasoningChain();
        
        for (SubProblem subProblem : subProblems) {
            ReasoningStep step = new ReasoningStep();
            step.setDescription(subProblem.getDescription());
            step.setSubProblem(subProblem);
            chain.addStep(step);
        }
        
        return chain;
    }
    
    private void executeReasoningChain(ReasoningChain chain, ReasoningContext context) {
        for (ReasoningStep step : chain.getSteps()) {
            try {
                // 应用推理规则
                List<Fact> conclusions = inferenceEngine.applyRules(
                    step.getSubProblem(), context);
                step.setConclusions(conclusions);
                
                // 更新置信度
                step.setConfidence(calculateStepConfidence(conclusions));
            } catch (Exception e) {
                step.setError(true);
                step.setErrorMessage(e.getMessage());
            }
        }
    }
    
    private void generateFinalAnswer(ReasoningResult result, ReasoningChain chain, 
                                   ReasoningContext context) {
        StringBuilder answer = new StringBuilder();
        answer.append("基于以下推理得出答案:\n\n");
        
        for (ReasoningStep step : chain.getSteps()) {
            answer.append("- ").append(step.getDescription());
            if (step.getConclusions() != null && !step.getConclusions().isEmpty()) {
                answer.append(": ").append(step.getConclusions().get(0).getStatement());
            }
            answer.append("\n");
        }
        
        answer.append("\n最终答案: 问题已通过推理解决。");
        result.setAnswer(answer.toString());
        
        // 计算整体置信度
        double overallConfidence = calculateOverallConfidence(chain);
        result.setConfidence(getConfidenceLevel(overallConfidence));
    }
    
    private double calculateStepConfidence(List<Fact> conclusions) {
        if (conclusions.isEmpty()) {
            return 0.0;
        }
        
        double totalConfidence = 0.0;
        for (Fact fact : conclusions) {
            totalConfidence += fact.getConfidence();
        }
        
        return totalConfidence / conclusions.size();
    }
    
    private double calculateOverallConfidence(ReasoningChain chain) {
        double totalConfidence = 0.0;
        int validSteps = 0;
        
        for (ReasoningStep step : chain.getSteps()) {
            if (!step.isError()) {
                totalConfidence += step.getConfidence();
                validSteps++;
            }
        }
        
        return validSteps > 0 ? totalConfidence / validSteps : 0.0;
    }
    
    private String getConfidenceLevel(double confidence) {
        if (confidence >= 0.8) {
            return "high";
        } else if (confidence >= 0.6) {
            return "medium";
        } else {
            return "low";
        }
    }
}

// 推理上下文类
class ReasoningContext {
    private ProcessedQuery query;
    private EnhancedRetrievalResult retrievalResult;
    private Map<String, Object> context;
    private int maxSteps;
    
    public ReasoningContext() {
        this.context = new HashMap<>();
    }
    
    // Getters and Setters
    public ProcessedQuery getQuery() { return query; }
    public void setQuery(ProcessedQuery query) { this.query = query; }
    
    public EnhancedRetrievalResult getRetrievalResult() { return retrievalResult; }
    public void setRetrievalResult(EnhancedRetrievalResult retrievalResult) { this.retrievalResult = retrievalResult; }
    
    public Map<String, Object> getContext() { return context; }
    public void setContext(Map<String, Object> context) { this.context = context; }
    
    public int getMaxSteps() { return maxSteps; }
    public void setMaxSteps(int maxSteps) { this.maxSteps = maxSteps; }
}

// 推理结果类
class ReasoningResult {
    private String answer;
    private boolean complete;
    private String confidence;
    private boolean error;
    private String errorMessage;
    private long reasoningTime;
    
    public ReasoningResult() {
        this.confidence = "medium";
    }
    
    // Getters and Setters
    public String getAnswer() { return answer; }
    public void setAnswer(String answer) { this.answer = answer; }
    
    public boolean isComplete() { return complete; }
    public void setComplete(boolean complete) { this.complete = complete; }
    
    public String getConfidence() { return confidence; }
    public void setConfidence(String confidence) { this.confidence = confidence; }
    
    public boolean isError() { return error; }
    public void setError(boolean error) { this.error = error; }
    
    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    
    public long getReasoningTime() { return reasoningTime; }
    public void setReasoningTime(long reasoningTime) { this.reasoningTime = reasoningTime; }
}

// 推理链类
class ReasoningChain {
    private List<ReasoningStep> steps;
    
    public ReasoningChain() {
        this.steps = new ArrayList<>();
    }
    
    public void addStep(ReasoningStep step) {
        step.setStepNumber(steps.size() + 1);
        steps.add(step);
    }
    
    public List<ReasoningStep> getSteps() {
        return steps;
    }
}

// 推理步骤类
class ReasoningStep {
    private int stepNumber;
    private String description;
    private SubProblem subProblem;
    private List<Fact> conclusions;
    private double confidence;
    private boolean error;
    private String errorMessage;
    
    // Getters and Setters
    public int getStepNumber() { return stepNumber; }
    public void setStepNumber(int stepNumber) { this.stepNumber = stepNumber; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public SubProblem getSubProblem() { return subProblem; }
    public void setSubProblem(SubProblem subProblem) { this.subProblem = subProblem; }
    
    public List<Fact> getConclusions() { return conclusions; }
    public void setConclusions(List<Fact> conclusions) { this.conclusions = conclusions; }
    
    public double getConfidence() { return confidence; }
    public void setConfidence(double confidence) { this.confidence = confidence; }
    
    public boolean isError() { return error; }
    public void setError(boolean error) { this.error = error; }
    
    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
}
```

### 6. 答案生成模块

``java
public class AnswerGenerator {
    private LanguageModel languageModel;
    private TemplateManager templateManager;
    private Configuration config;
    private Logger logger;
    
    public AnswerGenerator(Configuration config) {
        this.config = config;
        this.logger = Logger.getLogger("AnswerGenerator");
        initializeComponents();
    }
    
    private void initializeComponents() {
        try {
            this.languageModel = new LanguageModel(config);
            this.templateManager = new TemplateManager();
            
            logger.info("Answer Generator initialized successfully");
        } catch (Exception e) {
            logger.severe("Failed to initialize Answer Generator: " + e.getMessage());
            throw new RuntimeException("Initialization failed", e);
        }
    }
    
    public QAAnswer generate(ProcessedQuery query, EnhancedRetrievalResult retrievalResult, 
                           ReasoningResult reasoningResult) {
        QAAnswer answer = new QAAnswer();
        answer.setQueryId(query.getOriginalQuery().getQueryText());
        answer.setTimestamp(System.currentTimeMillis());
        
        try {
            // 1. 选择生成策略
            GenerationStrategy strategy = selectGenerationStrategy(query);
            
            // 2. 生成答案
            String answerText = generateAnswerText(query, retrievalResult, reasoningResult, strategy);
            answer.setAnswerText(answerText);
            
            // 3. 设置置信度
            String confidence = calculateConfidence(query, retrievalResult, reasoningResult);
            answer.setConfidence(confidence);
            
            // 4. 设置来源
            String source = determineSource(retrievalResult, reasoningResult);
            answer.setSource(source);
            
            // 5. 添加引用信息
            List<String> citations = extractCitations(retrievalResult);
            answer.setCitations(citations);
            
            // 6. 格式化答案
            formatAnswer(answer, strategy);
            
            logger.info("Answer generated successfully");
        } catch (Exception e) {
            logger.severe("Answer generation failed: " + e.getMessage());
            answer.setError(true);
            answer.setAnswerText("抱歉，生成答案时遇到错误: " + e.getMessage());
            answer.setConfidence("low");
            answer.setSource("system");
        }
        
        return answer;
    }
    
    private GenerationStrategy selectGenerationStrategy(ProcessedQuery query) {
        // 根据查询类型选择生成策略
        switch (query.getQueryType()) {
            case FACTUAL:
                return GenerationStrategy.RETRIEVAL_BASED;
            case CAUSAL:
            case PROCEDURAL:
                return GenerationStrategy.REASONING_BASED;
            case COMPARATIVE:
                return GenerationStrategy.COMPARISON_BASED;
            default:
                return GenerationStrategy.HYBRID;
        }
    }
    
    private String generateAnswerText(ProcessedQuery query, 
                                    EnhancedRetrievalResult retrievalResult,
                                    ReasoningResult reasoningResult,
                                    GenerationStrategy strategy) throws Exception {
        switch (strategy) {
            case RETRIEVAL_BASED:
                return generateRetrievalBasedAnswer(query, retrievalResult);
            case REASONING_BASED:
                return generateReasoningBasedAnswer(query, reasoningResult);
            case COMPARISON_BASED:
                return generateComparisonBasedAnswer(query, retrievalResult);
            case HYBRID:
                return generateHybridAnswer(query, retrievalResult, reasoningResult);
            default:
                return generateDefaultAnswer(query, retrievalResult);
        }
    }
    
    private String generateRetrievalBasedAnswer(ProcessedQuery query, 
                                              EnhancedRetrievalResult retrievalResult) throws Exception {
        // 基于检索结果生成答案
        List<RetrievedDocument> documents = retrievalResult.getBaseResult().getDocuments();
        
        if (documents.isEmpty()) {
            return "抱歉，我没有找到相关的信息来回答您的问题。";
        }
        
        // 构建提示
        StringBuilder prompt = new StringBuilder();
        prompt.append("基于以下文档内容回答问题: ").append(query.getProcessedText()).append("\n\n");
        
        for (int i = 0; i < Math.min(3, documents.size()); i++) {
            RetrievedDocument doc = documents.get(i);
            prompt.append("文档 ").append(i + 1).append(" (相关度: ")
                  .append(String.format("%.2f", doc.getSimilarity())).append("):\n")
                  .append(doc.getContent()).append("\n\n");
        }
        
        prompt.append("请基于以上信息提供准确、简洁的回答:");
        
        // 调用语言模型生成答案
        return languageModel.generate(prompt.toString());
    }
    
    private String generateReasoningBasedAnswer(ProcessedQuery query, 
                                              ReasoningResult reasoningResult) {
        // 基于推理结果生成答案
        if (reasoningResult == null) {
            return "抱歉，我无法对这个问题进行推理分析。";
        }
        
        if (reasoningResult.isError()) {
            return "推理过程中遇到错误: " + reasoningResult.getErrorMessage();
        }
        
        return reasoningResult.getAnswer();
    }
    
    private String generateComparisonBasedAnswer(ProcessedQuery query, 
                                               EnhancedRetrievalResult retrievalResult) throws Exception {
        // 生成比较类答案
        StringBuilder prompt = new StringBuilder();
        prompt.append("比较以下内容来回答问题: ").append(query.getProcessedText()).append("\n\n");
        
        List<RetrievedDocument> documents = retrievalResult.getBaseResult().getDocuments();
        for (int i = 0; i < Math.min(5, documents.size()); i++) {
            RetrievedDocument doc = documents.get(i);
            prompt.append("选项 ").append(i + 1).append(":\n")
                  .append(doc.getContent()).append("\n\n");
        }
        
        prompt.append("请比较以上选项并给出详细的分析:");
        
        return languageModel.generate(prompt.toString());
    }
    
    private String generateHybridAnswer(ProcessedQuery query, 
                                      EnhancedRetrievalResult retrievalResult,
                                      ReasoningResult reasoningResult) throws Exception {
        // 生成混合答案
        StringBuilder prompt = new StringBuilder();
        prompt.append("基于以下信息回答问题: ").append(query.getProcessedText()).append("\n\n");
        
        // 添加检索信息
        List<RetrievedDocument> documents = retrievalResult.getBaseResult().getDocuments();
        if (!documents.isEmpty()) {
            prompt.append("相关信息:\n");
            for (int i = 0; i < Math.min(2, documents.size()); i++) {
                RetrievedDocument doc = documents.get(i);
                prompt.append("- ").append(doc.getContent()).append("\n");
            }
            prompt.append("\n");
        }
        
        // 添加推理信息
        if (reasoningResult != null && !reasoningResult.isError()) {
            prompt.append("分析过程:\n").append(reasoningResult.getAnswer()).append("\n\n");
        }
        
        prompt.append("请综合以上信息提供完整的回答:");
        
        return languageModel.generate(prompt.toString());
    }
    
    private String generateDefaultAnswer(ProcessedQuery query, 
                                       EnhancedRetrievalResult retrievalResult) throws Exception {
        // 默认答案生成
        return generateRetrievalBasedAnswer(query, retrievalResult);
    }
    
    private String calculateConfidence(ProcessedQuery query, 
                                     EnhancedRetrievalResult retrievalResult,
                                     ReasoningResult reasoningResult) {
        // 计算答案置信度
        double confidence = 0.5; // 默认置信度
        
        // 基于检索结果的置信度
        if (retrievalResult != null) {
            List<RetrievedDocument> documents = retrievalResult.getBaseResult().getDocuments();
            if (!documents.isEmpty()) {
                // 基于最高相关度文档计算置信度
                double maxSimilarity = documents.get(0).getSimilarity();
                confidence = Math.min(0.5 + maxSimilarity * 0.5, 1.0);
            }
        }
        
        // 基于推理结果的置信度
        if (reasoningResult != null && !reasoningResult.isError()) {
            switch (reasoningResult.getConfidence()) {
                case "high":
                    confidence = Math.min(confidence + 0.3, 1.0);
                    break;
                case "medium":
                    confidence = Math.min(confidence + 0.1, 1.0);
                    break;
                case "low":
                    confidence = Math.max(confidence - 0.2, 0.1);
                    break;
            }
        }
        
        // 基于查询复杂度调整置信度
        if (query.getComplexity() > 80) {
            confidence = Math.max(confidence - 0.2, 0.1);
        }
        
        if (confidence >= 0.8) {
            return "high";
        } else if (confidence >= 0.6) {
            return "medium";
        } else {
            return "low";
        }
    }
    
    private String determineSource(EnhancedRetrievalResult retrievalResult, 
                                 ReasoningResult reasoningResult) {
        // 确定答案来源
        if (reasoningResult != null && !reasoningResult.isError()) {
            return "reasoning";
        } else if (retrievalResult != null) {
            return "retrieval";
        } else {
            return "system";
        }
    }
    
    private List<String> extractCitations(EnhancedRetrievalResult retrievalResult) {
        List<String> citations = new ArrayList<>();
        
        if (retrievalResult != null) {
            List<RetrievedDocument> documents = retrievalResult.getBaseResult().getDocuments();
            for (RetrievedDocument doc : documents) {
                Object source = doc.getMetadata().get("source");
                if (source != null) {
                    citations.add(source.toString());
                }
            }
        }
        
        return citations;
    }
    
    private void formatAnswer(QAAnswer answer, GenerationStrategy strategy) {
        // 格式化答案
        String formattedAnswer = answer.getAnswerText();
        
        // 添加格式化标记
        switch (strategy) {
            case REASONING_BASED:
                formattedAnswer = "[推理结果]\n" + formattedAnswer;
                break;
            case COMPARISON_BASED:
                formattedAnswer = "[比较分析]\n" + formattedAnswer;
                break;
            case HYBRID:
                formattedAnswer = "[综合分析]\n" + formattedAnswer;
                break;
        }
        
        answer.setFormattedAnswer(formattedAnswer);
    }
    
    public void shutdown() {
        try {
            languageModel.close();
            logger.info("Answer Generator shutdown completed");
        } catch (Exception e) {
            logger.severe("Error during shutdown: " + e.getMessage());
        }
    }
}

// 答案生成策略枚举
enum GenerationStrategy {
    RETRIEVAL_BASED,    // 基于检索
    REASONING_BASED,    // 基于推理
    COMPARISON_BASED,   // 基于比较
    HYBRID              // 混合策略
}

// QA答案类
class QAAnswer {
    private String queryId;
    private String answerText;
    private String formattedAnswer;
    private String confidence;
    private String source;
    private List<String> citations;
    private boolean error;
    private long timestamp;
    private long expirationTime;
    
    public QAAnswer() {
        this.citations = new ArrayList<>();
        this.confidence = "medium";
        this.timestamp = System.currentTimeMillis();
        // 默认1小时过期
        this.expirationTime = this.timestamp + 3600000;
    }
    
    // Getters and Setters
    public String getQueryId() { return queryId; }
    public void setQueryId(String queryId) { this.queryId = queryId; }
    
    public String getAnswerText() { return answerText; }
    public void setAnswerText(String answerText) { this.answerText = answerText; }
    
    public String getFormattedAnswer() { return formattedAnswer; }
    public void setFormattedAnswer(String formattedAnswer) { this.formattedAnswer = formattedAnswer; }
    
    public String getConfidence() { return confidence; }
    public void setConfidence(String confidence) { this.confidence = confidence; }
    
    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }
    
    public List<String> getCitations() { return citations; }
    public void setCitations(List<String> citations) { this.citations = citations; }
    public void addCitation(String citation) { this.citations.add(citation); }
    
    public boolean isError() { return error; }
    public void setError(boolean error) { this.error = error; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
    
    public long getExpirationTime() { return expirationTime; }
    public void setExpirationTime(long expirationTime) { this.expirationTime = expirationTime; }
    
    public boolean isExpired() {
        return System.currentTimeMillis() > expirationTime;
    }
}

// 语言模型类（简化版）
class LanguageModel {
    private Configuration config;
    
    public LanguageModel(Configuration config) {
        this.config = config;
    }
    
    public String generate(String prompt) throws Exception {
        // 简化的语言模型调用
        // 实际应用中应调用真实的语言模型API
        return "基于您的查询 \"" + prompt.substring(0, Math.min(50, prompt.length())) + 
               "...\"，我生成了以下回答...";
    }
    
    public void close() throws Exception {
        // 清理资源
    }
}

// 模板管理器
class TemplateManager {
    private Map<String, String> templates;
    
    public TemplateManager() {
        this.templates = new HashMap<>();
        initializeTemplates();
    }
    
    private void initializeTemplates() {
        templates.put("factual", "根据以下信息回答问题:\n{context}\n\n问题: {question}\n回答:");
        templates.put("causal", "分析以下信息并回答因果关系问题:\n{context}\n\n问题: {question}\n分析:");
        templates.put("procedural", "基于以下步骤信息回答过程问题:\n{context}\n\n问题: {question}\n步骤:");
    }
    
    public String getTemplate(String templateName) {
        return templates.getOrDefault(templateName, templates.get("factual"));
    }
}
```

### 7. 缓存管理模块

``java
public class CacheManager {
    private Map<String, CachedAnswer> cache;
    private int maxSize;
    private long defaultTTL;
    private AtomicLong totalQueries;
    private AtomicLong cacheHits;
    private ReadWriteLock lock;
    private ScheduledExecutorService cleanupExecutor;
    private Logger logger;
    
    public CacheManager(Configuration config) {
        this.cache = new LinkedHashMap<String, CachedAnswer>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, CachedAnswer> eldest) {
                return size() > maxSize;
            }
        };
        
        this.maxSize = config.getProperty("cache.maxSize", 1000);
        this.defaultTTL = config.getProperty("cache.ttl", 3600000L); // 1小时
        this.totalQueries = new AtomicLong(0);
        this.cacheHits = new AtomicLong(0);
        this.lock = new ReentrantReadWriteLock();
        this.logger = Logger.getLogger("CacheManager");
        
        // 启动定期清理任务
        this.cleanupExecutor = Executors.newScheduledThreadPool(1);
        this.cleanupExecutor.scheduleAtFixedRate(this::cleanupExpiredEntries, 
                                               30, 30, TimeUnit.MINUTES);
        
        logger.info("Cache Manager initialized with maxSize=" + maxSize + ", ttl=" + defaultTTL);
    }
    
    public void cacheAnswer(QAQuery query, QAAnswer answer) {
        if (!isCachingEnabled()) {
            return;
        }
        
        String cacheKey = generateCacheKey(query);
        CachedAnswer cachedAnswer = new CachedAnswer(answer, System.currentTimeMillis() + defaultTTL);
        
        lock.writeLock().lock();
        try {
            cache.put(cacheKey, cachedAnswer);
            logger.fine("Answer cached for key: " + cacheKey);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public QAAnswer getAnswer(QAQuery query) {
        totalQueries.incrementAndGet();
        
        if (!isCachingEnabled()) {
            return null;
        }
        
        String cacheKey = generateCacheKey(query);
        
        lock.readLock().lock();
        try {
            CachedAnswer cachedAnswer = cache.get(cacheKey);
            if (cachedAnswer != null) {
                if (!cachedAnswer.isExpired()) {
                    cacheHits.incrementAndGet();
                    logger.fine("Cache hit for key: " + cacheKey);
                    return cachedAnswer.getAnswer();
                } else {
                    // 异步清理过期条目
                    CompletableFuture.runAsync(() -> removeExpiredEntry(cacheKey));
                }
            }
            return null;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    private String generateCacheKey(QAQuery query) {
        // 生成缓存键
        StringBuilder key = new StringBuilder();
        key.append(query.getQueryText());
        key.append("|").append(query.getModality());
        
        // 添加上下文信息
        if (query.getContext() != null && !query.getContext().isEmpty()) {
            key.append("|").append(query.getContext().hashCode());
        }
        
        return String.valueOf(key.toString().hashCode());
    }
    
    private boolean isCachingEnabled() {
        // 检查缓存是否启用
        return true; // 简化实现，实际应从配置中读取
    }
    
    private void removeExpiredEntry(String cacheKey) {
        lock.writeLock().lock();
        try {
            CachedAnswer cachedAnswer = cache.get(cacheKey);
            if (cachedAnswer != null && cachedAnswer.isExpired()) {
                cache.remove(cacheKey);
                logger.fine("Expired cache entry removed: " + cacheKey);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    private void cleanupExpiredEntries() {
        lock.writeLock().lock();
        try {
            Iterator<Map.Entry<String, CachedAnswer>> iterator = cache.entrySet().iterator();
            int removedCount = 0;
            
            while (iterator.hasNext()) {
                Map.Entry<String, CachedAnswer> entry = iterator.next();
                if (entry.getValue().isExpired()) {
                    iterator.remove();
                    removedCount++;
                }
            }
            
            if (removedCount > 0) {
                logger.info("Cleaned up " + removedCount + " expired cache entries");
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public double getHitRate() {
        long total = totalQueries.get();
        return total > 0 ? (double) cacheHits.get() / total : 0.0;
    }
    
    public long getTotalQueries() {
        return totalQueries.get();
    }
    
    public long getCacheSize() {
        lock.readLock().lock();
        try {
            return cache.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void clear() {
        lock.writeLock().lock();
        try {
            cache.clear();
            cacheHits.set(0);
            totalQueries.set(0);
            logger.info("Cache cleared");
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public CacheStats getStats() {
        CacheStats stats = new CacheStats();
        stats.setSize(getCacheSize());
        stats.setTotalQueries(getTotalQueries());
        stats.setCacheHits(cacheHits.get());
        stats.setHitRate(getHitRate());
        return stats;
    }
    
    public void shutdown() {
        cleanupExecutor.shutdown();
        try {
            if (!cleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                cleanupExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            cleanupExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        logger.info("Cache Manager shutdown completed");
    }
}

// 缓存的答案类
class CachedAnswer {
    private QAAnswer answer;
    private long expirationTime;
    
    public CachedAnswer(QAAnswer answer, long expirationTime) {
        this.answer = answer;
        this.expirationTime = expirationTime;
    }
    
    public QAAnswer getAnswer() {
        return answer;
    }
    
    public boolean isExpired() {
        return System.currentTimeMillis() > expirationTime;
    }
    
    public long getExpirationTime() {
        return expirationTime;
    }
}

// 缓存统计类
class CacheStats {
    private long size;
    private long totalQueries;
    private long cacheHits;
    private double hitRate;
    
    // Getters and Setters
    public long getSize() { return size; }
    public void setSize(long size) { this.size = size; }
    
    public long getTotalQueries() { return totalQueries; }
    public void setTotalQueries(long totalQueries) { this.totalQueries = totalQueries; }
    
    public long getCacheHits() { return cacheHits; }
    public void setCacheHits(long cacheHits) { this.cacheHits = cacheHits; }
    
    public double getHitRate() { return hitRate; }
    public void setHitRate(double hitRate) { this.hitRate = hitRate; }
}
```

### 8. 系统监控和日志模块

``java
public class SystemMonitor {
    private IntelligentQAService qaService;
    private MetricRegistry metricRegistry;
    private Logger logger;
    
    public SystemMonitor(IntelligentQAService qaService) {
        this.qaService = qaService;
        this.metricRegistry = new MetricRegistry();
        this.logger = Logger.getLogger("SystemMonitor");
        registerMetrics();
    }
    
    private void registerMetrics() {
        // 注册系统指标
        metricRegistry.register("queries.processed", (Gauge<Long>) 
            () -> qaService.getSystemStats().getTotalQueriesProcessed());
        
        metricRegistry.register("cache.hit.rate", (Gauge<Double>) 
            () -> qaService.getSystemStats().getCacheHitRate());
        
        metricRegistry.register("average.response.time", (Gauge<Double>) 
            () -> qaService.getSystemStats().getAverageResponseTime());
        
        metricRegistry.register("documents.indexed", (Gauge<Integer>) 
            () -> qaService.getSystemStats().getTotalDocumentsIndexed());
        
        metricRegistry.register("knowledge.graph.size", (Gauge<Integer>) 
            () -> qaService.getSystemStats().getKnowledgeGraphSize());
    }
    
    public SystemHealth checkHealth() {
        SystemHealth health = new SystemHealth();
        health.setTimestamp(System.currentTimeMillis());
        
        try {
            SystemStats stats = qaService.getSystemStats();
            
            // 检查各项指标
            health.setQueriesProcessed(stats.getTotalQueriesProcessed());
            health.setCacheHitRate(stats.getCacheHitRate());
            health.setAverageResponseTime(stats.getAverageResponseTime());
            health.setDocumentsIndexed(stats.getTotalDocumentsIndexed());
            health.setKnowledgeGraphSize(stats.getKnowledgeGraphSize());
            
            // 健康状态评估
            health.setStatus(evaluateHealthStatus(stats));
            health.setHealthy(health.getStatus() == HealthStatus.HEALTHY);
            
            logger.info("Health check completed: " + health.getStatus());
        } catch (Exception e) {
            health.setStatus(HealthStatus.UNHEALTHY);
            health.setHealthy(false);
            health.setErrorMessage(e.getMessage());
            logger.severe("Health check failed: " + e.getMessage());
        }
        
        return health;
    }
    
    private HealthStatus evaluateHealthStatus(SystemStats stats) {
        // 评估系统健康状态
        if (stats.getAverageResponseTime() > 5000) {
            return HealthStatus.DEGRADED;
        }
        
        if (stats.getCacheHitRate() < 0.3) {
            return HealthStatus.DEGRADED;
        }
        
        return HealthStatus.HEALTHY;
    }
    
    public PerformanceReport generatePerformanceReport() {
        PerformanceReport report = new PerformanceReport();
        report.setGeneratedAt(System.currentTimeMillis());
        
        try {
            SystemStats stats = qaService.getSystemStats();
            
            report.setTotalQueries(stats.getTotalQueriesProcessed());
            report.setCacheHitRate(stats.getCacheHitRate());
            report.setAverageResponseTime(stats.getAverageResponseTime());
            report.setDocumentsIndexed(stats.getTotalDocumentsIndexed());
            report.setKnowledgeGraphSize(stats.getKnowledgeGraphSize());
            
            // 生成详细指标
            report.setMetrics(generateDetailedMetrics());
            
            logger.info("Performance report generated");
        } catch (Exception e) {
            report.setError(true);
            report.setErrorMessage(e.getMessage());
            logger.severe("Failed to generate performance report: " + e.getMessage());
        }
        
        return report;
    }
    
    private Map<String, Object> generateDetailedMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // 获取所有注册的指标
        for (Map.Entry<String, Gauge> entry : metricRegistry.getGauges().entrySet()) {
            try {
                metrics.put(entry.getKey(), entry.getValue().getValue());
            } catch (Exception e) {
                logger.warning("Failed to get metric value for " + entry.getKey());
            }
        }
        
        return metrics;
    }
    
    public void logQuery(QueryLogEntry logEntry) {
        // 记录查询日志
        logger.info("Query Log - ID: " + logEntry.getQueryId() +
                   ", Time: " + logEntry.getProcessingTime() + "ms" +
                   ", Source: " + logEntry.getSource() +
                   ", Confidence: " + logEntry.getConfidence());
    }
}

// 系统健康状态类
class SystemHealth {
    private long timestamp;
    private HealthStatus status;
    private boolean healthy;
    private long queriesProcessed;
    private double cacheHitRate;
    private double averageResponseTime;
    private int documentsIndexed;
    private int knowledgeGraphSize;
    private String errorMessage;
    
    // Getters and Setters
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
    
    public HealthStatus getStatus() { return status; }
    public void setStatus(HealthStatus status) { this.status = status; }
    
    public boolean isHealthy() { return healthy; }
    public void setHealthy(boolean healthy) { this.healthy = healthy; }
    
    public long getQueriesProcessed() { return queriesProcessed; }
    public void setQueriesProcessed(long queriesProcessed) { this.queriesProcessed = queriesProcessed; }
    
    public double getCacheHitRate() { return cacheHitRate; }
    public void setCacheHitRate(double cacheHitRate) { this.cacheHitRate = cacheHitRate; }
    
    public double getAverageResponseTime() { return averageResponseTime; }
    public void setAverageResponseTime(double averageResponseTime) { this.averageResponseTime = averageResponseTime; }
    
    public int getDocumentsIndexed() { return documentsIndexed; }
    public void setDocumentsIndexed(int documentsIndexed) { this.documentsIndexed = documentsIndexed; }
    
    public int getKnowledgeGraphSize() { return knowledgeGraphSize; }
    public void setKnowledgeGraphSize(int knowledgeGraphSize) { this.knowledgeGraphSize = knowledgeGraphSize; }
    
    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
}

enum HealthStatus {
```

### 9. 文档存储模块

``java
public class DocumentStore {
    private Map<String, IndexableDocument> documents;
    private ReadWriteLock lock;
    private Configuration config;
    private Logger logger;
    
    public DocumentStore(Configuration config) {
        this.documents = new ConcurrentHashMap<>();
        this.lock = new ReentrantReadWriteLock();
        this.config = config;
        this.logger = Logger.getLogger("DocumentStore");
    }
    
    public void storeDocument(IndexableDocument document) {
        lock.writeLock().lock();
        try {
            documents.put(document.getId(), document);
            logger.fine("Document stored: " + document.getId());
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public IndexableDocument getDocument(String id) {
        lock.readLock().lock();
        try {
            return documents.get(id);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<IndexableDocument> searchDocuments(String query) {
        lock.readLock().lock();
        try {
            List<IndexableDocument> results = new ArrayList<>();
            String lowerQuery = query.toLowerCase();
            
            for (IndexableDocument doc : documents.values()) {
                if (doc.getContent().toLowerCase().contains(lowerQuery)) {
                    results.add(doc);
                }
            }
            
            return results;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void deleteDocument(String id) {
        lock.writeLock().lock();
        try {
            documents.remove(id);
            logger.fine("Document deleted: " + id);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int getDocumentCount() {
        lock.readLock().lock();
        try {
            return documents.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<IndexableDocument> getAllDocuments() {
        lock.readLock().lock();
        try {
            return new ArrayList<>(documents.values());
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void clear() {
        lock.writeLock().lock();
        try {
            documents.clear();
            logger.info("All documents cleared");
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void close() {
        // 清理资源
        logger.info("Document Store closed");
    }
}
```

### 10. 实体识别和链接模块

``java
public class EntityRecognizer {
    
    public List<RecognizedEntity> recognize(String text) {
        List<RecognizedEntity> entities = new ArrayList<>();
        
        // 简化的实体识别实现
        // 实际应用中应使用NER模型
        
        // 识别人名
        Pattern personPattern = Pattern.compile("\\b[A-Z][a-z]+\\s+[A-Z][a-z]+\\b");
        Matcher personMatcher = personPattern.matcher(text);
        while (personMatcher.find()) {
            entities.add(new RecognizedEntity(
                personMatcher.group(), 
                EntityType.PERSON, 
                personMatcher.start(), 
                personMatcher.end()
            ));
        }
        
        // 识别组织机构名
        Pattern orgPattern = Pattern.compile("\\b[A-Z][a-z]+\\s+(Inc|Corp|Ltd|Company)\\b");
        Matcher orgMatcher = orgPattern.matcher(text);
        while (orgMatcher.find()) {
            entities.add(new RecognizedEntity(
                orgMatcher.group(), 
                EntityType.ORGANIZATION, 
                orgMatcher.start(), 
                orgMatcher.end()
            ));
        }
        
        // 识别日期
        Pattern datePattern = Pattern.compile("\\b\\d{1,2}/\\d{1,2}/\\d{4}\\b");
        Matcher dateMatcher = datePattern.matcher(text);
        while (dateMatcher.find()) {
            entities.add(new RecognizedEntity(
                dateMatcher.group(), 
                EntityType.DATE, 
                dateMatcher.start(), 
                dateMatcher.end()
            ));
        }
        
        return entities;
    }
}

public class EntityLinker {
    private KnowledgeGraph knowledgeGraph;
    
    public EntityLinker(KnowledgeGraph knowledgeGraph) {
        this.knowledgeGraph = knowledgeGraph;
    }
    
    public LinkedEntity linkEntity(RecognizedEntity entity) {
        // 实体链接到知识图谱
        String linkedId = knowledgeGraph.findEntityId(entity.getText());
        if (linkedId != null) {
            LinkedEntity linkedEntity = new LinkedEntity(entity);
            linkedEntity.setLinkedId(linkedId);
            linkedEntity.setConfidence(0.9); // 简化置信度
            return linkedEntity;
        }
        return null;
    }
}

public class RelationExtractor {
    
    public List<ExtractedRelation> extract(String text, List<LinkedEntity> entities) {
        List<ExtractedRelation> relations = new ArrayList<>();
        
        // 简化的关系抽取实现
        // 实际应用中应使用关系抽取模型
        
        // 基于关键词的关系抽取
        if (text.contains("是") || text.contains("was") || text.contains("is")) {
            // 识别"是"关系
            for (int i = 0; i < entities.size() - 1; i++) {
                LinkedEntity subject = entities.get(i);
                LinkedEntity object = entities.get(i + 1);
                
                ExtractedRelation relation = new ExtractedRelation();
                relation.setSubject(subject.getLinkedId());
                relation.setPredicate("is");
                relation.setObject(object.getLinkedId());
                relation.setConfidence(0.8);
                relations.add(relation);
            }
        }
        
        if (text.contains("创立") || text.contains("founded")) {
            // 识别"创立"关系
            for (int i = 0; i < entities.size() - 1; i++) {
                LinkedEntity subject = entities.get(i);
                LinkedEntity object = entities.get(i + 1);
                
                ExtractedRelation relation = new ExtractedRelation();
                relation.setSubject(subject.getLinkedId());
                relation.setPredicate("founded");
                relation.setObject(object.getLinkedId());
                relation.setConfidence(0.9);
                relations.add(relation);
            }
        }
        
        return relations;
    }
}
```

### 11. 意图分类和复杂度分析模块

``java
public class IntentClassifier {
    
    public QueryIntent classify(String text) {
        String lowerText = text.toLowerCase();
        
        // 基于关键词的意图分类
        if (lowerText.contains("如何") || lowerText.contains("怎样") || lowerText.contains("how to")) {
            return QueryIntent.PROCEDURAL;
        } else if (lowerText.contains("比较") || lowerText.contains("对比") || lowerText.contains("compare")) {
            return QueryIntent.COMPARISON;
        } else if (lowerText.contains("是否") || lowerText.contains("吗") || lowerText.contains("is") || lowerText.contains("are")) {
            return QueryIntent.EVALUATIVE;
        } else if (lowerText.contains("创造") || lowerText.contains("生成") || lowerText.contains("create")) {
            return QueryIntent.CREATIVE;
        } else {
            return QueryIntent.INFORMATIONAL;
        }
    }
}

public class ComplexityAnalyzer {
    
    public int analyze(String text, List<RecognizedEntity> entities) {
        int complexity = 0;
        
        // 基于文本长度
        complexity += Math.min(text.length() / 10, 30);
        
        // 基于实体数量
        complexity += Math.min(entities.size() * 5, 20);
        
        // 基于复杂关键词
        String[] complexKeywords = {"计算", "分析", "比较", "优化", "设计", "实现", "开发", "构建"};
        for (String keyword : complexKeywords) {
            if (text.contains(keyword)) {
                complexity += 10;
            }
        }
        
        // 基于句子结构
        String[] sentences = text.split("[.!?]+");
        if (sentences.length > 3) {
            complexity += (sentences.length - 3) * 5;
        }
        
        return Math.min(complexity, 100); // 最大复杂度为100
    }
}
```

### 12. 知识图谱模块

``java
public class KnowledgeGraph {
    private Map<String, GraphNode> nodes;
    private Map<String, List<GraphEdge>> edges;
    private ReadWriteLock lock;
    private Configuration config;
    
    public KnowledgeGraph(Configuration config) {
        this.nodes = new ConcurrentHashMap<>();
        this.edges = new ConcurrentHashMap<>();
        this.lock = new ReentrantReadWriteLock();
        this.config = config;
    }
    
    public void addEntity(RecognizedEntity entity) {
        lock.writeLock().lock();
        try {
            String nodeId = generateNodeId(entity);
            if (!nodes.containsKey(nodeId)) {
                GraphNode node = new GraphNode(nodeId, entity.getText(), entity.getType());
                nodes.put(nodeId, node);
                edges.put(nodeId, new ArrayList<>());
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void addRelation(ExtractedRelation relation) {
        lock.writeLock().lock();
        try {
            // 确保节点存在
            if (!nodes.containsKey(relation.getSubject()) || 
                !nodes.containsKey(relation.getObject())) {
                return;
            }
            
            GraphEdge edge = new GraphEdge(
                relation.getSubject(), 
                relation.getObject(), 
                relation.getPredicate(), 
                relation.getConfidence()
            );
            
            edges.computeIfAbsent(relation.getSubject(), k -> new ArrayList<>()).add(edge);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public String findEntityId(String entityText) {
        lock.readLock().lock();
        try {
            for (Map.Entry<String, GraphNode> entry : nodes.entrySet()) {
                if (entry.getValue().getLabel().equalsIgnoreCase(entityText)) {
                    return entry.getKey();
                }
            }
            return null;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public GraphQueryResult queryEntity(String entityId) {
        lock.readLock().lock();
        try {
            GraphNode node = nodes.get(entityId);
            if (node == null) {
                return null;
            }
            
            GraphQueryResult result = new GraphQueryResult(entityId);
            result.getProperties().put("label", node.getLabel());
            result.getProperties().put("type", node.getType().toString());
            
            // 添加关联关系
            List<GraphEdge> nodeEdges = edges.get(entityId);
            if (nodeEdges != null) {
                result.setRelations(new ArrayList<>(nodeEdges));
            }
            
            return result;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<GraphNode> searchNodes(String query) {
        lock.readLock().lock();
        try {
            List<GraphNode> results = new ArrayList<>();
            String lowerQuery = query.toLowerCase();
            
            for (GraphNode node : nodes.values()) {
                if (node.getLabel().toLowerCase().contains(lowerQuery)) {
                    results.add(node);
                }
            }
            
            return results;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public int getNodeCount() {
        lock.readLock().lock();
        try {
            return nodes.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public int getEdgeCount() {
        lock.readLock().lock();
        try {
            return edges.values().stream().mapToInt(List::size).sum();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    private String generateNodeId(RecognizedEntity entity) {
        return entity.getType().toString() + "_" + entity.getText().hashCode();
    }
    
    public void close() {
        // 清理资源
    }
}

class GraphNode {
    private String id;
    private String label;
    private EntityType type;
    private Map<String, Object> properties;
    
    public GraphNode(String id, String label, EntityType type) {
        this.id = id;
        this.label = label;
        this.type = type;
        this.properties = new HashMap<>();
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public String getLabel() { return label; }
    public EntityType getType() { return type; }
    public Map<String, Object> getProperties() { return properties; }
    public void setProperty(String key, Object value) { properties.put(key, value); }
}

class GraphEdge {
    private String from;
    private String to;
    private String label;
    private double confidence;
    
    public GraphEdge(String from, String to, String label, double confidence) {
        this.from = from;
        this.to = to;
        this.label = label;
        this.confidence = confidence;
    }
    
    // Getters and Setters
    public String getFrom() { return from; }
    public String getTo() { return to; }
    public String getLabel() { return label; }
    public double getConfidence() { return confidence; }
}
```

## 系统测试

### 1. 单元测试

``java
public class IntelligentQATest {
    private IntelligentQAService qaService;
    
    @Before
    public void setUp() {
        Configuration config = new Configuration();
        qaService = new IntelligentQAService(config);
    }
    
    @Test
    public void testSimpleQuestion() {
        QAQuery query = new QAQuery("苹果公司的创始人是谁？");
        QAAnswer answer = qaService.answerQuestion(query);
        
        assertNotNull(answer);
        assertFalse(answer.isError());
        assertNotNull(answer.getAnswerText());
        assertTrue(answer.getAnswerText().length() > 0);
    }
    
    @Test
    public void testComplexQuestion() {
        QAQuery query = new QAQuery("为什么苹果公司的iPhone如此成功？");
        QAAnswer answer = qaService.answerQuestion(query);
        
        assertNotNull(answer);
        assertFalse(answer.isError());
        assertNotNull(answer.getAnswerText());
        assertTrue(answer.getAnswerText().length() > 0);
    }
    
    @Test
    public void testDocumentIndexing() {
        IndexableDocument document = new IndexableDocument();
        document.setId("test_doc_1");
        document.setContent("苹果公司是一家知名的科技公司，总部位于加利福尼亚州库比蒂诺。");
        
        MultimodalData data = new MultimodalData();
        data.addData(ModalityType.TEXT, document.getContent());
        document.setData(data);
        
        qaService.indexDocument(document);
        
        // 验证文档已索引
        QAQuery query = new QAQuery("苹果公司的总部在哪里？");
        QAAnswer answer = qaService.answerQuestion(query);
        
        assertNotNull(answer);
        assertFalse(answer.isError());
    }
    
    @Test
    public void testCacheFunctionality() {
        QAQuery query = new QAQuery("什么是人工智能？");
        
        // 第一次查询
        QAAnswer answer1 = qaService.answerQuestion(query);
        
        // 第二次查询（应该命中缓存）
        QAAnswer answer2 = qaService.answerQuestion(query);
        
        assertNotNull(answer1);
        assertNotNull(answer2);
        // 验证缓存功能
    }
    
    @After
    public void tearDown() {
        if (qaService != null) {
            qaService.shutdown();
        }
    }
}
```

### 2. 性能测试

``java
public class PerformanceTest {
    private IntelligentQAService qaService;
    
    @Before
    public void setUp() {
        Configuration config = new Configuration();
        config.setProperty("cache.enabled", true);
        qaService = new IntelligentQAService(config);
    }
    
    @Test
    public void testResponseTime() {
        QAQuery query = new QAQuery("什么是机器学习？");
        
        long startTime = System.currentTimeMillis();
        QAAnswer answer = qaService.answerQuestion(query);
        long endTime = System.currentTimeMillis();
        
        long responseTime = endTime - startTime;
        assertTrue(responseTime < 5000); // 响应时间应小于5秒
        
        System.out.println("Response time: " + responseTime + "ms");
    }
    
    @Test
    public void testConcurrentQueries() throws InterruptedException {
        int threadCount = 10;
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<Long> responseTimes = Collections.synchronizedList(new ArrayList<>());
        
        for (int i = 0; i < threadCount; i++) {
            final int queryId = i;
            new Thread(() -> {
                try {
                    QAQuery query = new QAQuery("并发测试查询 " + queryId);
                    long startTime = System.currentTimeMillis();
                    QAAnswer answer = qaService.answerQuestion(query);
                    long endTime = System.currentTimeMillis();
                    responseTimes.add(endTime - startTime);
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await(30, TimeUnit.SECONDS);
        
        // 验证所有查询都成功处理
        assertEquals(threadCount, responseTimes.size());
        
        // 计算平均响应时间
        double avgResponseTime = responseTimes.stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);
        
        System.out.println("Average response time: " + avgResponseTime + "ms");
        assertTrue(avgResponseTime < 10000); // 平均响应时间应小于10秒
    }
    
    @Test
    public void testCachePerformance() {
        QAQuery query = new QAQuery("缓存性能测试");
        
        // 预热缓存
        qaService.answerQuestion(query);
        
        // 测试缓存命中性能
        long startTime = System.currentTimeMillis();
        QAAnswer answer = qaService.answerQuestion(query);
        long endTime = System.currentTimeMillis();
        
        long cacheHitTime = endTime - startTime;
        assertTrue(cacheHitTime < 100); // 缓存命中应非常快
        
        System.out.println("Cache hit time: " + cacheHitTime + "ms");
    }
    
    @After
    public void tearDown() {
        if (qaService != null) {
            qaService.shutdown();
        }
    }
}
```

## 部署和运维

### 1. 配置管理

``java
public class ConfigurationLoader {
    
    public static Configuration loadConfiguration(String configPath) {
        Configuration config = new Configuration();
        
        try (InputStream input = new FileInputStream(configPath)) {
            Properties properties = new Properties();
            properties.load(input);
            
            // 加载配置属性
            for (String key : properties.stringPropertyNames()) {
                String value = properties.getProperty(key);
                config.setProperty(key, parseValue(value));
            }
        } catch (IOException e) {
            System.err.println("Failed to load configuration: " + e.getMessage());
        }
        
        return config;
    }
    
    private static Object parseValue(String value) {
        // 简化的值解析
        if (value.equalsIgnoreCase("true")) {
            return true;
        } else if (value.equalsIgnoreCase("false")) {
            return false;
        } else {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e1) {
                try {
                    return Double.parseDouble(value);
                } catch (NumberFormatException e2) {
                    return value;
                }
            }
        }
    }
}
```

### 2. 监控和告警

``java
public class SystemAlertManager {
    private SystemMonitor monitor;
    private List<AlertHandler> alertHandlers;
    private ScheduledExecutorService scheduler;
    
    public SystemAlertManager(SystemMonitor monitor) {
        this.monitor = monitor;
        this.alertHandlers = new ArrayList<>();
        this.scheduler = Executors.newScheduledThreadPool(1);
        
        // 启动定期检查
        this.scheduler.scheduleAtFixedRate(this::checkSystemHealth, 0, 5, TimeUnit.MINUTES);
    }
    
    public void addAlertHandler(AlertHandler handler) {
        alertHandlers.add(handler);
    }
    
    private void checkSystemHealth() {
        SystemHealth health = monitor.checkHealth();
        
        if (!health.isHealthy()) {
            Alert alert = new Alert();
            alert.setType(AlertType.SYSTEM_HEALTH);
            alert.setSeverity(health.getStatus() == HealthStatus.DEGRADED ? 
                            AlertSeverity.WARNING : AlertSeverity.CRITICAL);
            alert.setMessage("System health check failed: " + health.getStatus());
            alert.setTimestamp(System.currentTimeMillis());
            
            notifyAlertHandlers(alert);
        }
    }
    
    private void notifyAlertHandlers(Alert alert) {
        for (AlertHandler handler : alertHandlers) {
            try {
                handler.handleAlert(alert);
            } catch (Exception e) {
                System.err.println("Failed to handle alert: " + e.getMessage());
            }
        }
    }
    
    public void shutdown() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}

interface AlertHandler {
    void handleAlert(Alert alert);
}

class Alert {
    private AlertType type;
    private AlertSeverity severity;
    private String message;
    private long timestamp;
    
    // Getters and Setters
    public AlertType getType() { return type; }
    public void setType(AlertType type) { this.type = type; }
    
    public AlertSeverity getSeverity() { return severity; }
    public void setSeverity(AlertSeverity severity) { this.severity = severity; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

enum AlertType {
    SYSTEM_HEALTH, PERFORMANCE, ERROR_RATE
}

enum AlertSeverity {
    INFO, WARNING, CRITICAL
}
```

## 项目总结

通过本项目的完整实现，我们构建了一个功能完整的智能问答系统，涵盖了：

1. **核心架构实现**：实现了基于模块化的智能问答系统架构
2. **多模态支持**：支持文本、图像、代码等多种模态的查询处理
3. **检索增强**：结合向量检索和知识图谱增强问答能力
4. **智能推理**：具备复杂问题的多步骤推理解决能力
5. **系统优化**：实现了缓存、并发处理等性能优化技术
6. **监控运维**：提供了完整的系统监控和告警机制

这个智能问答系统具备了以下核心能力：

- **多模态理解**：能够理解和处理多种类型的输入查询
- **知识增强**：利用知识图谱提升问答的准确性和丰富性
- **智能推理**：能够进行复杂问题的多步骤分析和推理
- **高效检索**：基于向量的高效文档检索能力
- **缓存优化**：通过缓存机制提升重复查询的响应速度
- **可扩展性**：模块化设计支持系统的灵活扩展

## 扩展思考

1. **实时学习**：如何实现系统的在线学习和知识更新
2. **个性化服务**：如何根据用户偏好提供个性化问答服务
3. **多语言支持**：如何扩展系统支持多种语言的问答
4. **安全控制**：如何加强系统的安全性和隐私保护
5. **分布式部署**：如何将系统部署到分布式环境中
6. **持续优化**：如何实现系统的持续学习和自我优化

通过不断实践和优化，我们可以构建出更加智能、高效、安全的问答系统，为用户提供更好的服务体验。

在下一章中，我们将学习多智能体系统与应用实战，掌握构建复杂AI应用生态系统的关键技术。
    HEALTHY, DEGRADED, UNHEALTHY