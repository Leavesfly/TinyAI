# 17.3 知识图谱构建与维护

> **设计思想**：掌握知识图谱的构建和维护方法，实现结构化知识的管理和应用

## 本节概述

知识图谱是一种结构化的语义网络，用于描述现实世界中的实体及其相互关系。它以图的形式组织知识，其中节点代表实体，边代表实体间的关系。知识图谱在搜索引擎、智能问答、推荐系统等领域有着广泛的应用。

本节将深入探讨知识图谱的核心概念、构建方法、存储技术以及维护策略，并通过实际代码实现来加深理解。

## 学习目标

完成本节学习后，你将：

- ✅ **理解知识图谱概念**：掌握知识图谱的基本结构和核心组件
- ✅ **掌握实体识别技术**：学会从文本中识别和提取实体
- ✅ **实现关系抽取方法**：掌握实体间关系的自动抽取技术
- ✅ **构建知识图谱存储**：学会设计和实现知识图谱的存储系统
- ✅ **掌握图谱查询语言**：理解图查询语言（如SPARQL）的使用方法
- ✅ **实现知识图谱维护**：掌握知识图谱的更新和维护策略

## 知识图谱基本概念

### 1. 知识图谱定义

知识图谱是一种结构化的语义网络，用于描述物理世界中的概念及其相互关系。它由以下核心组件构成：

1. **实体（Entity）**：现实世界中的对象或概念，如"苹果公司"、"乔布斯"
2. **属性（Attribute）**：实体的特征或描述信息，如"苹果公司的成立时间"
3. **关系（Relation）**：实体之间的关联，如"乔布斯创立了苹果公司"
4. **本体（Ontology）**：对概念、属性和关系的形式化描述

```mermaid
graph TB
    subgraph "知识图谱结构"
        A[实体<br/>Entity]
        B[属性<br/>Attribute]
        C[关系<br/>Relation]
        D[本体<br/>Ontology]
    end
    
    A --> B
    A --> C
    C --> D
```

### 2. 知识图谱表示

知识图谱通常用三元组（Subject, Predicate, Object）的形式表示知识：

```java
public class Triple {
    private String subject;    // 主体
    private String predicate;  // 谓词/关系
    private String object;     // 客体
    
    public Triple(String subject, String predicate, String object) {
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
    }
    
    // Getters
    public String getSubject() { return subject; }
    public String getPredicate() { return predicate; }
    public String getObject() { return object; }
    
    @Override
    public String toString() {
        return String.format("(%s, %s, %s)", subject, predicate, object);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Triple triple = (Triple) obj;
        return Objects.equals(subject, triple.subject) &&
               Objects.equals(predicate, triple.predicate) &&
               Objects.equals(object, triple.object);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(subject, predicate, object);
    }
}
```

## 实体识别技术

### 1. 基于规则的实体识别

```java
public class RuleBasedEntityRecognizer {
    private Map<EntityType, List<Pattern>> patterns;
    
    public RuleBasedEntityRecognizer() {
        this.patterns = new HashMap<>();
        initializePatterns();
    }
    
    private void initializePatterns() {
        // 人名模式
        List<Pattern> personPatterns = Arrays.asList(
            Pattern.compile("\\b[A-Z][a-z]+\\s+[A-Z][a-z]+\\b"),
            Pattern.compile("\\b[A-Z]\\.\\s+[A-Z][a-z]+\\b")
        );
        patterns.put(EntityType.PERSON, personPatterns);
        
        // 组织机构名模式
        List<Pattern> orgPatterns = Arrays.asList(
            Pattern.compile("\\b[A-Z][a-z]+\\s+(Inc|Corp|Ltd|Company|Corporation)\\b"),
            Pattern.compile("\\b[A-Z][a-z]+\\s+University\\b")
        );
        patterns.put(EntityType.ORGANIZATION, orgPatterns);
        
        // 地名模式
        List<Pattern> locationPatterns = Arrays.asList(
            Pattern.compile("\\b[A-Z][a-z]+\\s+(Street|Avenue|Road|Lane)\\b"),
            Pattern.compile("\\b[A-Z][a-z]+,\\s+[A-Z]{2}\\b")
        );
        patterns.put(EntityType.LOCATION, locationPatterns);
        
        // 日期模式
        List<Pattern> datePatterns = Arrays.asList(
            Pattern.compile("\\b\\d{1,2}/\\d{1,2}/\\d{4}\\b"),
            Pattern.compile("\\b\\d{4}-\\d{2}-\\d{2}\\b")
        );
        patterns.put(EntityType.DATE, datePatterns);
    }
    
    public List<RecognizedEntity> recognizeEntities(String text) {
        List<RecognizedEntity> entities = new ArrayList<>();
        
        for (Map.Entry<EntityType, List<Pattern>> entry : patterns.entrySet()) {
            EntityType type = entry.getKey();
            List<Pattern> typePatterns = entry.getValue();
            
            for (Pattern pattern : typePatterns) {
                Matcher matcher = pattern.matcher(text);
                while (matcher.find()) {
                    String entityText = matcher.group();
                    int start = matcher.start();
                    int end = matcher.end();
                    entities.add(new RecognizedEntity(entityText, type, start, end));
                }
            }
        }
        
        // 按位置排序
        entities.sort(Comparator.comparingInt(RecognizedEntity::getStart));
        return entities;
    }
    
    public void addPattern(EntityType type, Pattern pattern) {
        patterns.computeIfAbsent(type, k -> new ArrayList<>()).add(pattern);
    }
}

enum EntityType {
    PERSON, ORGANIZATION, LOCATION, DATE, TIME, MONEY, PERCENTAGE
}

class RecognizedEntity {
    private String text;
    private EntityType type;
    private int start;
    private int end;
    
    public RecognizedEntity(String text, EntityType type, int start, int end) {
        this.text = text;
        this.type = type;
        this.start = start;
        this.end = end;
    }
    
    // Getters
    public String getText() { return text; }
    public EntityType getType() { return type; }
    public int getStart() { return start; }
    public int getEnd() { return end; }
    
    @Override
    public String toString() {
        return String.format("[%s] %s (%d-%d)", type, text, start, end);
    }
}
```

### 2. 基于机器学习的实体识别

```java
public class MLBasedEntityRecognizer {
    private SequenceLabelingModel model;
    
    public MLBasedEntityRecognizer(SequenceLabelingModel model) {
        this.model = model;
    }
    
    public List<RecognizedEntity> recognizeEntities(String text) {
        // 1. 文本分词
        List<String> tokens = tokenize(text);
        
        // 2. 预测标签
        List<String> labels = model.predict(tokens);
        
        // 3. 构建实体
        return buildEntities(tokens, labels);
    }
    
    private List<String> tokenize(String text) {
        // 简单的分词实现
        return Arrays.asList(text.split("\\s+"));
    }
    
    private List<RecognizedEntity> buildEntities(List<String> tokens, List<String> labels) {
        List<RecognizedEntity> entities = new ArrayList<>();
        StringBuilder currentEntity = new StringBuilder();
        EntityType currentType = null;
        int startPos = -1;
        
        for (int i = 0; i < tokens.size(); i++) {
            String token = tokens.get(i);
            String label = labels.get(i);
            
            if (label.startsWith("B-")) {
                // 开始新的实体
                if (currentEntity.length() > 0) {
                    // 保存之前的实体
                    entities.add(new RecognizedEntity(
                        currentEntity.toString().trim(), 
                        currentType, 
                        startPos, 
                        startPos + currentEntity.length()
                    ));
                    currentEntity.setLength(0);
                }
                
                // 开始新实体
                currentEntity.append(token);
                currentType = parseEntityType(label.substring(2));
                startPos = i;
            } else if (label.startsWith("I-") && currentEntity.length() > 0) {
                // 继续当前实体
                currentEntity.append(" ").append(token);
            } else {
                // 结束当前实体
                if (currentEntity.length() > 0) {
                    entities.add(new RecognizedEntity(
                        currentEntity.toString().trim(), 
                        currentType, 
                        startPos, 
                        startPos + currentEntity.length()
                    ));
                    currentEntity.setLength(0);
                }
            }
        }
        
        // 处理最后一个实体
        if (currentEntity.length() > 0) {
            entities.add(new RecognizedEntity(
                currentEntity.toString().trim(), 
                currentType, 
                startPos, 
                startPos + currentEntity.length()
            ));
        }
        
        return entities;
    }
    
    private EntityType parseEntityType(String typeStr) {
        try {
            return EntityType.valueOf(typeStr.toUpperCase());
        } catch (IllegalArgumentException e) {
            return EntityType.PERSON; // 默认类型
        }
    }
}

// 序列标注模型接口
interface SequenceLabelingModel {
    List<String> predict(List<String> tokens);
}

// 模拟序列标注模型
class MockSequenceLabelingModel implements SequenceLabelingModel {
    @Override
    public List<String> predict(List<String> tokens) {
        List<String> labels = new ArrayList<>();
        Random random = new Random(42);
        
        for (String token : tokens) {
            // 简单的随机标签生成（实际应用中应使用训练好的模型）
            String[] possibleLabels = {"O", "B-PERSON", "I-PERSON", "B-ORG", "I-ORG", "B-LOC", "I-LOC"};
            labels.add(possibleLabels[random.nextInt(possibleLabels.length)]);
        }
        
        return labels;
    }
}
```

## 关系抽取技术

### 1. 基于依存句法的关系抽取

```java
public class DependencyBasedRelationExtractor {
    private DependencyParser parser;
    
    public DependencyBasedRelationExtractor(DependencyParser parser) {
        this.parser = parser;
    }
    
    public List<ExtractedRelation> extractRelations(String sentence) {
        List<ExtractedRelation> relations = new ArrayList<>();
        
        // 1. 解析依存句法
        DependencyParseResult parseResult = parser.parse(sentence);
        
        // 2. 识别实体对
        List<EntityPair> entityPairs = identifyEntityPairs(parseResult);
        
        // 3. 抽取关系
        for (EntityPair pair : entityPairs) {
            String relation = extractRelation(parseResult, pair);
            if (relation != null && !relation.isEmpty()) {
                relations.add(new ExtractedRelation(
                    pair.getEntity1(), 
                    relation, 
                    pair.getEntity2(), 
                    sentence
                ));
            }
        }
        
        return relations;
    }
    
    private List<EntityPair> identifyEntityPairs(DependencyParseResult parseResult) {
        List<EntityPair> pairs = new ArrayList<>();
        List<RecognizedEntity> entities = parseResult.getEntities();
        
        // 生成所有实体对
        for (int i = 0; i < entities.size(); i++) {
            for (int j = i + 1; j < entities.size(); j++) {
                pairs.add(new EntityPair(entities.get(i), entities.get(j)));
            }
        }
        
        return pairs;
    }
    
    private String extractRelation(DependencyParseResult parseResult, EntityPair pair) {
        // 基于依存路径的关系抽取
        List<DependencyEdge> path = findDependencyPath(
            parseResult, 
            pair.getEntity1().getStart(), 
            pair.getEntity2().getStart()
        );
        
        if (path.isEmpty()) {
            return null;
        }
        
        // 简化的规则：基于路径中的依存关系类型
        StringBuilder relation = new StringBuilder();
        for (DependencyEdge edge : path) {
            if (!edge.getRelation().equals("punct")) { // 忽略标点符号
                if (relation.length() > 0) {
                    relation.append("_");
                }
                relation.append(edge.getRelation());
            }
        }
        
        return relation.toString();
    }
    
    private List<DependencyEdge> findDependencyPath(
            DependencyParseResult parseResult, int start1, int start2) {
        // 简化的最短路径查找（实际应用中应使用图算法）
        List<DependencyEdge> edges = parseResult.getEdges();
        List<DependencyEdge> path = new ArrayList<>();
        
        // 这里简化处理，实际应实现BFS或Dijkstra算法
        for (DependencyEdge edge : edges) {
            if ((edge.getFrom() == start1 && edge.getTo() == start2) ||
                (edge.getFrom() == start2 && edge.getTo() == start1)) {
                path.add(edge);
            }
        }
        
        return path;
    }
}

class EntityPair {
    private RecognizedEntity entity1;
    private RecognizedEntity entity2;
    
    public EntityPair(RecognizedEntity entity1, RecognizedEntity entity2) {
        // 确保实体按位置排序
        if (entity1.getStart() <= entity2.getStart()) {
            this.entity1 = entity1;
            this.entity2 = entity2;
        } else {
            this.entity1 = entity2;
            this.entity2 = entity1;
        }
    }
    
    // Getters
    public RecognizedEntity getEntity1() { return entity1; }
    public RecognizedEntity getEntity2() { return entity2; }
}

class ExtractedRelation {
    private RecognizedEntity subject;
    private String relation;
    private RecognizedEntity object;
    private String sentence;
    private double confidence;
    
    public ExtractedRelation(RecognizedEntity subject, String relation, 
                           RecognizedEntity object, String sentence) {
        this(subject, relation, object, sentence, 1.0);
    }
    
    public ExtractedRelation(RecognizedEntity subject, String relation, 
                           RecognizedEntity object, String sentence, double confidence) {
        this.subject = subject;
        this.relation = relation;
        this.object = object;
        this.sentence = sentence;
        this.confidence = confidence;
    }
    
    // Getters
    public RecognizedEntity getSubject() { return subject; }
    public String getRelation() { return relation; }
    public RecognizedEntity getObject() { return object; }
    public String getSentence() { return sentence; }
    public double getConfidence() { return confidence; }
}

// 依存句法解析器接口
interface DependencyParser {
    DependencyParseResult parse(String sentence);
}

// 依存句法解析结果
class DependencyParseResult {
    private List<RecognizedEntity> entities;
    private List<DependencyEdge> edges;
    
    public DependencyParseResult(List<RecognizedEntity> entities, 
                               List<DependencyEdge> edges) {
        this.entities = entities;
        this.edges = edges;
    }
    
    // Getters
    public List<RecognizedEntity> getEntities() { return entities; }
    public List<DependencyEdge> getEdges() { return edges; }
}

// 依存关系边
class DependencyEdge {
    private int from;
    private int to;
    private String relation;
    
    public DependencyEdge(int from, int to, String relation) {
        this.from = from;
        this.to = to;
        this.relation = relation;
    }
    
    // Getters
    public int getFrom() { return from; }
    public int getTo() { return to; }
    public String getRelation() { return relation; }
}

// 模拟依存句法解析器
class MockDependencyParser implements DependencyParser {
    private RuleBasedEntityRecognizer entityRecognizer;
    
    public MockDependencyParser() {
        this.entityRecognizer = new RuleBasedEntityRecognizer();
    }
    
    @Override
    public DependencyParseResult parse(String sentence) {
        // 1. 实体识别
        List<RecognizedEntity> entities = entityRecognizer.recognizeEntities(sentence);
        
        // 2. 生成模拟的依存关系（实际应用中应使用真实的解析器）
        List<DependencyEdge> edges = generateMockEdges(sentence, entities);
        
        return new DependencyParseResult(entities, edges);
    }
    
    private List<DependencyEdge> generateMockEdges(String sentence, 
                                                 List<RecognizedEntity> entities) {
        List<DependencyEdge> edges = new ArrayList<>();
        String[] tokens = sentence.split("\\s+");
        
        // 简单的依存关系生成
        for (int i = 0; i < tokens.length - 1; i++) {
            edges.add(new DependencyEdge(i, i + 1, "dep"));
        }
        
        return edges;
    }
}
```

### 2. 基于深度学习的关系抽取

```java
public class DeepLearningRelationExtractor {
    private RelationClassificationModel model;
    
    public DeepLearningRelationExtractor(RelationClassificationModel model) {
        this.model = model;
    }
    
    public List<ExtractedRelation> extractRelations(String sentence) {
        List<ExtractedRelation> relations = new ArrayList<>();
        
        // 1. 实体识别
        List<RecognizedEntity> entities = recognizeEntities(sentence);
        
        // 2. 生成实体对
        List<EntityPair> entityPairs = generateEntityPairs(entities);
        
        // 3. 关系分类
        for (EntityPair pair : entityPairs) {
            RelationClassificationResult result = model.classify(
                sentence, pair.getEntity1(), pair.getEntity2());
            
            if (result.getConfidence() > 0.5) { // 置信度阈值
                relations.add(new ExtractedRelation(
                    pair.getEntity1(),
                    result.getRelationType(),
                    pair.getEntity2(),
                    sentence,
                    result.getConfidence()
                ));
            }
        }
        
        return relations;
    }
    
    private List<RecognizedEntity> recognizeEntities(String sentence) {
        // 使用实体识别器（这里简化处理）
        RuleBasedEntityRecognizer recognizer = new RuleBasedEntityRecognizer();
        return recognizer.recognizeEntities(sentence);
    }
    
    private List<EntityPair> generateEntityPairs(List<RecognizedEntity> entities) {
        List<EntityPair> pairs = new ArrayList<>();
        for (int i = 0; i < entities.size(); i++) {
            for (int j = i + 1; j < entities.size(); j++) {
                pairs.add(new EntityPair(entities.get(i), entities.get(j)));
            }
        }
        return pairs;
    }
}

// 关系分类模型接口
interface RelationClassificationModel {
    RelationClassificationResult classify(String sentence, 
                                       RecognizedEntity entity1, 
                                       RecognizedEntity entity2);
}

// 关系分类结果
class RelationClassificationResult {
    private String relationType;
    private double confidence;
    
    public RelationClassificationResult(String relationType, double confidence) {
        this.relationType = relationType;
        this.confidence = confidence;
    }
    
    // Getters
    public String getRelationType() { return relationType; }
    public double getConfidence() { return confidence; }
}

// 模拟关系分类模型
class MockRelationClassificationModel implements RelationClassificationModel {
    @Override
    public RelationClassificationResult classify(String sentence, 
                                              RecognizedEntity entity1, 
                                              RecognizedEntity entity2) {
        Random random = new Random(42);
        String[] relations = {"works_for", "located_in", "founded_by", "born_in", "married_to"};
        String relation = relations[random.nextInt(relations.length)];
        double confidence = random.nextDouble();
        
        return new RelationClassificationResult(relation, confidence);
    }
}
```

## 知识图谱存储实现

### 1. 图数据库存储

```java
public class GraphDatabaseKnowledgeGraph {
    private Map<String, GraphNode> nodes;
    private Map<Triple, GraphEdge> edges;
    private ReadWriteLock lock;
    
    public GraphDatabaseKnowledgeGraph() {
        this.nodes = new ConcurrentHashMap<>();
        this.edges = new ConcurrentHashMap<>();
        this.lock = new ReentrantReadWriteLock();
    }
    
    public void addNode(String nodeId, Map<String, Object> properties) {
        lock.writeLock().lock();
        try {
            nodes.put(nodeId, new GraphNode(nodeId, properties));
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void addEdge(String fromNodeId, String toNodeId, 
                       String relation, Map<String, Object> properties) {
        lock.writeLock().lock();
        try {
            // 确保节点存在
            if (!nodes.containsKey(fromNodeId)) {
                addNode(fromNodeId, new HashMap<>());
            }
            if (!nodes.containsKey(toNodeId)) {
                addNode(toNodeId, new HashMap<>());
            }
            
            Triple triple = new Triple(fromNodeId, relation, toNodeId);
            edges.put(triple, new GraphEdge(fromNodeId, toNodeId, relation, properties));
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public GraphNode getNode(String nodeId) {
        lock.readLock().lock();
        try {
            return nodes.get(nodeId);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<GraphEdge> getEdges(String nodeId) {
        lock.readLock().lock();
        try {
            return edges.values().stream()
                .filter(edge -> edge.getFromNodeId().equals(nodeId) || 
                               edge.getToNodeId().equals(nodeId))
                .collect(Collectors.toList());
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<GraphNode> queryNodes(Map<String, Object> conditions) {
        lock.readLock().lock();
        try {
            return nodes.values().stream()
                .filter(node -> matchesConditions(node, conditions))
                .collect(Collectors.toList());
        } finally {
            lock.readLock().unlock();
        }
    }
    
    private boolean matchesConditions(GraphNode node, Map<String, Object> conditions) {
        for (Map.Entry<String, Object> entry : conditions.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            Object nodeValue = node.getProperties().get(key);
            if (nodeValue == null || !nodeValue.equals(value)) {
                return false;
            }
        }
        return true;
    }
    
    public void updateNode(String nodeId, Map<String, Object> properties) {
        lock.writeLock().lock();
        try {
            GraphNode node = nodes.get(nodeId);
            if (node != null) {
                node.getProperties().putAll(properties);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void deleteNode(String nodeId) {
        lock.writeLock().lock();
        try {
            nodes.remove(nodeId);
            // 删除相关的边
            edges.entrySet().removeIf(entry -> {
                Triple triple = entry.getKey();
                return triple.getSubject().equals(nodeId) || triple.getObject().equals(nodeId);
            });
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int getNodeCount() {
        lock.readLock().lock();
        try {
            return nodes.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public int getEdgeCount() {
        lock.readLock().lock();
        try {
            return edges.size();
        } finally {
            lock.readLock().unlock();
        }
    }
}

class GraphNode {
    private String id;
    private Map<String, Object> properties;
    
    public GraphNode(String id, Map<String, Object> properties) {
        this.id = id;
        this.properties = new HashMap<>(properties);
    }
    
    // Getters and Setters
    public String getId() { return id; }
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { 
        this.properties = new HashMap<>(properties); 
    }
}

class GraphEdge {
    private String fromNodeId;
    private String toNodeId;
    private String relation;
    private Map<String, Object> properties;
    
    public GraphEdge(String fromNodeId, String toNodeId, String relation, 
                    Map<String, Object> properties) {
        this.fromNodeId = fromNodeId;
        this.toNodeId = toNodeId;
        this.relation = relation;
        this.properties = new HashMap<>(properties);
    }
    
    // Getters
    public String getFromNodeId() { return fromNodeId; }
    public String getToNodeId() { return toNodeId; }
    public String getRelation() { return relation; }
    public Map<String, Object> getProperties() { return properties; }
}
```

### 2. RDF三元组存储

```java
public class RDFKnowledgeGraph {
    private Set<Triple> triples;
    private Map<String, Set<Triple>> subjectIndex;
    private Map<String, Set<Triple>> predicateIndex;
    private Map<String, Set<Triple>> objectIndex;
    private ReadWriteLock lock;
    
    public RDFKnowledgeGraph() {
        this.triples = new HashSet<>();
        this.subjectIndex = new HashMap<>();
        this.predicateIndex = new HashMap<>();
        this.objectIndex = new HashMap<>();
        this.lock = new ReentrantReadWriteLock();
    }
    
    public void addTriple(String subject, String predicate, String object) {
        Triple triple = new Triple(subject, predicate, object);
        
        lock.writeLock().lock();
        try {
            if (triples.add(triple)) {
                // 更新索引
                subjectIndex.computeIfAbsent(subject, k -> new HashSet<>()).add(triple);
                predicateIndex.computeIfAbsent(predicate, k -> new HashSet<>()).add(triple);
                objectIndex.computeIfAbsent(object, k -> new HashSet<>()).add(triple);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public Set<Triple> queryBySubject(String subject) {
        lock.readLock().lock();
        try {
            return new HashSet<>(subjectIndex.getOrDefault(subject, new HashSet<>()));
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public Set<Triple> queryByPredicate(String predicate) {
        lock.readLock().lock();
        try {
            return new HashSet<>(predicateIndex.getOrDefault(predicate, new HashSet<>()));
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public Set<Triple> queryByObject(String object) {
        lock.readLock().lock();
        try {
            return new HashSet<>(objectIndex.getOrDefault(object, new HashSet<>()));
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public Set<Triple> queryBySPARQL(String sparqlQuery) {
        // 简化的SPARQL查询解析（实际应用中应使用完整的SPARQL解析器）
        return parseAndExecuteSPARQL(sparqlQuery);
    }
    
    private Set<Triple> parseAndExecuteSPARQL(String sparqlQuery) {
        // 这里简化处理，实际应实现完整的SPARQL解析和执行
        Set<Triple> results = new HashSet<>();
        
        // 解析WHERE子句中的三元组模式
        Pattern pattern = Pattern.compile(
            "WHERE\\s*\\{\\s*([^\\}]+)\\s*\\}", 
            Pattern.CASE_INSENSITIVE
        );
        Matcher matcher = pattern.matcher(sparqlQuery);
        
        if (matcher.find()) {
            String whereClause = matcher.group(1);
            String[] patterns = whereClause.split("\\s*;\\s*");
            
            for (String patternStr : patterns) {
                patternStr = patternStr.trim();
                if (patternStr.endsWith(".")) {
                    patternStr = patternStr.substring(0, patternStr.length() - 1);
                }
                
                String[] parts = patternStr.split("\\s+");
                if (parts.length >= 3) {
                    String subject = parts[0];
                    String predicate = parts[1];
                    String object = parts[2];
                    
                    // 处理变量（以?开头）
                    if (subject.startsWith("?")) {
                        // 变量，需要匹配所有subject
                        results.addAll(triples);
                    } else if (predicate.startsWith("?")) {
                        // 变量，需要匹配所有predicate
                        results.addAll(triples);
                    } else if (object.startsWith("?")) {
                        // 变量，需要匹配所有object
                        results.addAll(triples);
                    } else {
                        // 具体值，查找匹配的三元组
                        Triple target = new Triple(subject, predicate, object);
                        if (triples.contains(target)) {
                            results.add(target);
                        }
                    }
                }
            }
        }
        
        return results;
    }
    
    public void removeTriple(String subject, String predicate, String object) {
        Triple triple = new Triple(subject, predicate, object);
        
        lock.writeLock().lock();
        try {
            if (triples.remove(triple)) {
                // 更新索引
                Set<Triple> subjectTriples = subjectIndex.get(subject);
                if (subjectTriples != null) {
                    subjectTriples.remove(triple);
                }
                
                Set<Triple> predicateTriples = predicateIndex.get(predicate);
                if (predicateTriples != null) {
                    predicateTriples.remove(triple);
                }
                
                Set<Triple> objectTriples = objectIndex.get(object);
                if (objectTriples != null) {
                    objectTriples.remove(triple);
                }
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int size() {
        lock.readLock().lock();
        try {
            return triples.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public Set<Triple> getAllTriples() {
        lock.readLock().lock();
        try {
            return new HashSet<>(triples);
        } finally {
            lock.readLock().unlock();
        }
    }
}
```

## 知识图谱查询语言

### 1. SPARQL查询示例

```java
public class SPARQLQueryExecutor {
    private RDFKnowledgeGraph knowledgeGraph;
    
    public SPARQLQueryExecutor(RDFKnowledgeGraph knowledgeGraph) {
        this.knowledgeGraph = knowledgeGraph;
    }
    
    public QueryResult executeQuery(String sparqlQuery) {
        // 解析SPARQL查询
        SPARQLQuery parsedQuery = parseSPARQL(sparqlQuery);
        
        // 执行查询
        return executeParsedQuery(parsedQuery);
    }
    
    private SPARQLQuery parseSPARQL(String sparqlQuery) {
        // 简化的SPARQL解析器
        SPARQLQuery query = new SPARQLQuery();
        
        // 提取SELECT子句
        Pattern selectPattern = Pattern.compile(
            "SELECT\\s+(.+?)\\s+WHERE", 
            Pattern.CASE_INSENSITIVE
        );
        Matcher selectMatcher = selectPattern.matcher(sparqlQuery);
        if (selectMatcher.find()) {
            String selectClause = selectMatcher.group(1).trim();
            String[] variables = selectClause.split("\\s+");
            for (String variable : variables) {
                if (variable.startsWith("?")) {
                    query.addSelectVariable(variable);
                }
            }
        }
        
        // 提取WHERE子句
        Pattern wherePattern = Pattern.compile(
            "WHERE\\s*\\{\\s*(.+?)\\s*\\}", 
            Pattern.CASE_INSENSITIVE | Pattern.DOTALL
        );
        Matcher whereMatcher = wherePattern.matcher(sparqlQuery);
        if (whereMatcher.find()) {
            String whereClause = whereMatcher.group(1).trim();
            query.setWhereClause(whereClause);
        }
        
        return query;
    }
    
    private QueryResult executeParsedQuery(SPARQLQuery query) {
        QueryResult result = new QueryResult();
        
        // 解析WHERE子句中的三元组模式
        String whereClause = query.getWhereClause();
        String[] triplePatterns = whereClause.split("\\s*;\\s*|\\s*\\.\\s*");
        
        // 执行查询（简化实现）
        for (String pattern : triplePatterns) {
            pattern = pattern.trim();
            if (!pattern.isEmpty()) {
                String[] parts = pattern.split("\\s+");
                if (parts.length >= 3) {
                    String subject = parts[0];
                    String predicate = parts[1];
                    String object = parts[2];
                    
                    // 根据模式类型执行查询
                    if (!subject.startsWith("?")) {
                        // 具体subject查询
                        Set<Triple> triples = knowledgeGraph.queryBySubject(subject);
                        result.addTriples(triples);
                    } else if (!predicate.startsWith("?")) {
                        // 具体predicate查询
                        Set<Triple> triples = knowledgeGraph.queryByPredicate(predicate);
                        result.addTriples(triples);
                    } else if (!object.startsWith("?")) {
                        // 具体object查询
                        Set<Triple> triples = knowledgeGraph.queryByObject(object);
                        result.addTriples(triples);
                    } else {
                        // 全部是变量，返回所有三元组
                        result.addTriples(knowledgeGraph.getAllTriples());
                    }
                }
            }
        }
        
        return result;
    }
}

class SPARQLQuery {
    private List<String> selectVariables;
    private String whereClause;
    
    public SPARQLQuery() {
        this.selectVariables = new ArrayList<>();
    }
    
    public void addSelectVariable(String variable) {
        selectVariables.add(variable);
    }
    
    public void setWhereClause(String whereClause) {
        this.whereClause = whereClause;
    }
    
    // Getters
    public List<String> getSelectVariables() { return selectVariables; }
    public String getWhereClause() { return whereClause; }
}

class QueryResult {
    private Set<Triple> triples;
    private List<Map<String, String>> bindings;
    
    public QueryResult() {
        this.triples = new HashSet<>();
        this.bindings = new ArrayList<>();
    }
    
    public void addTriples(Set<Triple> triples) {
        this.triples.addAll(triples);
    }
    
    public void addBinding(Map<String, String> binding) {
        this.bindings.add(binding);
    }
    
    // Getters
    public Set<Triple> getTriples() { return triples; }
    public List<Map<String, String>> getBindings() { return bindings; }
}
```

## 知识图谱维护策略

### 1. 增量更新机制

```java
public class KnowledgeGraphUpdater {
    private RDFKnowledgeGraph knowledgeGraph;
    private ChangeLog changeLog;
    private ConflictResolver conflictResolver;
    
    public KnowledgeGraphUpdater(RDFKnowledgeGraph knowledgeGraph) {
        this.knowledgeGraph = knowledgeGraph;
        this.changeLog = new ChangeLog();
        this.conflictResolver = new SimpleConflictResolver();
    }
    
    public void addTriple(String subject, String predicate, String object) {
        Triple newTriple = new Triple(subject, predicate, object);
        
        // 检查是否存在冲突
        Set<Triple> existingTriples = knowledgeGraph.queryBySubject(subject);
        for (Triple existing : existingTriples) {
            if (existing.getPredicate().equals(predicate) && 
                !existing.getObject().equals(object)) {
                // 存在冲突，需要解决
                ConflictResolution resolution = conflictResolver.resolve(
                    newTriple, existing);
                if (resolution.getAction() == ConflictAction.REPLACE) {
                    knowledgeGraph.removeTriple(
                        existing.getSubject(), 
                        existing.getPredicate(), 
                        existing.getObject()
                    );
                } else if (resolution.getAction() == ConflictAction.SKIP) {
                    return; // 跳过添加
                }
                // 如果是MERGE，则继续添加
            }
        }
        
        // 添加新三元组
        knowledgeGraph.addTriple(subject, predicate, object);
        
        // 记录变更日志
        changeLog.logChange(ChangeType.ADD, newTriple);
    }
    
    public void updateTriple(String subject, String predicate, String oldObject, 
                           String newObject) {
        // 移除旧三元组
        knowledgeGraph.removeTriple(subject, predicate, oldObject);
        
        // 添加新三元组
        knowledgeGraph.addTriple(subject, predicate, newObject);
        
        // 记录变更日志
        changeLog.logChange(ChangeType.UPDATE, 
            new Triple(subject, predicate, oldObject),
            new Triple(subject, predicate, newObject)
        );
    }
    
    public void removeTriple(String subject, String predicate, String object) {
        knowledgeGraph.removeTriple(subject, predicate, object);
        
        // 记录变更日志
        changeLog.logChange(ChangeType.DELETE, new Triple(subject, predicate, object));
    }
    
    public void batchUpdate(List<TripleChange> changes) {
        for (TripleChange change : changes) {
            switch (change.getChangeType()) {
                case ADD:
                    addTriple(
                        change.getTriple().getSubject(),
                        change.getTriple().getPredicate(),
                        change.getTriple().getObject()
                    );
                    break;
                case DELETE:
                    removeTriple(
                        change.getTriple().getSubject(),
                        change.getTriple().getPredicate(),
                        change.getTriple().getObject()
                    );
                    break;
                case UPDATE:
                    updateTriple(
                        change.getOldTriple().getSubject(),
                        change.getOldTriple().getPredicate(),
                        change.getOldTriple().getObject(),
                        change.getNewTriple().getObject()
                    );
                    break;
            }
        }
    }
    
    public ChangeLog getChangeLog() {
        return changeLog;
    }
}

enum ChangeType {
    ADD, DELETE, UPDATE
}

enum ConflictAction {
    REPLACE, MERGE, SKIP
}

class TripleChange {
    private ChangeType changeType;
    private Triple oldTriple;
    private Triple newTriple;
    
    public TripleChange(ChangeType changeType, Triple triple) {
        this(changeType, triple, null);
    }
    
    public TripleChange(ChangeType changeType, Triple oldTriple, Triple newTriple) {
        this.changeType = changeType;
        this.oldTriple = oldTriple;
        this.newTriple = newTriple;
    }
    
    // Getters
    public ChangeType getChangeType() { return changeType; }
    public Triple getOldTriple() { return oldTriple; }
    public Triple getNewTriple() { return newTriple; }
    public Triple getTriple() { 
        return newTriple != null ? newTriple : oldTriple; 
    }
}

class ChangeLog {
    private List<ChangeRecord> records;
    private ReadWriteLock lock;
    
    public ChangeLog() {
        this.records = new ArrayList<>();
        this.lock = new ReentrantReadWriteLock();
    }
    
    public void logChange(ChangeType type, Triple triple) {
        logChange(type, triple, null);
    }
    
    public void logChange(ChangeType type, Triple oldTriple, Triple newTriple) {
        lock.writeLock().lock();
        try {
            records.add(new ChangeRecord(type, oldTriple, newTriple, System.currentTimeMillis()));
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public List<ChangeRecord> getRecords() {
        lock.readLock().lock();
        try {
            return new ArrayList<>(records);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public List<ChangeRecord> getRecordsSince(long timestamp) {
        lock.readLock().lock();
        try {
            return records.stream()
                .filter(record -> record.getTimestamp() >= timestamp)
                .collect(Collectors.toList());
        } finally {
            lock.readLock().unlock();
        }
    }
}

class ChangeRecord {
    private ChangeType type;
    private Triple oldTriple;
    private Triple newTriple;
    private long timestamp;
    
    public ChangeRecord(ChangeType type, Triple oldTriple, Triple newTriple, long timestamp) {
        this.type = type;
        this.oldTriple = oldTriple;
        this.newTriple = newTriple;
        this.timestamp = timestamp;
    }
    
    // Getters
    public ChangeType getType() { return type; }
    public Triple getOldTriple() { return oldTriple; }
    public Triple getNewTriple() { return newTriple; }
    public long getTimestamp() { return timestamp; }
}

interface ConflictResolver {
    ConflictResolution resolve(Triple newTriple, Triple existingTriple);
}

class SimpleConflictResolver implements ConflictResolver {
    @Override
    public ConflictResolution resolve(Triple newTriple, Triple existingTriple) {
        // 简单的冲突解决策略：总是替换
        return new ConflictResolution(ConflictAction.REPLACE);
    }
}

class ConflictResolution {
    private ConflictAction action;
    private String reason;
    
    public ConflictResolution(ConflictAction action) {
        this(action, "");
    }
    
    public ConflictResolution(ConflictAction action, String reason) {
        this.action = action;
        this.reason = reason;
    }
    
    // Getters
    public ConflictAction getAction() { return action; }
    public String getReason() { return reason; }
}
```

### 2. 版本控制和回滚

```java
public class VersionedKnowledgeGraph {
    private RDFKnowledgeGraph currentGraph;
    private Map<Integer, GraphSnapshot> snapshots;
    private int currentVersion;
    private ReadWriteLock lock;
    
    public VersionedKnowledgeGraph() {
        this.currentGraph = new RDFKnowledgeGraph();
        this.snapshots = new HashMap<>();
        this.currentVersion = 0;
        this.lock = new ReentrantReadWriteLock();
        
        // 创建初始版本
        createSnapshot();
    }
    
    public void addTriple(String subject, String predicate, String object) {
        lock.writeLock().lock();
        try {
            currentGraph.addTriple(subject, predicate, object);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void removeTriple(String subject, String predicate, String object) {
        lock.writeLock().lock();
        try {
            currentGraph.removeTriple(subject, predicate, object);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int createSnapshot() {
        lock.writeLock().lock();
        try {
            currentVersion++;
            GraphSnapshot snapshot = new GraphSnapshot(
                currentVersion, 
                new HashSet<>(currentGraph.getAllTriples()),
                System.currentTimeMillis()
            );
            snapshots.put(currentVersion, snapshot);
            return currentVersion;
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public boolean rollbackToVersion(int version) {
        lock.writeLock().lock();
        try {
            GraphSnapshot snapshot = snapshots.get(version);
            if (snapshot == null) {
                return false;
            }
            
            // 清空当前图
            // 这里简化处理，实际应用中应更高效地计算差异
            Set<Triple> currentTriples = currentGraph.getAllTriples();
            for (Triple triple : currentTriples) {
                currentGraph.removeTriple(
                    triple.getSubject(), 
                    triple.getPredicate(), 
                    triple.getObject()
                );
            }
            
            // 恢复快照中的三元组
            for (Triple triple : snapshot.getTriples()) {
                currentGraph.addTriple(
                    triple.getSubject(), 
                    triple.getPredicate(), 
                    triple.getObject()
                );
            }
            
            currentVersion = version;
            return true;
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public List<Integer> getVersionHistory() {
        lock.readLock().lock();
        try {
            return new ArrayList<>(snapshots.keySet()).stream()
                .sorted()
                .collect(Collectors.toList());
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public GraphSnapshot getVersionSnapshot(int version) {
        lock.readLock().lock();
        try {
            return snapshots.get(version);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public int getCurrentVersion() {
        lock.readLock().lock();
        try {
            return currentVersion;
        } finally {
            lock.readLock().unlock();
        }
    }
}

class GraphSnapshot {
    private int version;
    private Set<Triple> triples;
    private long timestamp;
    
    public GraphSnapshot(int version, Set<Triple> triples, long timestamp) {
        this.version = version;
        this.triples = triples;
        this.timestamp = timestamp;
    }
    
    // Getters
    public int getVersion() { return version; }
    public Set<Triple> getTriples() { return triples; }
    public long getTimestamp() { return timestamp; }
}
```

## 实际应用示例

### 知识图谱构建系统

```java
public class KnowledgeGraphBuilder {
    private RDFKnowledgeGraph knowledgeGraph;
    private RuleBasedEntityRecognizer entityRecognizer;
    private DeepLearningRelationExtractor relationExtractor;
    private KnowledgeGraphUpdater updater;
    
    public KnowledgeGraphBuilder() {
        this.knowledgeGraph = new RDFKnowledgeGraph();
        this.entityRecognizer = new RuleBasedEntityRecognizer();
        this.relationExtractor = new DeepLearningRelationExtractor(
            new MockRelationClassificationModel()
        );
        this.updater = new KnowledgeGraphUpdater(knowledgeGraph);
    }
    
    public void buildFromText(String text) {
        // 1. 实体识别
        List<RecognizedEntity> entities = entityRecognizer.recognizeEntities(text);
        
        // 2. 关系抽取
        List<ExtractedRelation> relations = relationExtractor.extractRelations(text);
        
        // 3. 构建知识图谱
        for (ExtractedRelation relation : relations) {
            // 将实体添加到知识图谱
            addEntityToGraph(relation.getSubject());
            addEntityToGraph(relation.getObject());
            
            // 添加关系
            updater.addTriple(
                relation.getSubject().getText(),
                relation.getRelation(),
                relation.getObject().getText()
            );
        }
    }
    
    private void addEntityToGraph(RecognizedEntity entity) {
        // 为实体添加类型信息
        updater.addTriple(
            entity.getText(),
            "rdf:type",
            entity.getType().toString().toLowerCase()
        );
    }
    
    public void buildFromDocuments(List<String> documents) {
        for (String document : documents) {
            buildFromText(document);
        }
        
        // 创建快照
        VersionedKnowledgeGraph versionedGraph = new VersionedKnowledgeGraph();
        // 这里简化处理，实际应将knowledgeGraph的内容复制到versionedGraph
    }
    
    public RDFKnowledgeGraph getKnowledgeGraph() {
        return knowledgeGraph;
    }
    
    public QueryResult query(String sparqlQuery) {
        SPARQLQueryExecutor executor = new SPARQLQueryExecutor(knowledgeGraph);
        return executor.executeQuery(sparqlQuery);
    }
    
    public int createVersionSnapshot() {
        VersionedKnowledgeGraph versionedGraph = new VersionedKnowledgeGraph();
        // 简化处理，实际应实现版本控制
        return 1;
    }
}

// 使用示例
class KnowledgeGraphBuilderExample {
    public static void main(String[] args) {
        KnowledgeGraphBuilder builder = new KnowledgeGraphBuilder();
        
        // 构建知识图谱
        String text = "Steve Jobs founded Apple Inc. in 1976 in California.";
        builder.buildFromText(text);
        
        // 查询知识图谱
        String sparqlQuery = "SELECT ?company WHERE { ?person founded ?company }";
        QueryResult result = builder.query(sparqlQuery);
        
        System.out.println("Query results:");
        for (Triple triple : result.getTriples()) {
            System.out.println(triple);
        }
        
        // 创建版本快照
        int version = builder.createVersionSnapshot();
        System.out.println("Created snapshot version: " + version);
    }
}
```

## 本节小结

本节我们深入探讨了知识图谱构建与维护的核心技术，包括：

1. **知识图谱基本概念**：
   - 理解了知识图谱的定义、结构和表示方法
   - 掌握了三元组（Subject, Predicate, Object）的基本形式

2. **实体识别技术**：
   - 基于规则的实体识别方法
   - 基于机器学习的实体识别技术

3. **关系抽取技术**：
   - 基于依存句法的关系抽取
   - 基于深度学习的关系抽取方法

4. **知识图谱存储实现**：
   - 图数据库存储方式
   - RDF三元组存储方式

5. **知识图谱查询语言**：
   - SPARQL查询语言的基本使用
   - 查询执行器的实现

6. **知识图谱维护策略**：
   - 增量更新机制
   - 版本控制和回滚功能

7. **实际应用示例**：
   - 完整的知识图谱构建系统实现

通过本节的学习，我们掌握了构建和维护知识图谱的核心技术，为实现结构化的知识管理和应用奠定了坚实基础。在下一节中，我们将学习多模态检索技术，进一步扩展知识图谱的应用范围。