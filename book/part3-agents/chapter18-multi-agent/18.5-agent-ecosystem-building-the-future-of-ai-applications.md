# 18.5 智能体生态：构建AI应用的未来

随着人工智能技术的快速发展，单一功能的智能体已经无法满足复杂应用场景的需求。构建一个完整的智能体生态系统，让多个专门化的智能体协同工作，成为构建下一代AI应用的关键方向。本节将深入探讨智能体生态系统的设计理念、架构模式和实现方法。

## 18.5.1 智能体生态系统概述

智能体生态系统是一个由多个相互协作的智能体组成的复杂系统，每个智能体都有其专门的职责和能力。这些智能体通过标准化的通信协议和接口进行交互，共同完成复杂的任务。一个良好的智能体生态系统应该具备以下特征：

1. **模块化设计**：每个智能体都是独立的模块，可以单独开发、测试和部署
2. **松耦合**：智能体之间通过标准接口通信，降低相互依赖
3. **可扩展性**：可以方便地添加新的智能体或替换现有智能体
4. **容错性**：单个智能体的故障不会影响整个系统的运行
5. **自适应性**：系统能够根据任务需求动态调整智能体配置

### 生态系统架构设计

```java
/**
 * 智能体生态系统核心管理类
 * 负责管理整个智能体生态系统
 */
public class AgentEcosystem {
    private final String ecosystemId;
    private final String name;
    private final Map<String, Agent> agents;
    private final MessageBus messageBus;
    private final AgentRegistry agentRegistry;
    private final ResourceManager resourceManager;
    private final TaskScheduler taskScheduler;
    private final MonitoringService monitoringService;
    
    public AgentEcosystem(String ecosystemId, String name) {
        this.ecosystemId = ecosystemId;
        this.name = name;
        this.agents = new ConcurrentHashMap<>();
        this.messageBus = new MessageBus();
        this.agentRegistry = new AgentRegistry();
        this.resourceManager = new ResourceManager();
        this.taskScheduler = new TaskScheduler();
        this.monitoringService = new MonitoringService();
        
        // 初始化系统组件
        initializeSystem();
    }
    
    /**
     * 初始化生态系统
     */
    private void initializeSystem() {
        // 注册系统服务
        messageBus.registerService("message_bus", messageBus);
        agentRegistry.registerService("agent_registry", agentRegistry);
        resourceManager.registerService("resource_manager", resourceManager);
        taskScheduler.registerService("task_scheduler", taskScheduler);
        monitoringService.registerService("monitoring_service", monitoringService);
        
        // 启动核心服务
        messageBus.start();
        taskScheduler.start();
        monitoringService.start();
    }
    
    /**
     * 注册智能体到生态系统
     */
    public void registerAgent(Agent agent) {
        if (agent == null) {
            throw new IllegalArgumentException("Agent cannot be null");
        }
        
        // 检查智能体ID是否已存在
        if (agents.containsKey(agent.getAgentId())) {
            throw new IllegalStateException("Agent with ID " + agent.getAgentId() + " already exists");
        }
        
        // 注册智能体
        agents.put(agent.getAgentId(), agent);
        agentRegistry.registerAgent(agent);
        messageBus.registerAgent(agent);
        
        // 通知监控服务
        monitoringService.agentRegistered(agent);
        
        logger.info("Agent registered: " + agent.getAgentId() + " (" + agent.getName() + ")");
    }
    
    /**
     * 注销智能体
     */
    public void unregisterAgent(String agentId) {
        Agent agent = agents.remove(agentId);
        if (agent != null) {
            agentRegistry.unregisterAgent(agentId);
            messageBus.unregisterAgent(agentId);
            monitoringService.agentUnregistered(agent);
            logger.info("Agent unregistered: " + agentId);
        }
    }
    
    /**
     * 启动生态系统
     */
    public void start() {
        // 启动所有已注册的智能体
        for (Agent agent : agents.values()) {
            try {
                agent.start();
                logger.info("Agent started: " + agent.getAgentId());
            } catch (Exception e) {
                logger.severe("Failed to start agent " + agent.getAgentId() + ": " + e.getMessage());
            }
        }
        
        logger.info("Agent ecosystem started: " + name);
    }
    
    /**
     * 停止生态系统
     */
    public void stop() {
        // 停止所有智能体
        for (Agent agent : agents.values()) {
            try {
                agent.stop();
                logger.info("Agent stopped: " + agent.getAgentId());
            } catch (Exception e) {
                logger.severe("Failed to stop agent " + agent.getAgentId() + ": " + e.getMessage());
            }
        }
        
        // 停止核心服务
        messageBus.stop();
        taskScheduler.stop();
        monitoringService.stop();
        
        logger.info("Agent ecosystem stopped: " + name);
    }
    
    /**
     * 处理外部请求
     */
    public EcosystemResponse processRequest(EcosystemRequest request) {
        try {
            // 记录请求
            monitoringService.recordRequest(request);
            
            // 根据请求类型分发处理
            switch (request.getRequestType()) {
                case CREATE_TASK:
                    return handleCreateTaskRequest(request);
                case EXECUTE_WORKFLOW:
                    return handleExecuteWorkflowRequest(request);
                case QUERY_AGENT_STATUS:
                    return handleQueryAgentStatusRequest(request);
                case MANAGE_RESOURCES:
                    return handleManageResourcesRequest(request);
                case MONITOR_SYSTEM:
                    return handleMonitorSystemRequest(request);
                default:
                    EcosystemResponse response = new EcosystemResponse();
                    response.setError(true);
                    response.setErrorMessage("Unknown request type: " + request.getRequestType());
                    return response;
            }
        } catch (Exception e) {
            logger.severe("Error processing ecosystem request: " + e.getMessage());
            EcosystemResponse response = new EcosystemResponse();
            response.setError(true);
            response.setErrorMessage(e.getMessage());
            return response;
        }
    }
    
    // 请求处理方法
    private EcosystemResponse handleCreateTaskRequest(EcosystemRequest request) {
        EcosystemResponse response = new EcosystemResponse();
        try {
            TaskCreationRequest taskRequest = (TaskCreationRequest) request.getContent();
            
            // 创建任务
            Task task = taskScheduler.createTask(
                taskRequest.getTaskType(),
                taskRequest.getParameters(),
                taskRequest.getPriority()
            );
            
            // 分配资源
            ResourceAllocation allocation = resourceManager.allocateResources(task);
            
            // 调度任务
            taskScheduler.scheduleTask(task, allocation);
            
            response.setTaskId(task.getTaskId());
            response.setSuccess(true);
            response.setMessage("Task created successfully: " + task.getTaskId());
        } catch (Exception e) {
            logger.severe("Error creating task: " + e.getMessage());
            response.setError(true);
            response.setErrorMessage(e.getMessage());
        }
        return response;
    }
    
    private EcosystemResponse handleExecuteWorkflowRequest(EcosystemRequest request) {
        EcosystemResponse response = new EcosystemResponse();
        try {
            WorkflowExecutionRequest workflowRequest = (WorkflowExecutionRequest) request.getContent();
            
            // 执行工作流
            WorkflowResult result = taskScheduler.executeWorkflow(
                workflowRequest.getWorkflowDefinition(),
                workflowRequest.getInputData()
            );
            
            response.setWorkflowResult(result);
            response.setSuccess(true);
        } catch (Exception e) {
            logger.severe("Error executing workflow: " + e.getMessage());
            response.setError(true);
            response.setErrorMessage(e.getMessage());
        }
        return response;
    }
    
    private EcosystemResponse handleQueryAgentStatusRequest(EcosystemRequest request) {
        EcosystemResponse response = new EcosystemResponse();
        try {
            AgentStatusQuery query = (AgentStatusQuery) request.getContent();
            
            // 查询智能体状态
            List<AgentStatus> agentStatuses = new ArrayList<>();
            if (query.getAgentIds() != null && !query.getAgentIds().isEmpty()) {
                // 查询指定智能体
                for (String agentId : query.getAgentIds()) {
                    Agent agent = agents.get(agentId);
                    if (agent != null) {
                        agentStatuses.add(agent.getStatus());
                    }
                }
            } else {
                // 查询所有智能体
                for (Agent agent : agents.values()) {
                    agentStatuses.add(agent.getStatus());
                }
            }
            
            response.setAgentStatuses(agentStatuses);
            response.setSuccess(true);
        } catch (Exception e) {
            logger.severe("Error querying agent status: " + e.getMessage());
            response.setError(true);
            response.setErrorMessage(e.getMessage());
        }
        return response;
    }
    
    private EcosystemResponse handleManageResourcesRequest(EcosystemRequest request) {
        EcosystemResponse response = new EcosystemResponse();
        try {
            ResourceManagerRequest resourceRequest = (ResourceManagerRequest) request.getContent();
            
            switch (resourceRequest.getOperation()) {
                case ALLOCATE:
                    ResourceAllocation allocation = resourceManager.allocateResources(
                        resourceRequest.getResourceRequirements());
                    response.setResourceAllocation(allocation);
                    break;
                case RELEASE:
                    resourceManager.releaseResources(resourceRequest.getAllocationId());
                    break;
                case QUERY:
                    List<AvailableResource> availableResources = resourceManager.getAvailableResources();
                    response.setAvailableResources(availableResources);
                    break;
            }
            
            response.setSuccess(true);
        } catch (Exception e) {
            logger.severe("Error managing resources: " + e.getMessage());
            response.setError(true);
            response.setErrorMessage(e.getMessage());
        }
        return response;
    }
    
    private EcosystemResponse handleMonitorSystemRequest(EcosystemRequest request) {
        EcosystemResponse response = new EcosystemResponse();
        try {
            SystemMonitoringRequest monitorRequest = (SystemMonitoringRequest) request.getContent();
            
            switch (monitorRequest.getMetricType()) {
                case PERFORMANCE:
                    SystemPerformanceMetrics performanceMetrics = monitoringService.getPerformanceMetrics();
                    response.setPerformanceMetrics(performanceMetrics);
                    break;
                case RESOURCE_USAGE:
                    ResourceUsageMetrics resourceMetrics = monitoringService.getResourceUsageMetrics();
                    response.setResourceUsageMetrics(resourceMetrics);
                    break;
                case ERROR_RATE:
                    ErrorRateMetrics errorMetrics = monitoringService.getErrorRateMetrics();
                    response.setErrorRateMetrics(errorMetrics);
                    break;
            }
            
            response.setSuccess(true);
        } catch (Exception e) {
            logger.severe("Error monitoring system: " + e.getMessage());
            response.setError(true);
            response.setErrorMessage(e.getMessage());
        }
        return response;
    }
    
    // Getter方法
    public String getEcosystemId() {
        return ecosystemId;
    }
    
    public String getName() {
        return name;
    }
    
    public Collection<Agent> getAgents() {
        return agents.values();
    }
    
    public MessageBus getMessageBus() {
        return messageBus;
    }
    
    public AgentRegistry getAgentRegistry() {
        return agentRegistry;
    }
    
    public ResourceManager getResourceManager() {
        return resourceManager;
    }
    
    public TaskScheduler getTaskScheduler() {
        return taskScheduler;
    }
    
    public MonitoringService getMonitoringService() {
        return monitoringService;
    }
}
```

## 18.5.2 消息总线系统实现

消息总线是智能体生态系统的核心通信基础设施，负责在不同智能体之间传递消息。

```java
/**
 * 消息总线系统
 * 负责智能体之间的消息传递
 */
public class MessageBus {
    private final String busId;
    private final Map<String, Agent> registeredAgents;
    private final Map<String, List<MessageListener>> topicListeners;
    private final BlockingQueue<Message> messageQueue;
    private final ExecutorService messageExecutor;
    private final AtomicBoolean isRunning;
    private final Logger logger = Logger.getLogger(MessageBus.class.getName());
    
    public MessageBus() {
        this.busId = "message_bus_" + UUID.randomUUID().toString();
        this.registeredAgents = new ConcurrentHashMap<>();
        this.topicListeners = new ConcurrentHashMap<>();
        this.messageQueue = new LinkedBlockingQueue<>();
        this.messageExecutor = Executors.newFixedThreadPool(10);
        this.isRunning = new AtomicBoolean(false);
    }
    
    /**
     * 启动消息总线
     */
    public void start() {
        if (isRunning.compareAndSet(false, true)) {
            // 启动消息处理线程
            messageExecutor.submit(this::processMessages);
            logger.info("Message bus started: " + busId);
        }
    }
    
    /**
     * 停止消息总线
     */
    public void stop() {
        if (isRunning.compareAndSet(true, false)) {
            messageExecutor.shutdown();
            try {
                if (!messageExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    messageExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                messageExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
            logger.info("Message bus stopped: " + busId);
        }
    }
    
    /**
     * 注册智能体
     */
    public void registerAgent(Agent agent) {
        registeredAgents.put(agent.getAgentId(), agent);
        logger.info("Agent registered with message bus: " + agent.getAgentId());
    }
    
    /**
     * 注销智能体
     */
    public void unregisterAgent(String agentId) {
        registeredAgents.remove(agentId);
        logger.info("Agent unregistered from message bus: " + agentId);
    }
    
    /**
     * 发送消息
     */
    public void sendMessage(Message message) {
        if (!isRunning.get()) {
            throw new IllegalStateException("Message bus is not running");
        }
        
        try {
            messageQueue.put(message);
            logger.fine("Message queued: " + message.getMessageId());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Failed to queue message", e);
        }
    }
    
    /**
     * 发布消息到主题
     */
    public void publishMessage(String topic, Message message) {
        if (!isRunning.get()) {
            throw new IllegalStateException("Message bus is not running");
        }
        
        message.setTopic(topic);
        sendMessage(message);
    }
    
    /**
     * 订阅主题
     */
    public void subscribe(String topic, MessageListener listener) {
        topicListeners.computeIfAbsent(topic, k -> new ArrayList<>()).add(listener);
        logger.fine("Listener subscribed to topic: " + topic);
    }
    
    /**
     * 取消订阅主题
     */
    public void unsubscribe(String topic, MessageListener listener) {
        List<MessageListener> listeners = topicListeners.get(topic);
        if (listeners != null) {
            listeners.remove(listener);
            logger.fine("Listener unsubscribed from topic: " + topic);
        }
    }
    
    /**
     * 处理消息队列
     */
    private void processMessages() {
        while (isRunning.get()) {
            try {
                Message message = messageQueue.take();
                messageExecutor.submit(() -> deliverMessage(message));
            } catch (InterruptedException e) {
                if (isRunning.get()) {
                    logger.warning("Message processing interrupted");
                }
                break;
            } catch (Exception e) {
                logger.severe("Error processing message: " + e.getMessage());
            }
        }
    }
    
    /**
     * 投递消息
     */
    private void deliverMessage(Message message) {
        try {
            String topic = message.getTopic();
            String targetAgentId = message.getTargetAgentId();
            
            // 如果指定了目标智能体，直接发送给该智能体
            if (targetAgentId != null && !targetAgentId.isEmpty()) {
                Agent targetAgent = registeredAgents.get(targetAgentId);
                if (targetAgent != null) {
                    targetAgent.receiveMessage(message);
                    logger.fine("Message delivered to agent: " + targetAgentId);
                    return;
                } else {
                    logger.warning("Target agent not found: " + targetAgentId);
                }
            }
            
            // 如果指定了主题，发送给订阅该主题的所有监听器
            if (topic != null && !topic.isEmpty()) {
                List<MessageListener> listeners = topicListeners.get(topic);
                if (listeners != null) {
                    for (MessageListener listener : listeners) {
                        try {
                            listener.onMessage(message);
                        } catch (Exception e) {
                            logger.severe("Error delivering message to listener: " + e.getMessage());
                        }
                    }
                    logger.fine("Message delivered to " + listeners.size() + " listeners for topic: " + topic);
                }
            }
            
            // 如果都没有指定，广播给所有智能体
            if (targetAgentId == null && topic == null) {
                for (Agent agent : registeredAgents.values()) {
                    try {
                        agent.receiveMessage(message);
                    } catch (Exception e) {
                        logger.severe("Error delivering message to agent " + agent.getAgentId() + ": " + e.getMessage());
                    }
                }
                logger.fine("Message broadcast to all agents");
            }
        } catch (Exception e) {
            logger.severe("Error delivering message: " + e.getMessage());
        }
    }
    
    /**
     * 获取消息队列大小
     */
    public int getQueueSize() {
        return messageQueue.size();
    }
    
    /**
     * 获取注册的智能体数量
     */
    public int getRegisteredAgentCount() {
        return registeredAgents.size();
    }
    
    /**
     * 获取主题订阅数量
     */
    public int getTopicSubscriptionCount() {
        return topicListeners.size();
    }
}
```

## 18.5.3 智能体注册与发现机制

智能体注册与发现机制负责管理系统中所有智能体的注册信息，并提供发现和查找功能。

```java
/**
 * 智能体注册与发现服务
 */
public class AgentRegistry {
    private final String registryId;
    private final Map<String, AgentInfo> registeredAgents;
    private final Map<String, List<String>> agentTypes;
    private final ReadWriteLock lock;
    private final Logger logger = Logger.getLogger(AgentRegistry.class.getName());
    
    public AgentRegistry() {
        this.registryId = "agent_registry_" + UUID.randomUUID().toString();
        this.registeredAgents = new ConcurrentHashMap<>();
        this.agentTypes = new ConcurrentHashMap<>();
        this.lock = new ReentrantReadWriteLock();
    }
    
    /**
     * 注册智能体
     */
    public void registerAgent(Agent agent) {
        if (agent == null) {
            throw new IllegalArgumentException("Agent cannot be null");
        }
        
        AgentInfo agentInfo = new AgentInfo(agent);
        registeredAgents.put(agent.getAgentId(), agentInfo);
        
        // 按类型分类
        agentTypes.computeIfAbsent(agent.getClass().getSimpleName(), k -> new ArrayList<>())
                  .add(agent.getAgentId());
        
        logger.info("Agent registered: " + agent.getAgentId() + " (" + agent.getName() + ")");
    }
    
    /**
     * 注销智能体
     */
    public void unregisterAgent(String agentId) {
        lock.writeLock().lock();
        try {
            AgentInfo agentInfo = registeredAgents.remove(agentId);
            if (agentInfo != null) {
                // 从类型分类中移除
                List<String> typeAgents = agentTypes.get(agentInfo.getAgent().getClass().getSimpleName());
                if (typeAgents != null) {
                    typeAgents.remove(agentId);
                }
                logger.info("Agent unregistered: " + agentId);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * 查找智能体
     */
    public Agent findAgent(String agentId) {
        AgentInfo agentInfo = registeredAgents.get(agentId);
        return agentInfo != null ? agentInfo.getAgent() : null;
    }
    
    /**
     * 根据类型查找智能体
     */
    public List<Agent> findAgentsByType(String type) {
        List<Agent> agents = new ArrayList<>();
        List<String> agentIds = agentTypes.get(type);
        
        if (agentIds != null) {
            for (String agentId : agentIds) {
                Agent agent = findAgent(agentId);
                if (agent != null) {
                    agents.add(agent);
                }
            }
        }
        
        return agents;
    }
    
    /**
     * 根据能力查找智能体
     */
    public List<Agent> findAgentsByCapability(String capability) {
        List<Agent> agents = new ArrayList<>();
        
        for (AgentInfo agentInfo : registeredAgents.values()) {
            if (agentInfo.hasCapability(capability)) {
                agents.add(agentInfo.getAgent());
            }
        }
        
        return agents;
    }
    
    /**
     * 获取所有注册的智能体
     */
    public List<Agent> getAllAgents() {
        List<Agent> agents = new ArrayList<>();
        for (AgentInfo agentInfo : registeredAgents.values()) {
            agents.add(agentInfo.getAgent());
        }
        return agents;
    }
    
    /**
     * 获取智能体信息
     */
    public AgentInfo getAgentInfo(String agentId) {
        return registeredAgents.get(agentId);
    }
    
    /**
     * 获取注册的智能体数量
     */
    public int getRegisteredAgentCount() {
        return registeredAgents.size();
    }
    
    /**
     * 获取按类型分类的统计信息
     */
    public Map<String, Integer> getAgentTypeStatistics() {
        Map<String, Integer> statistics = new HashMap<>();
        for (Map.Entry<String, List<String>> entry : agentTypes.entrySet()) {
            statistics.put(entry.getKey(), entry.getValue().size());
        }
        return statistics;
    }
    
    /**
     * 智能体信息类
     */
    public static class AgentInfo {
        private final Agent agent;
        private final String agentId;
        private final String name;
        private final String type;
        private final Set<String> capabilities;
        private final long registrationTime;
        private volatile AgentStatus status;
        
        public AgentInfo(Agent agent) {
            this.agent = agent;
            this.agentId = agent.getAgentId();
            this.name = agent.getName();
            this.type = agent.getClass().getSimpleName();
            this.capabilities = extractCapabilities(agent);
            this.registrationTime = System.currentTimeMillis();
            this.status = AgentStatus.READY;
        }
        
        private Set<String> extractCapabilities(Agent agent) {
            Set<String> caps = new HashSet<>();
            
            // 通过反射获取智能体实现的接口
            Class<?> clazz = agent.getClass();
            while (clazz != null) {
                for (Class<?> intf : clazz.getInterfaces()) {
                    caps.add(intf.getSimpleName());
                }
                clazz = clazz.getSuperclass();
            }
            
            // 可以通过注解或其他方式添加额外的能力标识
            if (agent instanceof TextProcessingAgent) {
                caps.add("TextProcessing");
            }
            if (agent instanceof ImageProcessingAgent) {
                caps.add("ImageProcessing");
            }
            if (agent instanceof DataAnalysisAgent) {
                caps.add("DataAnalysis");
            }
            
            return caps;
        }
        
        public boolean hasCapability(String capability) {
            return capabilities.contains(capability);
        }
        
        // Getter方法
        public Agent getAgent() {
            return agent;
        }
        
        public String getAgentId() {
            return agentId;
        }
        
        public String getName() {
            return name;
        }
        
        public String getType() {
            return type;
        }
        
        public Set<String> getCapabilities() {
            return new HashSet<>(capabilities);
        }
        
        public long getRegistrationTime() {
            return registrationTime;
        }
        
        public AgentStatus getStatus() {
            return status;
        }
        
        public void setStatus(AgentStatus status) {
            this.status = status;
        }
    }
}
```

## 18.5.4 资源管理与调度系统

资源管理与调度系统负责管理系统的计算资源，并根据任务需求进行合理分配。

```java
/**
 * 资源管理与调度系统
 */
public class ResourceManager {
    private final String managerId;
    private final ResourcePool resourcePool;
    private final Map<String, ResourceAllocation> activeAllocations;
    private final PriorityQueue<ResourceRequest> pendingRequests;
    private final ScheduledExecutorService scheduler;
    private final Logger logger = Logger.getLogger(ResourceManager.class.getName());
    
    public ResourceManager() {
        this.managerId = "resource_manager_" + UUID.randomUUID().toString();
        this.resourcePool = new ResourcePool();
        this.activeAllocations = new ConcurrentHashMap<>();
        this.pendingRequests = new PriorityQueue<>(Comparator.comparing(ResourceRequest::getPriority).reversed());
        this.scheduler = Executors.newScheduledThreadPool(2);
        
        // 启动资源监控
        scheduler.scheduleAtFixedRate(this::monitorResources, 0, 30, TimeUnit.SECONDS);
    }
    
    /**
     * 初始化资源池
     */
    public void initializeResourcePool(SystemResources systemResources) {
        resourcePool.initialize(systemResources);
        logger.info("Resource pool initialized with " + systemResources.getTotalCpuCores() + " CPU cores and " 
                   + systemResources.getTotalMemory() + " MB memory");
    }
    
    /**
     * 分配资源
     */
    public ResourceAllocation allocateResources(ResourceRequest request) {
        lock.writeLock().lock();
        try {
            // 检查是否有足够的资源
            if (resourcePool.hasSufficientResources(request.getRequiredResources())) {
                // 分配资源
                AllocatedResources allocated = resourcePool.allocate(request.getRequiredResources());
                
                // 创建资源分配记录
                ResourceAllocation allocation = new ResourceAllocation(
                    UUID.randomUUID().toString(),
                    request.getRequesterId(),
                    allocated,
                    System.currentTimeMillis(),
                    request.getTimeout()
                );
                
                // 记录活跃分配
                activeAllocations.put(allocation.getAllocationId(), allocation);
                
                logger.info("Resources allocated: " + allocation.getAllocationId() + 
                           " for requester: " + request.getRequesterId());
                
                return allocation;
            } else {
                // 资源不足，加入等待队列
                pendingRequests.offer(request);
                logger.info("Insufficient resources, request queued: " + request.getRequesterId());
                
                return null; // 表示需要等待
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * 释放资源
     */
    public void releaseResources(String allocationId) {
        lock.writeLock().lock();
        try {
            ResourceAllocation allocation = activeAllocations.remove(allocationId);
            if (allocation != null) {
                // 释放资源
                resourcePool.release(allocation.getAllocatedResources());
                
                logger.info("Resources released: " + allocationId);
                
                // 检查等待队列中是否有可以满足的请求
                processPendingRequests();
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    /**
     * 处理等待队列中的请求
     */
    private void processPendingRequests() {
        List<ResourceRequest> fulfilledRequests = new ArrayList<>();
        
        Iterator<ResourceRequest> iterator = pendingRequests.iterator();
        while (iterator.hasNext()) {
            ResourceRequest request = iterator.next();
            
            if (resourcePool.hasSufficientResources(request.getRequiredResources())) {
                // 可以满足请求
                iterator.remove();
                fulfilledRequests.add(request);
            }
        }
        
        // 处理可满足的请求
        for (ResourceRequest request : fulfilledRequests) {
            scheduler.submit(() -> {
                ResourceAllocation allocation = allocateResources(request);
                if (allocation != null) {
                    // 通知请求者资源已分配
                    notifyResourceAllocated(request, allocation);
                }
            });
        }
    }
    
    /**
     * 通知资源已分配
     */
    private void notifyResourceAllocated(ResourceRequest request, ResourceAllocation allocation) {
        // 这里可以通过消息总线或其他方式通知请求者
        // 实现细节取决于具体的消息传递机制
    }
    
    /**
     * 获取可用资源
     */
    public List<AvailableResource> getAvailableResources() {
        lock.readLock().lock();
        try {
            return resourcePool.getAvailableResources();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * 获取资源使用统计
     */
    public ResourceUsageStatistics getUsageStatistics() {
        lock.readLock().lock();
        try {
            return new ResourceUsageStatistics(
                resourcePool.getTotalResources(),
                resourcePool.getAllocatedResources(),
                resourcePool.getAvailableResources(),
                activeAllocations.size(),
                pendingRequests.size()
            );
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * 监控资源使用情况
     */
    private void monitorResources() {
        try {
            ResourceUsageStatistics stats = getUsageStatistics();
            
            // 检查资源使用率
            double cpuUsage = (double) stats.getAllocatedCpuCores() / stats.getTotalCpuCores();
            double memoryUsage = (double) stats.getAllocatedMemory() / stats.getTotalMemory();
            
            if (cpuUsage > 0.8 || memoryUsage > 0.8) {
                logger.warning("High resource usage - CPU: " + String.format("%.2f", cpuUsage * 100) + 
                              "%, Memory: " + String.format("%.2f", memoryUsage * 100) + "%");
            }
            
            // 清理过期的资源分配
            cleanupExpiredAllocations();
        } catch (Exception e) {
            logger.severe("Error monitoring resources: " + e.getMessage());
        }
    }
    
    /**
     * 清理过期的资源分配
     */
    private void cleanupExpiredAllocations() {
        long currentTime = System.currentTimeMillis();
        List<String> expiredAllocations = new ArrayList<>();
        
        for (ResourceAllocation allocation : activeAllocations.values()) {
            if (currentTime > allocation.getAllocationTime() + allocation.getTimeout()) {
                expiredAllocations.add(allocation.getAllocationId());
            }
        }
        
        for (String allocationId : expiredAllocations) {
            logger.warning("Releasing expired resource allocation: " + allocationId);
            releaseResources(allocationId);
        }
    }
    
    /**
     * 关闭资源管理器
     */
    public void shutdown() {
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        // 释放所有活跃分配
        for (String allocationId : new ArrayList<>(activeAllocations.keySet())) {
            releaseResources(allocationId);
        }
        
        logger.info("Resource manager shutdown completed");
    }
    
    // 内部锁
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
}

/**
 * 资源池管理类
 */
class ResourcePool {
    private SystemResources totalResources;
    private volatile int availableCpuCores;
    private volatile long availableMemory; // in MB
    private final Object lock = new Object();
    
    public void initialize(SystemResources resources) {
        this.totalResources = resources;
        this.availableCpuCores = resources.getTotalCpuCores();
        this.availableMemory = resources.getTotalMemory();
    }
    
    public boolean hasSufficientResources(RequiredResources required) {
        synchronized (lock) {
            return availableCpuCores >= required.getCpuCores() && 
                   availableMemory >= required.getMemory();
        }
    }
    
    public AllocatedResources allocate(RequiredResources required) {
        synchronized (lock) {
            if (!hasSufficientResources(required)) {
                throw new InsufficientResourcesException("Insufficient resources available");
            }
            
            availableCpuCores -= required.getCpuCores();
            availableMemory -= required.getMemory();
            
            return new AllocatedResources(required.getCpuCores(), required.getMemory());
        }
    }
    
    public void release(AllocatedResources allocated) {
        synchronized (lock) {
            availableCpuCores += allocated.getCpuCores();
            availableMemory += allocated.getMemory();
            
            // 确保不超过总资源
            availableCpuCores = Math.min(availableCpuCores, totalResources.getTotalCpuCores());
            availableMemory = Math.min(availableMemory, totalResources.getTotalMemory());
        }
    }
    
    public List<AvailableResource> getAvailableResources() {
        synchronized (lock) {
            List<AvailableResource> resources = new ArrayList<>();
            resources.add(new AvailableResource("CPU_CORES", availableCpuCores));
            resources.add(new AvailableResource("MEMORY_MB", availableMemory));
            return resources;
        }
    }
    
    public SystemResources getTotalResources() {
        return totalResources;
    }
    
    public int getAvailableCpuCores() {
        synchronized (lock) {
            return availableCpuCores;
        }
    }
    
    public long getAvailableMemory() {
        synchronized (lock) {
            return availableMemory;
        }
    }
    
    public int getAllocatedCpuCores() {
        synchronized (lock) {
            return totalResources.getTotalCpuCores() - availableCpuCores;
        }
    }
    
    public long getAllocatedMemory() {
        synchronized (lock) {
            return totalResources.getTotalMemory() - availableMemory;
        }
    }
}

/**
 * 系统资源定义
 */
class SystemResources {
    private final int totalCpuCores;
    private final long totalMemory; // in MB
    private final long totalStorage; // in GB
    
    public SystemResources(int totalCpuCores, long totalMemory, long totalStorage) {
        this.totalCpuCores = totalCpuCores;
        this.totalMemory = totalMemory;
        this.totalStorage = totalStorage;
    }
    
    // Getter方法
    public int getTotalCpuCores() {
        return totalCpuCores;
    }
    
    public long getTotalMemory() {
        return totalMemory;
    }
    
    public long getTotalStorage() {
        return totalStorage;
    }
}

/**
 * 资源请求类
 */
class ResourceRequest {
    private final String requesterId;
    private final RequiredResources requiredResources;
    private final int priority;
    private final long timeout; // in milliseconds
    
    public ResourceRequest(String requesterId, RequiredResources requiredResources, int priority, long timeout) {
        this.requesterId = requesterId;
        this.requiredResources = requiredResources;
        this.priority = priority;
        this.timeout = timeout;
    }
    
    // Getter方法
    public String getRequesterId() {
        return requesterId;
    }
    
    public RequiredResources getRequiredResources() {
        return requiredResources;
    }
    
    public int getPriority() {
        return priority;
    }
    
    public long getTimeout() {
        return timeout;
    }
}

/**
 * 所需资源定义
 */
class RequiredResources {
    private final int cpuCores;
    private final long memory; // in MB
    
    public RequiredResources(int cpuCores, long memory) {
        this.cpuCores = cpuCores;
        this.memory = memory;
    }
    
    // Getter方法
    public int getCpuCores() {
        return cpuCores;
    }
    
    public long getMemory() {
        return memory;
    }
}

/**
 * 已分配资源定义
 */
class AllocatedResources {
    private final int cpuCores;
    private final long memory; // in MB
    
    public AllocatedResources(int cpuCores, long memory) {
        this.cpuCores = cpuCores;
        this.memory = memory;
    }
    
    // Getter方法
    public int getCpuCores() {
        return cpuCores;
    }
    
    public long getMemory() {
        return memory;
    }
}

/**
 * 资源分配记录
 */
class ResourceAllocation {
    private final String allocationId;
    private final String requesterId;
    private final AllocatedResources allocatedResources;
    private final long allocationTime;
    private final long timeout;
    
    public ResourceAllocation(String allocationId, String requesterId, 
                            AllocatedResources allocatedResources, long allocationTime, long timeout) {
        this.allocationId = allocationId;
        this.requesterId = requesterId;
        this.allocatedResources = allocatedResources;
        this.allocationTime = allocationTime;
        this.timeout = timeout;
    }
    
    // Getter方法
    public String getAllocationId() {
        return allocationId;
    }
    
    public String getRequesterId() {
        return requesterId;
    }
    
    public AllocatedResources getAllocatedResources() {
        return allocatedResources;
    }
    
    public long getAllocationTime() {
        return allocationTime;
    }
    
    public long getTimeout() {
        return timeout;
    }
}

/**
 * 可用资源信息
 */
class AvailableResource {
    private final String type;
    private final long amount;
    
    public AvailableResource(String type, long amount) {
        this.type = type;
        this.amount = amount;
    }
    
    // Getter方法
    public String getType() {
        return type;
    }
    
    public long getAmount() {
        return amount;
    }
}

/**
 * 资源使用统计
 */
class ResourceUsageStatistics {
    private final SystemResources totalResources;
    private final int allocatedCpuCores;
    private final long allocatedMemory;
    private final List<AvailableResource> availableResources;
    private final int activeAllocations;
    private final int pendingRequests;
    
    public ResourceUsageStatistics(SystemResources totalResources, 
                                 int allocatedCpuCores, long allocatedMemory,
                                 List<AvailableResource> availableResources,
                                 int activeAllocations, int pendingRequests) {
        this.totalResources = totalResources;
        this.allocatedCpuCores = allocatedCpuCores;
        this.allocatedMemory = allocatedMemory;
        this.availableResources = availableResources;
        this.activeAllocations = activeAllocations;
        this.pendingRequests = pendingRequests;
    }
    
    // Getter方法
    public SystemResources getTotalResources() {
        return totalResources;
    }
    
    public int getTotalCpuCores() {
        return totalResources.getTotalCpuCores();
    }
    
    public long getTotalMemory() {
        return totalResources.getTotalMemory();
    }
    
    public int getAllocatedCpuCores() {
        return allocatedCpuCores;
    }
    
    public long getAllocatedMemory() {
        return allocatedMemory;
    }
    
    public List<AvailableResource> getAvailableResources() {
        return availableResources;
    }
    
    public int getActiveAllocations() {
        return activeAllocations;
    }
    
    public int getPendingRequests() {
        return pendingRequests;
    }
}

/**
 * 资源不足异常
 */
class InsufficientResourcesException extends RuntimeException {
    public InsufficientResourcesException(String message) {
        super(message);
    }
}
```

## 18.5.5 任务调度与工作流引擎

任务调度与工作流引擎负责管理任务的执行和协调多个智能体之间的工作流。

```java
/**
 * 任务调度与工作流引擎
 */
public class TaskScheduler {
    private final String schedulerId;
    private final Map<String, Task> activeTasks;
    private final PriorityQueue<ScheduledTask> taskQueue;
    private final Map<String, WorkflowDefinition> workflowDefinitions;
    private final Map<String, WorkflowInstance> activeWorkflows;
    private final ExecutorService taskExecutor;
    private final ScheduledExecutorService scheduler;
    private final AtomicBoolean isRunning;
    private final Logger logger = Logger.getLogger(TaskScheduler.class.getName());
    
    public TaskScheduler() {
        this.schedulerId = "task_scheduler_" + UUID.randomUUID().toString();
        this.activeTasks = new ConcurrentHashMap<>();
        this.taskQueue = new PriorityQueue<>(Comparator.comparing(ScheduledTask::getScheduledTime));
        this.workflowDefinitions = new ConcurrentHashMap<>();
        this.activeWorkflows = new ConcurrentHashMap<>();
        this.taskExecutor = Executors.newFixedThreadPool(20);
        this.scheduler = Executors.newScheduledThreadPool(2);
        this.isRunning = new AtomicBoolean(false);
    }
    
    /**
     * 启动调度器
     */
    public void start() {
        if (isRunning.compareAndSet(false, true)) {
            // 启动任务调度线程
            scheduler.scheduleAtFixedRate(this::processScheduledTasks, 0, 1, TimeUnit.SECONDS);
            logger.info("Task scheduler started: " + schedulerId);
        }
    }
    
    /**
     * 停止调度器
     */
    public void stop() {
        if (isRunning.compareAndSet(true, false)) {
            scheduler.shutdown();
            taskExecutor.shutdown();
            
            try {
                if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
                if (!taskExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    taskExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                scheduler.shutdownNow();
                taskExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
            
            logger.info("Task scheduler stopped: " + schedulerId);
        }
    }
    
    /**
     * 创建任务
     */
    public Task createTask(TaskType taskType, Map<String, Object> parameters, TaskPriority priority) {
        String taskId = "task_" + UUID.randomUUID().toString();
        Task task = new Task(taskId, taskType, parameters, priority);
        activeTasks.put(taskId, task);
        logger.info("Task created: " + taskId + " (" + taskType + ")");
        return task;
    }
    
    /**
     * 调度任务
     */
    public void scheduleTask(Task task, ResourceAllocation allocation) {
        if (!isRunning.get()) {
            throw new IllegalStateException("Task scheduler is not running");
        }
        
        ScheduledTask scheduledTask = new ScheduledTask(task, allocation, System.currentTimeMillis());
        taskQueue.offer(scheduledTask);
        logger.info("Task scheduled: " + task.getTaskId());
    }
    
    /**
     * 立即执行任务
     */
    public TaskResult executeTask(Task task) {
        try {
            logger.info("Executing task: " + task.getTaskId());
            
            // 根据任务类型执行相应的逻辑
            TaskResult result = executeTaskByType(task);
            
            // 更新任务状态
            task.setStatus(TaskStatus.COMPLETED);
            task.setResult(result);
            
            // 从活跃任务中移除
            activeTasks.remove(task.getTaskId());
            
            logger.info("Task completed: " + task.getTaskId());
            return result;
        } catch (Exception e) {
            logger.severe("Error executing task " + task.getTaskId() + ": " + e.getMessage());
            task.setStatus(TaskStatus.FAILED);
            task.setErrorMessage(e.getMessage());
            activeTasks.remove(task.getTaskId());
            throw new TaskExecutionException("Failed to execute task: " + task.getTaskId(), e);
        }
    }
    
    /**
     * 根据任务类型执行任务
     */
    private TaskResult executeTaskByType(Task task) {
        switch (task.getTaskType()) {
            case TEXT_PROCESSING:
                return executeTextProcessingTask(task);
            case IMAGE_ANALYSIS:
                return executeImageAnalysisTask(task);
            case DATA_ANALYSIS:
                return executeDataAnalysisTask(task);
            case MODEL_TRAINING:
                return executeModelTrainingTask(task);
            case MODEL_INFERENCE:
                return executeModelInferenceTask(task);
            default:
                throw new UnsupportedOperationException("Unsupported task type: " + task.getTaskType());
        }
    }
    
    // 各种任务类型的执行方法
    private TaskResult executeTextProcessingTask(Task task) {
        // 实现文本处理任务逻辑
        TextProcessingTask textTask = new TextProcessingTask(task);
        return textTask.execute();
    }
    
    private TaskResult executeImageAnalysisTask(Task task) {
        // 实现图像分析任务逻辑
        ImageAnalysisTask imageTask = new ImageAnalysisTask(task);
        return imageTask.execute();
    }
    
    private TaskResult executeDataAnalysisTask(Task task) {
        // 实现数据分析任务逻辑
        DataAnalysisTask dataTask = new DataAnalysisTask(task);
        return dataTask.execute();
    }
    
    private TaskResult executeModelTrainingTask(Task task) {
        // 实现模型训练任务逻辑
        ModelTrainingTask trainingTask = new ModelTrainingTask(task);
        return trainingTask.execute();
    }
    
    private TaskResult executeModelInferenceTask(Task task) {
        // 实现模型推理任务逻辑
        ModelInferenceTask inferenceTask = new ModelInferenceTask(task);
        return inferenceTask.execute();
    }
    
    /**
     * 处理调度的任务
     */
    private void processScheduledTasks() {
        long currentTime = System.currentTimeMillis();
        
        // 处理到期的任务
        while (!taskQueue.isEmpty() && taskQueue.peek().getScheduledTime() <= currentTime) {
            ScheduledTask scheduledTask = taskQueue.poll();
            if (scheduledTask != null) {
                taskExecutor.submit(() -> executeTask(scheduledTask.getTask()));
            }
        }
    }
    
    /**
     * 注册工作流定义
     */
    public void registerWorkflowDefinition(WorkflowDefinition workflowDefinition) {
        workflowDefinitions.put(workflowDefinition.getWorkflowId(), workflowDefinition);
        logger.info("Workflow definition registered: " + workflowDefinition.getWorkflowId());
    }
    
    /**
     * 执行工作流
     */
    public WorkflowResult executeWorkflow(WorkflowDefinition workflowDefinition, Map<String, Object> inputData) {
        String workflowInstanceId = "workflow_" + UUID.randomUUID().toString();
        WorkflowInstance workflowInstance = new WorkflowInstance(workflowInstanceId, workflowDefinition, inputData);
        activeWorkflows.put(workflowInstanceId, workflowInstance);
        
        try {
            logger.info("Executing workflow: " + workflowDefinition.getWorkflowId() + 
                       " (instance: " + workflowInstanceId + ")");
            
            WorkflowResult result = workflowInstance.execute();
            
            // 从活跃工作流中移除
            activeWorkflows.remove(workflowInstanceId);
            
            logger.info("Workflow completed: " + workflowDefinition.getWorkflowId());
            return result;
        } catch (Exception e) {
            logger.severe("Error executing workflow " + workflowDefinition.getWorkflowId() + ": " + e.getMessage());
            activeWorkflows.remove(workflowInstanceId);
            throw new WorkflowExecutionException("Failed to execute workflow: " + workflowDefinition.getWorkflowId(), e);
        }
    }
    
    /**
     * 获取任务状态
     */
    public TaskStatus getTaskStatus(String taskId) {
        Task task = activeTasks.get(taskId);
        return task != null ? task.getStatus() : null;
    }
    
    /**
     * 获取工作流状态
     */
    public WorkflowStatus getWorkflowStatus(String workflowInstanceId) {
        WorkflowInstance workflow = activeWorkflows.get(workflowInstanceId);
        return workflow != null ? workflow.getStatus() : null;
    }
    
    /**
     * 取消任务
     */
    public boolean cancelTask(String taskId) {
        Task task = activeTasks.get(taskId);
        if (task != null) {
            task.setStatus(TaskStatus.CANCELLED);
            activeTasks.remove(taskId);
            logger.info("Task cancelled: " + taskId);
            return true;
        }
        return false;
    }
    
    /**
     * 获取调度器统计信息
     */
    public SchedulerStatistics getStatistics() {
        return new SchedulerStatistics(
            activeTasks.size(),
            taskQueue.size(),
            workflowDefinitions.size(),
            activeWorkflows.size(),
            isRunning.get()
        );
    }
}

/**
 * 任务类
 */
class Task {
    private final String taskId;
    private final TaskType taskType;
    private final Map<String, Object> parameters;
    private final TaskPriority priority;
    private volatile TaskStatus status;
    private TaskResult result;
    private String errorMessage;
    private final long createdTime;
    private long startTime;
    private long endTime;
    
    public Task(String taskId, TaskType taskType, Map<String, Object> parameters, TaskPriority priority) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.parameters = parameters != null ? new HashMap<>(parameters) : new HashMap<>();
        this.priority = priority;
        this.status = TaskStatus.PENDING;
        this.createdTime = System.currentTimeMillis();
    }
    
    // Getter和Setter方法
    public String getTaskId() {
        return taskId;
    }
    
    public TaskType getTaskType() {
        return taskType;
    }
    
    public Map<String, Object> getParameters() {
        return new HashMap<>(parameters);
    }
    
    public TaskPriority getPriority() {
        return priority;
    }
    
    public TaskStatus getStatus() {
        return status;
    }
    
    public void setStatus(TaskStatus status) {
        this.status = status;
        if (status == TaskStatus.RUNNING) {
            this.startTime = System.currentTimeMillis();
        } else if (status == TaskStatus.COMPLETED || status == TaskStatus.FAILED || status == TaskStatus.CANCELLED) {
            this.endTime = System.currentTimeMillis();
        }
    }
    
    public TaskResult getResult() {
        return result;
    }
    
    public void setResult(TaskResult result) {
        this.result = result;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    public long getCreatedTime() {
        return createdTime;
    }
    
    public long getStartTime() {
        return startTime;
    }
    
    public long getEndTime() {
        return endTime;
    }
    
    public long getDuration() {
        if (startTime > 0 && endTime > 0) {
            return endTime - startTime;
        }
        return 0;
    }
}

/**
 * 调度任务类
 */
class ScheduledTask {
    private final Task task;
    private final ResourceAllocation allocation;
    private final long scheduledTime;
    
    public ScheduledTask(Task task, ResourceAllocation allocation, long scheduledTime) {
        this.task = task;
        this.allocation = allocation;
        this.scheduledTime = scheduledTime;
    }
    
    // Getter方法
    public Task getTask() {
        return task;
    }
    
    public ResourceAllocation getAllocation() {
        return allocation;
    }
    
    public long getScheduledTime() {
        return scheduledTime;
    }
}

/**
 * 任务类型枚举
 */
enum TaskType {
    TEXT_PROCESSING,
    IMAGE_ANALYSIS,
    DATA_ANALYSIS,
    MODEL_TRAINING,
    MODEL_INFERENCE,
    CUSTOM
}

/**
 * 任务优先级枚举
 */
enum TaskPriority {
    LOW(1),
    NORMAL(2),
    HIGH(3),
    CRITICAL(4);
    
    private final int value;
    
    TaskPriority(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

/**
 * 任务状态枚举
 */
enum TaskStatus {
    PENDING,
    RUNNING,
    COMPLETED,
    FAILED,
    CANCELLED
}

/**
 * 任务结果类
 */
class TaskResult {
    private final String taskId;
    private final boolean success;
    private final Object resultData;
    private final String errorMessage;
    private final long executionTime;
    
    public TaskResult(String taskId, boolean success, Object resultData, String errorMessage, long executionTime) {
        this.taskId = taskId;
        this.success = success;
        this.resultData = resultData;
        this.errorMessage = errorMessage;
        this.executionTime = executionTime;
    }
    
    // Getter方法
    public String getTaskId() {
        return taskId;
    }
    
    public boolean isSuccess() {
        return success;
    }
    
    public Object getResultData() {
        return resultData;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public long getExecutionTime() {
        return executionTime;
    }
}

/**
 * 工作流定义类
 */
class WorkflowDefinition {
    private final String workflowId;
    private final String name;
    private final List<WorkflowStep> steps;
    private final Map<String, Object> metadata;
    
    public WorkflowDefinition(String workflowId, String name, List<WorkflowStep> steps, Map<String, Object> metadata) {
        this.workflowId = workflowId;
        this.name = name;
        this.steps = steps != null ? new ArrayList<>(steps) : new ArrayList<>();
        this.metadata = metadata != null ? new HashMap<>(metadata) : new HashMap<>();
    }
    
    // Getter方法
    public String getWorkflowId() {
        return workflowId;
    }
    
    public String getName() {
        return name;
    }
    
    public List<WorkflowStep> getSteps() {
        return new ArrayList<>(steps);
    }
    
    public Map<String, Object> getMetadata() {
        return new HashMap<>(metadata);
    }
}

/**
 * 工作流步骤类
 */
class WorkflowStep {
    private final String stepId;
    private final String name;
    private final TaskType taskType;
    private final Map<String, Object> parameters;
    private final List<String> dependencies;
    private final boolean isParallel;
    
    public WorkflowStep(String stepId, String name, TaskType taskType, 
                       Map<String, Object> parameters, List<String> dependencies, boolean isParallel) {
        this.stepId = stepId;
        this.name = name;
        this.taskType = taskType;
        this.parameters = parameters != null ? new HashMap<>(parameters) : new HashMap<>();
        this.dependencies = dependencies != null ? new ArrayList<>(dependencies) : new ArrayList<>();
        this.isParallel = isParallel;
    }
    
    // Getter方法
    public String getStepId() {
        return stepId;
    }
    
    public String getName() {
        return name;
    }
    
    public TaskType getTaskType() {
        return taskType;
    }
    
    public Map<String, Object> getParameters() {
        return new HashMap<>(parameters);
    }
    
    public List<String> getDependencies() {
        return new ArrayList<>(dependencies);
    }
    
    public boolean isParallel() {
        return isParallel;
    }
}

/**
 * 工作流实例类
 */
class WorkflowInstance {
    private final String instanceId;
    private final WorkflowDefinition workflowDefinition;
    private final Map<String, Object> inputData;
    private volatile WorkflowStatus status;
    private final Map<String, TaskResult> stepResults;
    private WorkflowResult finalResult;
    private String errorMessage;
    private final long createdTime;
    private long startTime;
    private long endTime;
    
    public WorkflowInstance(String instanceId, WorkflowDefinition workflowDefinition, Map<String, Object> inputData) {
        this.instanceId = instanceId;
        this.workflowDefinition = workflowDefinition;
        this.inputData = inputData != null ? new HashMap<>(inputData) : new HashMap<>();
        this.status = WorkflowStatus.PENDING;
        this.stepResults = new ConcurrentHashMap<>();
        this.createdTime = System.currentTimeMillis();
    }
    
    /**
     * 执行工作流
     */
    public WorkflowResult execute() {
        try {
            setStatus(WorkflowStatus.RUNNING);
            startTime = System.currentTimeMillis();
            
            // 按步骤执行工作流
            executeWorkflowSteps();
            
            // 构建最终结果
            finalResult = new WorkflowResult(instanceId, true, new HashMap<>(stepResults), null, 
                                           System.currentTimeMillis() - startTime);
            setStatus(WorkflowStatus.COMPLETED);
            endTime = System.currentTimeMillis();
            
            return finalResult;
        } catch (Exception e) {
            errorMessage = e.getMessage();
            setStatus(WorkflowStatus.FAILED);
            endTime = System.currentTimeMillis();
            
            return new WorkflowResult(instanceId, false, new HashMap<>(stepResults), errorMessage,
                                   System.currentTimeMillis() - startTime);
        }
    }
    
    /**
     * 执行工作流步骤
     */
    private void executeWorkflowSteps() {
        List<WorkflowStep> steps = workflowDefinition.getSteps();
        
        // 简化实现：按顺序执行步骤
        // 实际实现中需要考虑依赖关系和并行执行
        for (WorkflowStep step : steps) {
            // 合并输入数据和之前步骤的结果
            Map<String, Object> stepParameters = new HashMap<>(inputData);
            stepParameters.putAll(step.getParameters());
            
            // 创建并执行任务
            Task task = new Task("task_" + UUID.randomUUID().toString(), 
                               step.getTaskType(), stepParameters, TaskPriority.NORMAL);
            
            // 这里应该使用TaskScheduler来执行任务
            // 简化实现中直接执行
            TaskResult result = executeTaskDirectly(task);
            stepResults.put(step.getStepId(), result);
            
            // 检查任务执行结果
            if (!result.isSuccess()) {
                throw new WorkflowExecutionException("Step " + step.getStepId() + " failed: " + result.getErrorMessage());
            }
        }
    }
    
    /**
     * 直接执行任务（简化实现）
     */
    private TaskResult executeTaskDirectly(Task task) {
        // 模拟任务执行
        try {
            Thread.sleep(100); // 模拟执行时间
            return new TaskResult(task.getTaskId(), true, "Result for " + task.getTaskId(), null, 100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new TaskResult(task.getTaskId(), false, null, "Interrupted", 0);
        }
    }
    
    // Getter和Setter方法
    public String getInstanceId() {
        return instanceId;
    }
    
    public WorkflowDefinition getWorkflowDefinition() {
        return workflowDefinition;
    }
    
    public Map<String, Object> getInputData() {
        return new HashMap<>(inputData);
    }
    
    public WorkflowStatus getStatus() {
        return status;
    }
    
    public void setStatus(WorkflowStatus status) {
        this.status = status;
    }
    
    public Map<String, TaskResult> getStepResults() {
        return new HashMap<>(stepResults);
    }
    
    public WorkflowResult getFinalResult() {
        return finalResult;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public long getCreatedTime() {
        return createdTime;
    }
    
    public long getStartTime() {
        return startTime;
    }
    
    public long getEndTime() {
        return endTime;
    }
    
    public long getDuration() {
        if (startTime > 0 && endTime > 0) {
            return endTime - startTime;
        }
        return 0;
    }
}

/**
 * 工作流状态枚举
 */
enum WorkflowStatus {
    PENDING,
    RUNNING,
    COMPLETED,
    FAILED,
    CANCELLED
}

/**
 * 工作流结果类
 */
class WorkflowResult {
    private final String workflowInstanceId;
    private final boolean success;
    private final Map<String, TaskResult> stepResults;
    private final String errorMessage;
    private final long executionTime;
    
    public WorkflowResult(String workflowInstanceId, boolean success, 
                         Map<String, TaskResult> stepResults, String errorMessage, long executionTime) {
        this.workflowInstanceId = workflowInstanceId;
        this.success = success;
        this.stepResults = stepResults != null ? new HashMap<>(stepResults) : new HashMap<>();
        this.errorMessage = errorMessage;
        this.executionTime = executionTime;
    }
    
    // Getter方法
    public String getWorkflowInstanceId() {
        return workflowInstanceId;
    }
    
    public boolean isSuccess() {
        return success;
    }
    
    public Map<String, TaskResult> getStepResults() {
        return new HashMap<>(stepResults);
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public long getExecutionTime() {
        return executionTime;
    }
}

/**
 * 调度器统计信息类
 */
class SchedulerStatistics {
    private final int activeTaskCount;
    private final int scheduledTaskCount;
    private final int workflowDefinitionCount;
    private final int activeWorkflowCount;
    private final boolean isRunning;
    
    public SchedulerStatistics(int activeTaskCount, int scheduledTaskCount, 
                             int workflowDefinitionCount, int activeWorkflowCount, boolean isRunning) {
        this.activeTaskCount = activeTaskCount;
        this.scheduledTaskCount = scheduledTaskCount;
        this.workflowDefinitionCount = workflowDefinitionCount;
        this.activeWorkflowCount = activeWorkflowCount;
        this.isRunning = isRunning;
    }
    
    // Getter方法
    public int getActiveTaskCount() {
        return activeTaskCount;
    }
    
    public int getScheduledTaskCount() {
        return scheduledTaskCount;
    }
    
    public int getWorkflowDefinitionCount() {
        return workflowDefinitionCount;
    }
    
    public int getActiveWorkflowCount() {
        return activeWorkflowCount;
    }
    
    public boolean isRunning() {
        return isRunning;
    }
}

/**
 * 任务执行异常类
 */
class TaskExecutionException extends RuntimeException {
    public TaskExecutionException(String message) {
        super(message);
    }
    
    public TaskExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 工作流执行异常类
 */
class WorkflowExecutionException extends RuntimeException {
    public WorkflowExecutionException(String message) {
        super(message);
    }
    
    public WorkflowExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 文本处理任务实现
 */
class TextProcessingTask {
    private final Task task;
    
    public TextProcessingTask(Task task) {
        this.task = task;
    }
    
    public TaskResult execute() {
        try {
            String text = (String) task.getParameters().get("text");
            String operation = (String) task.getParameters().get("operation");
            
            String result = performOperation(text, operation);
            
            return new TaskResult(task.getTaskId(), true, result, null, 
                                System.currentTimeMillis() - task.getCreatedTime());
        } catch (Exception e) {
            return new TaskResult(task.getTaskId(), false, null, e.getMessage(),
                                System.currentTimeMillis() - task.getCreatedTime());
        }
    }
    
    private String performOperation(String text, String operation) {
        switch (operation) {
            case "uppercase":
                return text.toUpperCase();
            case "lowercase":
                return text.toLowerCase();
            case "reverse":
                return new StringBuilder(text).reverse().toString();
            case "word_count":
                return String.valueOf(text.split("\\s+").length);
            default:
                throw new IllegalArgumentException("Unsupported operation: " + operation);
        }
    }
}

/**
 * 图像分析任务实现
 */
class ImageAnalysisTask {
    private final Task task;
    
    public ImageAnalysisTask(Task task) {
        this.task = task;
    }
    
    public TaskResult execute() {
        try {
            // 模拟图像分析
            String imagePath = (String) task.getParameters().get("image_path");
            String analysisType = (String) task.getParameters().get("analysis_type");
            
            // 这里应该实际处理图像，简化实现中返回模拟结果
            Map<String, Object> result = new HashMap<>();
            result.put("image_path", imagePath);
            result.put("analysis_type", analysisType);
            result.put("result", "Analysis completed for " + imagePath);
            result.put("confidence", 0.95);
            
            return new TaskResult(task.getTaskId(), true, result, null,
                                System.currentTimeMillis() - task.getCreatedTime());
        } catch (Exception e) {
            return new TaskResult(task.getTaskId(), false, null, e.getMessage(),
                                System.currentTimeMillis() - task.getCreatedTime());
        }
    }
}

/**
 * 数据分析任务实现
 */
class DataAnalysisTask {
    private final Task task;
    
    public DataAnalysisTask(Task task) {
        this.task = task;
    }
    
    public TaskResult execute() {
        try {
            // 模拟数据分析
            List<Double> data = (List<Double>) task.getParameters().get("data");
            String analysisType = (String) task.getParameters().get("analysis_type");
            
            Object result = performAnalysis(data, analysisType);
            
            return new TaskResult(task.getTaskId(), true, result, null,
                                System.currentTimeMillis() - task.getCreatedTime());
        } catch (Exception e) {
            return new TaskResult(task.getTaskId(), false, null, e.getMessage(),
                                System.currentTimeMillis() - task.getCreatedTime());
        }
    }
    
    private Object performAnalysis(List<Double> data, String analysisType) {
        switch (analysisType) {
            case "mean":
                return data.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
            case "sum":
                return data.stream().mapToDouble(Double::doubleValue).sum();
            case "max":
                return Collections.max(data);
            case "min":
                return Collections.min(data);
            default:
                throw new IllegalArgumentException("Unsupported analysis type: " + analysisType);
        }
    }
}

/**
 * 模型训练任务实现
 */
class ModelTrainingTask {
    private final Task task;
    
    public ModelTrainingTask(Task task) {
        this.task = task;
    }
    
    public TaskResult execute() {
        try {
            // 模拟模型训练
            String modelType = (String) task.getParameters().get("model_type");
            int epochs = (Integer) task.getParameters().getOrDefault("epochs", 10);
            
            // 模拟训练过程
            for (int i = 0; i < epochs; i++) {
                // 模拟训练时间
                Thread.sleep(50);
            }
            
            Map<String, Object> result = new HashMap<>();
            result.put("model_type", modelType);
            result.put("epochs", epochs);
            result.put("training_loss", 0.1);
            result.put("validation_accuracy", 0.95);
            
            return new TaskResult(task.getTaskId(), true, result, null,
                                System.currentTimeMillis() - task.getCreatedTime());
        } catch (Exception e) {
            return new TaskResult(task.getTaskId(), false, null, e.getMessage(),
                                System.currentTimeMillis() - task.getCreatedTime());
        }
    }
}

/**
 * 模型推理任务实现
 */
class ModelInferenceTask {
    private final Task task;
    
    public ModelInferenceTask(Task task) {
        this.task = task;
    }
    
    public TaskResult execute() {
        try {
            // 模拟模型推理
            String modelType = (String) task.getParameters().get("model_type");
            Object inputData = task.getParameters().get("input_data");
            
            // 模拟推理结果
            Map<String, Object> result = new HashMap<>();
            result.put("model_type", modelType);
            result.put("input", inputData);
            result.put("prediction", "Predicted result for " + inputData);
            result.put("confidence", 0.92);
            
            return new TaskResult(task.getTaskId(), true, result, null,
                                System.currentTimeMillis() - task.getCreatedTime());
        } catch (Exception e) {
            return new TaskResult(task.getTaskId(), false, null, e.getMessage(),
                                System.currentTimeMillis() - task.getCreatedTime());
        }
    }
}
```

## 18.5.6 监控与管理系统

监控与管理系统负责收集和分析智能体生态系统的运行数据，提供实时监控和告警功能。

```java
/**
 * 监控与管理系统
 */
public class MonitoringService {
    private final String serviceId;
    private final Map<String, AgentMetrics> agentMetrics;
    private final SystemMetrics systemMetrics;
    private final List<AlertRule> alertRules;
    private final List<Alert> activeAlerts;
    private final ScheduledExecutorService metricsCollector;
    private final ScheduledExecutorService alertChecker;
    private final AtomicBoolean isRunning;
    private final Logger logger = Logger.getLogger(MonitoringService.class.getName());
    
    public MonitoringService() {
        this.serviceId = "monitoring_service_" + UUID.randomUUID().toString();
        this.agentMetrics = new ConcurrentHashMap<>();
        this.systemMetrics = new SystemMetrics();
        this.alertRules = new ArrayList<>();
        this.activeAlerts = new ArrayList<>();
        this.metricsCollector = Executors.newScheduledThreadPool(2);
        this.alertChecker = Executors.newScheduledThreadPool(1);
        this.isRunning = new AtomicBoolean(false);
        
        // 初始化默认告警规则
        initializeDefaultAlertRules();
    }
    
    /**
     * 初始化默认告警规则
     */
    private void initializeDefaultAlertRules() {
        alertRules.add(new AlertRule("high_cpu_usage", "CPU使用率过高", 
                                   AlertSeverity.WARNING, "system.cpu.usage > 80"));
        alertRules.add(new AlertRule("high_memory_usage", "内存使用率过高", 
                                   AlertSeverity.WARNING, "system.memory.usage > 85"));
        alertRules.add(new AlertRule("agent_unresponsive", "智能体无响应", 
                                   AlertSeverity.CRITICAL, "agent.response_time > 5000"));
        alertRules.add(new AlertRule("high_error_rate", "错误率过高", 
                                   AlertSeverity.WARNING, "system.error_rate > 5"));
    }
    
    /**
     * 启动监控服务
     */
    public void start() {
        if (isRunning.compareAndSet(false, true)) {
            // 启动指标收集器
            metricsCollector.scheduleAtFixedRate(this::collectSystemMetrics, 0, 30, TimeUnit.SECONDS);
            
            // 启动告警检查器
            alertChecker.scheduleAtFixedRate(this::checkAlerts, 0, 10, TimeUnit.SECONDS);
            
            logger.info("Monitoring service started: " + serviceId);
        }
    }
    
    /**
     * 停止监控服务
     */
    public void stop() {
        if (isRunning.compareAndSet(true, false)) {
            metricsCollector.shutdown();
            alertChecker.shutdown();
            
            try {
                if (!metricsCollector.awaitTermination(5, TimeUnit.SECONDS)) {
                    metricsCollector.shutdownNow();
                }
                if (!alertChecker.awaitTermination(5, TimeUnit.SECONDS)) {
                    alertChecker.shutdownNow();
                }
            } catch (InterruptedException e) {
                metricsCollector.shutdownNow();
                alertChecker.shutdownNow();
                Thread.currentThread().interrupt();
            }
            
            logger.info("Monitoring service stopped: " + serviceId);
        }
    }
    
    /**
     * 记录智能体注册事件
     */
    public void agentRegistered(Agent agent) {
        agentMetrics.put(agent.getAgentId(), new AgentMetrics(agent.getAgentId()));
        logger.info("Agent registered for monitoring: " + agent.getAgentId());
    }
    
    /**
     * 记录智能体注销事件
     */
    public void agentUnregistered(Agent agent) {
        agentMetrics.remove(agent.getAgentId());
        logger.info("Agent unregistered from monitoring: " + agent.getAgentId());
    }
    
    /**
     * 记录请求
     */
    public void recordRequest(EcosystemRequest request) {
        systemMetrics.incrementRequestCount();
        logger.fine("Request recorded: " + request.getRequestType());
    }
    
    /**
     * 记录智能体响应时间
     */
    public void recordAgentResponseTime(String agentId, long responseTime) {
        AgentMetrics metrics = agentMetrics.get(agentId);
        if (metrics != null) {
            metrics.recordResponseTime(responseTime);
        }
    }
    
    /**
     * 记录错误
     */
    public void recordError(String source, String errorMessage) {
        systemMetrics.incrementErrorCount();
        logger.warning("Error recorded from " + source + ": " + errorMessage);
    }
    
    /**
     * 记录任务执行时间
     */
    public void recordTaskExecutionTime(String taskType, long executionTime) {
        systemMetrics.recordTaskExecutionTime(taskType, executionTime);
    }
    
    /**
     * 收集系统指标
     */
    private void collectSystemMetrics() {
        try {
            // 收集系统级指标
            systemMetrics.collectSystemMetrics();
            
            // 收集JVM指标
            systemMetrics.collectJvmMetrics();
            
            logger.fine("System metrics collected");
        } catch (Exception e) {
            logger.severe("Error collecting system metrics: " + e.getMessage());
        }
    }
    
    /**
     * 检查告警
     */
    private void checkAlerts() {
        try {
            List<Alert> newAlerts = new ArrayList<>();
            
            // 检查系统级告警
            for (AlertRule rule : alertRules) {
                if (evaluateAlertRule(rule)) {
                    Alert alert = new Alert(rule, System.currentTimeMillis());
                    newAlerts.add(alert);
                }
            }
            
            // 处理新告警
            for (Alert alert : newAlerts) {
                handleNewAlert(alert);
            }
            
            // 清理过期告警
            cleanupExpiredAlerts();
            
        } catch (Exception e) {
            logger.severe("Error checking alerts: " + e.getMessage());
        }
    }
    
    /**
     * 评估告警规则
     */
    private boolean evaluateAlertRule(AlertRule rule) {
        try {
            String condition = rule.getCondition();
            
            // 简化的条件评估
            if (condition.contains("system.cpu.usage")) {
                double cpuUsage = systemMetrics.getCpuUsage();
                double threshold = Double.parseDouble(condition.split(">")[1].trim());
                return cpuUsage > threshold;
            } else if (condition.contains("system.memory.usage")) {
                double memoryUsage = systemMetrics.getMemoryUsage();
                double threshold = Double.parseDouble(condition.split(">")[1].trim());
                return memoryUsage > threshold;
            } else if (condition.contains("agent.response_time")) {
                double avgResponseTime = agentMetrics.values().stream()
                    .mapToLong(AgentMetrics::getAverageResponseTime)
                    .average()
                    .orElse(0.0);
                double threshold = Double.parseDouble(condition.split(">")[1].trim());
                return avgResponseTime > threshold;
            } else if (condition.contains("system.error_rate")) {
                double errorRate = systemMetrics.getErrorRate();
                double threshold = Double.parseDouble(condition.split(">")[1].trim());
                return errorRate > threshold;
            }
            
            return false;
        } catch (Exception e) {
            logger.warning("Error evaluating alert rule " + rule.getName() + ": " + e.getMessage());
            return false;
        }
    }
    
    /**
     * 处理新告警
     */
    private void handleNewAlert(Alert alert) {
        // 检查是否已存在相同类型的活跃告警
        boolean duplicate = activeAlerts.stream()
            .anyMatch(a -> a.getRule().getId().equals(alert.getRule().getId()) && 
                          System.currentTimeMillis() - a.getTimestamp() < 300000); // 5分钟内不重复告警
        
        if (!duplicate) {
            activeAlerts.add(alert);
            logger.warning("New alert triggered: " + alert.getRule().getName() + 
                          " (Severity: " + alert.getRule().getSeverity() + ")");
            
            // 可以在这里添加告警通知逻辑（邮件、短信等）
            notifyAlert(alert);
        }
    }
    
    /**
     * 通知告警
     */
    private void notifyAlert(Alert alert) {
        // 简化实现，实际应用中可以发送邮件、短信或调用其他通知服务
        System.out.println("ALERT: " + alert.getRule().getName() + 
                          " - " + alert.getRule().getDescription() +
                          " (Severity: " + alert.getRule().getSeverity() + ")");
    }
    
    /**
     * 清理过期告警
     */
    private void cleanupExpiredAlerts() {
        long currentTime = System.currentTimeMillis();
        activeAlerts.removeIf(alert -> currentTime - alert.getTimestamp() > 3600000); // 1小时后清理
    }
    
    /**
     * 获取性能指标
     */
    public SystemPerformanceMetrics getPerformanceMetrics() {
        return new SystemPerformanceMetrics(
            systemMetrics.getRequestCount(),
            systemMetrics.getErrorCount(),
            systemMetrics.getAverageResponseTime(),
            systemMetrics.getTaskExecutionTimes(),
            agentMetrics.values().stream()
                .collect(Collectors.toMap(AgentMetrics::getAgentId, AgentMetrics::getAverageResponseTime))
        );
    }
    
    /**
     * 获取资源使用指标
     */
    public ResourceUsageMetrics getResourceUsageMetrics() {
        return new ResourceUsageMetrics(
            systemMetrics.getCpuUsage(),
            systemMetrics.getMemoryUsage(),
            systemMetrics.getDiskUsage(),
            systemMetrics.getNetworkUsage()
        );
    }
    
    /**
     * 获取错误率指标
     */
    public ErrorRateMetrics getErrorRateMetrics() {
        return new ErrorRateMetrics(
            systemMetrics.getErrorRate(),
            systemMetrics.getErrorCount(),
            systemMetrics.getRequestCount()
        );
    }
    
    /**
     * 获取活跃告警
     */
    public List<Alert> getActiveAlerts() {
        return new ArrayList<>(activeAlerts);
    }
    
    /**
     * 添加自定义告警规则
     */
    public void addAlertRule(AlertRule rule) {
        alertRules.add(rule);
        logger.info("Alert rule added: " + rule.getName());
    }
    
    /**
     * 移除告警规则
     */
    public void removeAlertRule(String ruleId) {
        alertRules.removeIf(rule -> rule.getId().equals(ruleId));
        logger.info("Alert rule removed: " + ruleId);
    }
    
    /**
     * 获取监控统计信息
     */
    public MonitoringStatistics getStatistics() {
        return new MonitoringStatistics(
            agentMetrics.size(),
            systemMetrics.getRequestCount(),
            systemMetrics.getErrorCount(),
            activeAlerts.size(),
            isRunning.get()
        );
    }
}

/**
 * 智能体指标类
 */
class AgentMetrics {
    private final String agentId;
    private final List<Long> responseTimes;
    private final int maxHistorySize;
    
    public AgentMetrics(String agentId) {
        this.agentId = agentId;
        this.responseTimes = new ArrayList<>();
        this.maxHistorySize = 1000;
    }
    
    /**
     * 记录响应时间
     */
    public void recordResponseTime(long responseTime) {
        synchronized (responseTimes) {
            responseTimes.add(responseTime);
            if (responseTimes.size() > maxHistorySize) {
                responseTimes.remove(0);
            }
        }
    }
    
    /**
     * 获取平均响应时间
     */
    public long getAverageResponseTime() {
        synchronized (responseTimes) {
            if (responseTimes.isEmpty()) {
                return 0;
            }
            return (long) responseTimes.stream().mapToLong(Long::longValue).average().orElse(0.0);
        }
    }
    
    /**
     * 获取最大响应时间
     */
    public long getMaxResponseTime() {
        synchronized (responseTimes) {
            return responseTimes.stream().mapToLong(Long::longValue).max().orElse(0L);
        }
    }
    
    /**
     * 获取最小响应时间
     */
    public long getMinResponseTime() {
        synchronized (responseTimes) {
            return responseTimes.stream().mapToLong(Long::longValue).min().orElse(0L);
        }
    }
    
    // Getter方法
    public String getAgentId() {
        return agentId;
    }
    
    public List<Long> getResponseTimes() {
        synchronized (responseTimes) {
            return new ArrayList<>(responseTimes);
        }
    }
}

/**
 * 系统指标类
 */
class SystemMetrics {
    private volatile long requestCount;
    private volatile long errorCount;
    private volatile double cpuUsage;
    private volatile double memoryUsage;
    private volatile double diskUsage;
    private volatile double networkUsage;
    private final Map<String, List<Long>> taskExecutionTimes;
    private final int maxHistorySize;
    
    public SystemMetrics() {
        this.requestCount = 0;
        this.errorCount = 0;
        this.cpuUsage = 0.0;
        this.memoryUsage = 0.0;
        this.diskUsage = 0.0;
        this.networkUsage = 0.0;
        this.taskExecutionTimes = new ConcurrentHashMap<>();
        this.maxHistorySize = 1000;
    }
    
    /**
     * 增加请求计数
     */
    public void incrementRequestCount() {
        requestCount++;
    }
    
    /**
     * 增加错误计数
     */
    public void incrementErrorCount() {
        errorCount++;
    }
    
    /**
     * 记录任务执行时间
     */
    public void recordTaskExecutionTime(String taskType, long executionTime) {
        taskExecutionTimes.computeIfAbsent(taskType, k -> new ArrayList<>()).add(executionTime);
        
        // 限制历史记录大小
        List<Long> times = taskExecutionTimes.get(taskType);
        synchronized (times) {
            if (times.size() > maxHistorySize) {
                times.remove(0);
            }
        }
    }
    
    /**
     * 收集系统指标
     */
    public void collectSystemMetrics() {
        // 模拟收集系统指标
        cpuUsage = Math.random() * 100;
        memoryUsage = Math.random() * 100;
        diskUsage = Math.random() * 100;
        networkUsage = Math.random() * 1000; // Mbps
    }
    
    /**
     * 收集JVM指标
     */
    public void collectJvmMetrics() {
        // 实际应用中可以使用JMX或其他方式收集JVM指标
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        memoryUsage = (double) usedMemory / totalMemory * 100;
    }
    
    /**
     * 获取错误率
     */
    public double getErrorRate() {
        if (requestCount == 0) {
            return 0.0;
        }
        return (double) errorCount / requestCount * 100;
    }
    
    /**
     * 获取平均任务执行时间
     */
    public Map<String, Double> getAverageTaskExecutionTimes() {
        Map<String, Double> averages = new HashMap<>();
        for (Map.Entry<String, List<Long>> entry : taskExecutionTimes.entrySet()) {
            List<Long> times = entry.getValue();
            synchronized (times) {
                double average = times.stream().mapToLong(Long::longValue).average().orElse(0.0);
                averages.put(entry.getKey(), average);
            }
        }
        return averages;
    }
    
    // Getter方法
    public long getRequestCount() {
        return requestCount;
    }
    
    public long getErrorCount() {
        return errorCount;
    }
    
    public double getCpuUsage() {
        return cpuUsage;
    }
    
    public double getMemoryUsage() {
        return memoryUsage;
    }
    
    public double getDiskUsage() {
        return diskUsage;
    }
    
    public double getNetworkUsage() {
        return networkUsage;
    }
    
    public Map<String, List<Long>> getTaskExecutionTimes() {
        return new HashMap<>(taskExecutionTimes);
    }
}

/**
 * 告警规则类
 */
class AlertRule {
    private final String id;
    private final String name;
    private final String description;
    private final AlertSeverity severity;
    private final String condition;
    
    public AlertRule(String id, String name, String description, AlertSeverity severity, String condition) {
        this.id = id != null ? id : "rule_" + UUID.randomUUID().toString();
        this.name = name;
        this.description = description;
        this.severity = severity;
        this.condition = condition;
    }
    
    public AlertRule(String name, String description, AlertSeverity severity, String condition) {
        this(null, name, description, severity, condition);
    }
    
    // Getter方法
    public String getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public AlertSeverity getSeverity() {
        return severity;
    }
    
    public String getCondition() {
        return condition;
    }
}

/**
 * 告警类
 */
class Alert {
    private final AlertRule rule;
    private final long timestamp;
    private final String details;
    
    public Alert(AlertRule rule, long timestamp) {
        this(rule, timestamp, null);
    }
    
    public Alert(AlertRule rule, long timestamp, String details) {
        this.rule = rule;
        this.timestamp = timestamp;
        this.details = details;
    }
    
    // Getter方法
    public AlertRule getRule() {
        return rule;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
    
    public String getDetails() {
        return details;
    }
    
    public boolean isExpired(long currentTime, long ttl) {
        return currentTime - timestamp > ttl;
    }
}

/**
 * 告警严重程度枚举
 */
enum AlertSeverity {
    INFO,
    WARNING,
    CRITICAL,
    FATAL
}

/**
 * 系统性能指标类
 */
class SystemPerformanceMetrics {
    private final long totalRequests;
    private final long errorCount;
    private final double averageResponseTime;
    private final Map<String, Double> taskExecutionTimes;
    private final Map<String, Long> agentResponseTimes;
    
    public SystemPerformanceMetrics(long totalRequests, long errorCount, double averageResponseTime,
                                  Map<String, Double> taskExecutionTimes, Map<String, Long> agentResponseTimes) {
        this.totalRequests = totalRequests;
        this.errorCount = errorCount;
        this.averageResponseTime = averageResponseTime;
        this.taskExecutionTimes = taskExecutionTimes != null ? new HashMap<>(taskExecutionTimes) : new HashMap<>();
        this.agentResponseTimes = agentResponseTimes != null ? new HashMap<>(agentResponseTimes) : new HashMap<>();
    }
    
    // Getter方法
    public long getTotalRequests() {
        return totalRequests;
    }
    
    public long getErrorCount() {
        return errorCount;
    }
    
    public double getAverageResponseTime() {
        return averageResponseTime;
    }
    
    public Map<String, Double> getTaskExecutionTimes() {
        return new HashMap<>(taskExecutionTimes);
    }
    
    public Map<String, Long> getAgentResponseTimes() {
        return new HashMap<>(agentResponseTimes);
    }
    
    public double getErrorRate() {
        if (totalRequests == 0) {
            return 0.0;
        }
        return (double) errorCount / totalRequests * 100;
    }
}

/**
 * 资源使用指标类
 */
class ResourceUsageMetrics {
    private final double cpuUsage;
    private final double memoryUsage;
    private final double diskUsage;
    private final double networkUsage;
    
    public ResourceUsageMetrics(double cpuUsage, double memoryUsage, double diskUsage, double networkUsage) {
        this.cpuUsage = cpuUsage;
        this.memoryUsage = memoryUsage;
        this.diskUsage = diskUsage;
        this.networkUsage = networkUsage;
    }
    
    // Getter方法
    public double getCpuUsage() {
        return cpuUsage;
    }
    
    public double getMemoryUsage() {
        return memoryUsage;
    }
    
    public double getDiskUsage() {
        return diskUsage;
    }
    
    public double getNetworkUsage() {
        return networkUsage;
    }
}

/**
 * 错误率指标类
 */
class ErrorRateMetrics {
    private final double errorRate;
    private final long errorCount;
    private final long totalRequests;
    
    public ErrorRateMetrics(double errorRate, long errorCount, long totalRequests) {
        this.errorRate = errorRate;
        this.errorCount = errorCount;
        this.totalRequests = totalRequests;
    }
    
    // Getter方法
    public double getErrorRate() {
        return errorRate;
    }
    
    public long getErrorCount() {
        return errorCount;
    }
    
    public long getTotalRequests() {
        return totalRequests;
    }
}

/**
 * 监控统计信息类
 */
class MonitoringStatistics {
    private final int monitoredAgentCount;
    private final long totalRequests;
    private final long errorCount;
    private final int activeAlertCount;
    private final boolean isRunning;
    
    public MonitoringStatistics(int monitoredAgentCount, long totalRequests, 
                              long errorCount, int activeAlertCount, boolean isRunning) {
        this.monitoredAgentCount = monitoredAgentCount;
        this.totalRequests = totalRequests;
        this.errorCount = errorCount;
        this.activeAlertCount = activeAlertCount;
        this.isRunning = isRunning;
    }
    
    // Getter方法
    public int getMonitoredAgentCount() {
        return monitoredAgentCount;
    }
    
    public long getTotalRequests() {
        return totalRequests;
    }
    
    public long getErrorCount() {
        return errorCount;
    }
    
    public int getActiveAlertCount() {
        return activeAlertCount;
    }
    
    public boolean isRunning() {
        return isRunning;
    }
    
    public double getErrorRate() {
        if (totalRequests == 0) {
            return 0.0;
        }
        return (double) errorCount / totalRequests * 100;
    }
}
```

## 18.5.7 智能体生态系统综合应用示例

以下是一个完整的示例，展示如何使用智能体生态系统来构建一个复杂的AI应用：

```java
/**
 * 智能体生态系统综合应用示例
 */
public class AgentEcosystemExample {
    public static void main(String[] args) {
        // 创建智能体生态系统
        AgentEcosystem ecosystem = new AgentEcosystem("ecosystem-001", "AI Research Ecosystem");
        
        try {
            // 初始化系统资源
            initializeSystemResources(ecosystem);
            
            // 注册各种智能体
            registerAgents(ecosystem);
            
            // 启动生态系统
            ecosystem.start();
            
            // 执行示例任务
            executeExampleTasks(ecosystem);
            
            // 监控系统状态
            monitorSystem(ecosystem);
            
        } catch (Exception e) {
            System.err.println("Error in ecosystem example: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // 停止生态系统
            ecosystem.stop();
        }
    }
    
    /**
     * 初始化系统资源
     */
    private static void initializeSystemResources(AgentEcosystem ecosystem) {
        ResourceManager resourceManager = ecosystem.getResourceManager();
        SystemResources systemResources = new SystemResources(8, 16384, 512); // 8核CPU, 16GB内存, 512GB存储
        resourceManager.initializeResourcePool(systemResources);
        System.out.println("System resources initialized");
    }
    
    /**
     * 注册智能体
     */
    private static void registerAgents(AgentEcosystem ecosystem) {
        // 注册研究智能体
        ResearchAgent researchAgent = new ResearchAgent("research-agent-001", "ResearchAgent");
        ecosystem.registerAgent(researchAgent);
        
        // 注册文档处理智能体
        DocumentParsingAgent documentAgent = new DocumentParsingAgent("document-agent-001", "DocumentParsingAgent");
        ecosystem.registerAgent(documentAgent);
        
        // 注册代码生成智能体
        CodeGenerationAgent codeAgent = new CodeGenerationAgent("code-agent-001", "CodeGenerationAgent");
        ecosystem.registerAgent(codeAgent);
        
        // 注册数据分析智能体
        DataAnalysisAgent dataAgent = new DataAnalysisAgent("data-agent-001", "DataAnalysisAgent");
        ecosystem.registerAgent(dataAgent);
        
        System.out.println("Agents registered: " + ecosystem.getAgents().size());
    }
    
    /**
     * 执行示例任务
     */
    private static void executeExampleTasks(AgentEcosystem ecosystem) {
        try {
            // 创建研究任务
            EcosystemRequest researchRequest = new EcosystemRequest();
            researchRequest.setRequestType(EcosystemRequest.RequestType.CREATE_TASK);
            
            TaskCreationRequest taskRequest = new TaskCreationRequest();
            taskRequest.setTaskType(TaskType.TEXT_PROCESSING);
            taskRequest.setParameters(Map.of("text", "Transformer Architecture in Large Language Models", 
                                           "operation", "word_count"));
            taskRequest.setPriority(TaskPriority.HIGH.getPriority());
            
            researchRequest.setContent(taskRequest);
            
            // 执行任务
            EcosystemResponse response = ecosystem.processRequest(researchRequest);
            
            if (response.isSuccess()) {
                System.out.println("Task created successfully: " + response.getTaskId());
            } else {
                System.err.println("Failed to create task: " + response.getErrorMessage());
            }
            
            // 执行工作流
            executeWorkflow(ecosystem);
            
        } catch (Exception e) {
            System.err.println("Error executing tasks: " + e.getMessage());
        }
    }
    
    /**
     * 执行工作流示例
     */
    private static void executeWorkflow(AgentEcosystem ecosystem) {
        try {
            // 定义工作流
            List<WorkflowStep> steps = Arrays.asList(
                new WorkflowStep("step-1", "Text Processing", TaskType.TEXT_PROCESSING,
                               Map.of("text", "Hello World", "operation", "uppercase"), 
                               Collections.emptyList(), false),
                new WorkflowStep("step-2", "Data Analysis", TaskType.DATA_ANALYSIS,
                               Map.of("data", Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0), 
                                    "analysis_type", "mean"),
                               Arrays.asList("step-1"), false)
            );
            
            WorkflowDefinition workflowDefinition = new WorkflowDefinition(
                "workflow-001", "Sample Workflow", steps, Collections.emptyMap());
            
            // 注册工作流定义
            ecosystem.getTaskScheduler().registerWorkflowDefinition(workflowDefinition);
            
            // 执行工作流
            EcosystemRequest workflowRequest = new EcosystemRequest();
            workflowRequest.setRequestType(EcosystemRequest.RequestType.EXECUTE_WORKFLOW);
            
            WorkflowExecutionRequest executionRequest = new WorkflowExecutionRequest();
            executionRequest.setWorkflowDefinition(workflowDefinition);
            executionRequest.setInputData(Collections.emptyMap());
            
            workflowRequest.setContent(executionRequest);
            
            EcosystemResponse response = ecosystem.processRequest(workflowRequest);
            
            if (response.isSuccess()) {
                System.out.println("Workflow executed successfully");
                if (response.getWorkflowResult() != null) {
                    System.out.println("Workflow result: " + response.getWorkflowResult().isSuccess());
                }
            } else {
                System.err.println("Failed to execute workflow: " + response.getErrorMessage());
            }
            
        } catch (Exception e) {
            System.err.println("Error executing workflow: " + e.getMessage());
        }
    }
    
    /**
     * 监控系统状态
     */
    private static void monitorSystem(AgentEcosystem ecosystem) {
        try {
            // 查询智能体状态
            EcosystemRequest statusRequest = new EcosystemRequest();
            statusRequest.setRequestType(EcosystemRequest.RequestType.QUERY_AGENT_STATUS);
            
            AgentStatusQuery statusQuery = new AgentStatusQuery();
            statusQuery.setAgentIds(null); // 查询所有智能体
            
            statusRequest.setContent(statusQuery);
            
            EcosystemResponse statusResponse = ecosystem.processRequest(statusRequest);
            
            if (statusResponse.isSuccess()) {
                System.out.println("Agent statuses:");
                for (AgentStatus status : statusResponse.getAgentStatuses()) {
                    System.out.println("  - " + status.getAgentId() + ": " + status.getStatus());
                }
            }
            
            // 查询资源使用情况
            EcosystemRequest resourceRequest = new EcosystemRequest();
            resourceRequest.setRequestType(EcosystemRequest.RequestType.MANAGE_RESOURCES);
            
            ResourceManagerRequest resourceManagerRequest = new ResourceManagerRequest();
            resourceManagerRequest.setOperation(ResourceManagerRequest.Operation.QUERY);
            
            resourceRequest.setContent(resourceManagerRequest);
            
            EcosystemResponse resourceResponse = ecosystem.processRequest(resourceRequest);
            
            if (resourceResponse.isSuccess()) {
                System.out.println("Available resources:");
                for (AvailableResource resource : resourceResponse.getAvailableResources()) {
                    System.out.println("  - " + resource.getType() + ": " + resource.getAmount());
                }
            }
            
            // 查询监控指标
            EcosystemRequest monitorRequest = new EcosystemRequest();
            monitorRequest.setRequestType(EcosystemRequest.RequestType.MONITOR_SYSTEM);
            
            SystemMonitoringRequest monitoringRequest = new SystemMonitoringRequest();
            monitoringRequest.setMetricType(SystemMonitoringRequest.MetricType.PERFORMANCE);
            
            monitorRequest.setContent(monitoringRequest);
            
            EcosystemResponse monitorResponse = ecosystem.processRequest(monitorRequest);
            
            if (monitorResponse.isSuccess() && monitorResponse.getPerformanceMetrics() != null) {
                SystemPerformanceMetrics metrics = monitorResponse.getPerformanceMetrics();
                System.out.println("Performance metrics:");
                System.out.println("  - Total requests: " + metrics.getTotalRequests());
                System.out.println("  - Error count: " + metrics.getErrorCount());
                System.out.println("  - Error rate: " + String.format("%.2f", metrics.getErrorRate()) + "%");
                System.out.println("  - Average response time: " + metrics.getAverageResponseTime() + "ms");
            }
            
        } catch (Exception e) {
            System.err.println("Error monitoring system: " + e.getMessage());
        }
    }
}

// 以下是一些辅助类的简化实现

/**
 * 生态系统请求类
 */
class EcosystemRequest {
    public enum RequestType {
        CREATE_TASK,
        EXECUTE_WORKFLOW,
        QUERY_AGENT_STATUS,
        MANAGE_RESOURCES,
        MONITOR_SYSTEM
    }
    
    private RequestType requestType;
    private Object content;
    
    // Getter和Setter方法
    public RequestType getRequestType() {
        return requestType;
    }
    
    public void setRequestType(RequestType requestType) {
        this.requestType = requestType;
    }
    
    public Object getContent() {
        return content;
    }
    
    public void setContent(Object content) {
        this.content = content;
    }
}

/**
 * 生态系统响应类
 */
class EcosystemResponse {
    private boolean success;
    private String errorMessage;
    private String message;
    private String taskId;
    private WorkflowResult workflowResult;
    private List<AgentStatus> agentStatuses;
    private ResourceAllocation resourceAllocation;
    private List<AvailableResource> availableResources;
    private SystemPerformanceMetrics performanceMetrics;
    private ResourceUsageMetrics resourceUsageMetrics;
    private ErrorRateMetrics errorRateMetrics;
    
    // Getter和Setter方法
    public boolean isSuccess() {
        return success;
    }
    
    public void setSuccess(boolean success) {
        this.success = success;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public String getTaskId() {
        return taskId;
    }
    
    public void setTaskId(String taskId) {
        this.taskId = taskId;
    }
    
    public WorkflowResult getWorkflowResult() {
        return workflowResult;
    }
    
    public void setWorkflowResult(WorkflowResult workflowResult) {
        this.workflowResult = workflowResult;
    }
    
    public List<AgentStatus> getAgentStatuses() {
        return agentStatuses;
    }
    
    public void setAgentStatuses(List<AgentStatus> agentStatuses) {
        this.agentStatuses = agentStatuses;
    }
    
    public ResourceAllocation getResourceAllocation() {
        return resourceAllocation;
    }
    
    public void setResourceAllocation(ResourceAllocation resourceAllocation) {
        this.resourceAllocation = resourceAllocation;
    }
    
    public List<AvailableResource> getAvailableResources() {
        return availableResources;
    }
    
    public void setAvailableResources(List<AvailableResource> availableResources) {
        this.availableResources = availableResources;
    }
    
    public SystemPerformanceMetrics getPerformanceMetrics() {
        return performanceMetrics;
    }
    
    public void setPerformanceMetrics(SystemPerformanceMetrics performanceMetrics) {
        this.performanceMetrics = performanceMetrics;
    }
    
    public ResourceUsageMetrics getResourceUsageMetrics() {
        return resourceUsageMetrics;
    }
    
    public void setResourceUsageMetrics(ResourceUsageMetrics resourceUsageMetrics) {
        this.resourceUsageMetrics = resourceUsageMetrics;
    }
    
    public ErrorRateMetrics getErrorRateMetrics() {
        return errorRateMetrics;
    }
    
    public void setErrorRateMetrics(ErrorRateMetrics errorRateMetrics) {
        this.errorRateMetrics = errorRateMetrics;
    }
    
    public boolean isError() {
        return errorMessage != null && !errorMessage.isEmpty();
    }
}

/**
 * 任务创建请求类
 */
class TaskCreationRequest {
    private TaskType taskType;
    private Map<String, Object> parameters;
    private int priority;
    
    // Getter和Setter方法
    public TaskType getTaskType() {
        return taskType;
    }
    
    public void setTaskType(TaskType taskType) {
        this.taskType = taskType;
    }
    
    public Map<String, Object> getParameters() {
        return parameters;
    }
    
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    
    public int getPriority() {
        return priority;
    }
    
    public void setPriority(int priority) {
        this.priority = priority;
    }
}

/**
 * 工作流执行请求类
 */
class WorkflowExecutionRequest {
    private WorkflowDefinition workflowDefinition;
    private Map<String, Object> inputData;
    
    // Getter和Setter方法
    public WorkflowDefinition getWorkflowDefinition() {
        return workflowDefinition;
    }
    
    public void setWorkflowDefinition(WorkflowDefinition workflowDefinition) {
        this.workflowDefinition = workflowDefinition;
    }
    
    public Map<String, Object> getInputData() {
        return inputData;
    }
    
    public void setInputData(Map<String, Object> inputData) {
        this.inputData = inputData;
    }
}

/**
 * 智能体状态查询类
 */
class AgentStatusQuery {
    private List<String> agentIds;
    
    // Getter和Setter方法
    public List<String> getAgentIds() {
        return agentIds;
    }
    
    public void setAgentIds(List<String> agentIds) {
        this.agentIds = agentIds;
    }
}

/**
 * 资源管理请求类
 */
class ResourceManagerRequest {
    public enum Operation {
        ALLOCATE,
        RELEASE,
        QUERY
    }
    
    private Operation operation;
    private RequiredResources resourceRequirements;
    private String allocationId;
    
    // Getter和Setter方法
    public Operation getOperation() {
        return operation;
    }
    
    public void setOperation(Operation operation) {
        this.operation = operation;
    }
    
    public RequiredResources getResourceRequirements() {
        return resourceRequirements;
    }
    
    public void setResourceRequirements(RequiredResources resourceRequirements) {
        this.resourceRequirements = resourceRequirements;
    }
    
    public String getAllocationId() {
        return allocationId;
    }
    
    public void setAllocationId(String allocationId) {
        this.allocationId = allocationId;
    }
}

/**
 * 系统监控请求类
 */
class SystemMonitoringRequest {
    public enum MetricType {
        PERFORMANCE,
        RESOURCE_USAGE,
        ERROR_RATE
    }
    
    private MetricType metricType;
    
    // Getter和Setter方法
    public MetricType getMetricType() {
        return metricType;
    }
    
    public void setMetricType(MetricType metricType) {
        this.metricType = metricType;
    }
}

/**
 * 智能体状态类
 */
class AgentStatus {
    private String agentId;
    private String status;
    private long lastHeartbeat;
    
    public AgentStatus(String agentId, String status, long lastHeartbeat) {
        this.agentId = agentId;
        this.status = status;
        this.lastHeartbeat = lastHeartbeat;
    }
    
    // Getter方法
    public String getAgentId() {
        return agentId;
    }
    
    public String getStatus() {
        return status;
    }
    
    public long getLastHeartbeat() {
        return lastHeartbeat;
    }
}
```

## 18.5.8 本节小结

在本节中，我们深入探讨了智能体生态系统的设计与实现，涵盖了以下几个核心组件：

1. **智能体生态系统核心管理**：我们设计了一个完整的生态系统管理类，负责协调各个子系统的运行。

2. **消息总线系统**：实现了智能体之间高效、可靠的消息传递机制，支持点对点和广播通信。

3. **智能体注册与发现机制**：提供了智能体的注册、发现和管理功能，支持按类型和能力查找智能体。

4. **资源管理与调度系统**：实现了系统资源的统一管理和智能分配，确保资源的高效利用。

5. **任务调度与工作流引擎**：提供了任务调度和复杂工作流执行能力，支持并行和依赖关系管理。

6. **监控与管理系统**：实现了全面的系统监控和告警机制，确保系统的稳定运行。

通过这些组件的协同工作，我们构建了一个功能完整、可扩展的智能体生态系统。该系统具备以下优势：

- **模块化设计**：各个组件职责明确，便于维护和扩展
- **高可用性**：通过冗余设计和错误处理机制确保系统稳定运行
- **可扩展性**：支持动态添加新的智能体和服务
- **监控完善**：提供全面的监控和告警功能
- **资源优化**：智能的资源分配和回收机制

在下一节中，我们将通过一个综合项目来展示如何将这些组件整合应用，构建一个完整的智能体协作开发平台。