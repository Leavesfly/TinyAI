# 6.1 Model抽象：训练与推理的统一框架

Model抽象是深度学习框架中最高层的设计抽象，它统一了训练和推理两个阶段的接口，提供了完整的模型生命周期管理。本节将深入探讨Model抽象的设计理念，并提供完整的Java实现方案。

## 6.1.1 Model抽象的设计哲学

Model抽象层需要解决以下核心问题：

1. **统一接口**：为训练和推理提供一致的调用接口
2. **状态管理**：管理模型的训练/评估状态切换
3. **参数管理**：统一管理所有可学习参数
4. **设备抽象**：支持CPU/GPU等不同计算设备
5. **序列化支持**：模型的保存和加载功能

### Model的核心职责

```
Model
├── 网络结构定义 (前向传播逻辑)
├── 参数管理 (权重和偏置)
├── 状态管理 (训练/评估模式)
├── 优化集成 (与优化器协作)
└── 序列化支持 (保存/加载)
```

## 6.1.2 Model基类的核心实现

```java
package com.tinyai.models;

import com.tinyai.core.Variable;
import com.tinyai.layers.Layer;
import com.tinyai.optimizers.Optimizer;
import com.tinyai.utils.DeviceManager;
import java.io.*;
import java.util.*;

/**
 * Model抽象基类
 * 提供训练和推理的统一框架
 */
public abstract class Model implements Serializable {
    private static final long serialVersionUID = 1L;
    
    protected String modelName;
    protected boolean training = true;
    protected String device = "cpu";
    
    // 参数管理
    protected Map<String, Variable> parameters = new LinkedHashMap<>();
    protected Map<String, Variable> buffers = new LinkedHashMap<>();
    
    // 优化器
    protected Optimizer optimizer;
    
    // 模型统计信息
    protected long totalParameters = 0;
    protected long trainableParameters = 0;

    public Model(String modelName) {
        this.modelName = modelName;
    }

    /**
     * 前向传播抽象方法
     * 子类必须实现具体的网络结构
     */
    public abstract Variable forward(Variable input);

    /**
     * 计算输出形状
     */
    public abstract int[] computeOutputShape(int[] inputShape);

    /**
     * 初始化模型参数
     */
    public abstract void initializeParameters(int[] inputShape);

    /**
     * 设置训练模式
     */
    public Model train() {
        this.training = true;
        applyTrainingMode(true);
        return this;
    }

    /**
     * 设置评估模式
     */
    public Model eval() {
        this.training = false;
        applyTrainingMode(false);
        return this;
    }

    /**
     * 应用训练模式到所有子层
     */
    protected abstract void applyTrainingMode(boolean training);

    /**
     * 获取所有参数
     */
    public Map<String, Variable> getParameters() {
        return Collections.unmodifiableMap(parameters);
    }

    /**
     * 获取指定参数
     */
    public Variable getParameter(String name) {
        return parameters.get(name);
    }

    /**
     * 添加参数
     */
    protected void addParameter(String name, Variable parameter) {
        if (parameter == null) {
            throw new IllegalArgumentException("Parameter cannot be null");
        }
        parameters.put(name, parameter);
        updateParameterStatistics();
    }

    /**
     * 获取所有缓冲区
     */
    public Map<String, Variable> getBuffers() {
        return Collections.unmodifiableMap(buffers);
    }

    /**
     * 添加缓冲区
     */
    protected void addBuffer(String name, Variable buffer) {
        if (buffer == null) {
            throw new IllegalArgumentException("Buffer cannot be null");
        }
        buffers.put(name, buffer);
    }

    /**
     * 设置优化器
     */
    public void setOptimizer(Optimizer optimizer) {
        this.optimizer = optimizer;
        if (optimizer != null) {
            optimizer.setParameters(parameters);
        }
    }

    /**
     * 获取优化器
     */
    public Optimizer getOptimizer() {
        return optimizer;
    }

    /**
     * 执行优化步骤
     */
    public void optimizerStep() {
        if (optimizer == null) {
            throw new IllegalStateException("Optimizer not set");
        }
        optimizer.step();
    }

    /**
     * 清零梯度
     */
    public void zeroGrad() {
        for (Variable param : parameters.values()) {
            if (param.requiresGrad()) {
                param.clearGrad();
            }
        }
    }

    /**
     * 移动模型到指定设备
     */
    public Model to(String device) {
        if (!DeviceManager.isDeviceAvailable(device)) {
            throw new IllegalArgumentException("Device not available: " + device);
        }
        
        this.device = device;
        
        // 移动所有参数到指定设备
        for (Variable param : parameters.values()) {
            param.to(device);
        }
        
        for (Variable buffer : buffers.values()) {
            buffer.to(device);
        }
        
        return this;
    }

    /**
     * 获取当前设备
     */
    public String getDevice() {
        return device;
    }

    /**
     * 保存模型
     */
    public void save(String filePath) throws IOException {
        ModelState state = new ModelState();
        state.modelName = this.modelName;
        state.parameters = new HashMap<>();
        state.buffers = new HashMap<>();
        
        // 保存参数
        for (Map.Entry<String, Variable> entry : parameters.entrySet()) {
            state.parameters.put(entry.getKey(), entry.getValue().detach());
        }
        
        // 保存缓冲区
        for (Map.Entry<String, Variable> entry : buffers.entrySet()) {
            state.buffers.put(entry.getKey(), entry.getValue().detach());
        }
        
        // 序列化到文件
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
            oos.writeObject(state);
        }
    }

    /**
     * 加载模型
     */
    public void load(String filePath) throws IOException, ClassNotFoundException {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
            ModelState state = (ModelState) ois.readObject();
            
            // 验证模型名称
            if (!this.modelName.equals(state.modelName)) {
                System.out.println("Warning: Model name mismatch. Expected: " + 
                                 this.modelName + ", Got: " + state.modelName);
            }
            
            // 加载参数
            loadParameters(state.parameters);
            
            // 加载缓冲区
            loadBuffers(state.buffers);
        }
    }

    /**
     * 加载参数状态
     */
    public void loadStateDict(Map<String, Variable> stateDict) {
        loadParameters(stateDict);
    }

    /**
     * 获取状态字典
     */
    public Map<String, Variable> stateDict() {
        Map<String, Variable> stateDict = new HashMap<>();
        
        for (Map.Entry<String, Variable> entry : parameters.entrySet()) {
            stateDict.put(entry.getKey(), entry.getValue().detach());
        }
        
        for (Map.Entry<String, Variable> entry : buffers.entrySet()) {
            stateDict.put(entry.getKey(), entry.getValue().detach());
        }
        
        return stateDict;
    }

    /**
     * 克隆模型
     */
    public abstract Model clone();

    /**
     * 获取模型信息
     */
    public ModelInfo getModelInfo() {
        return new ModelInfo(
            modelName,
            totalParameters,
            trainableParameters,
            device,
            training
        );
    }

    /**
     * 打印模型结构
     */
    public void summary() {
        System.out.println("=".repeat(70));
        System.out.println("Model: " + modelName);
        System.out.println("=".repeat(70));
        
        printModelStructure();
        
        System.out.println("=".repeat(70));
        System.out.println("Total params: " + formatNumber(totalParameters));
        System.out.println("Trainable params: " + formatNumber(trainableParameters));
        System.out.println("Non-trainable params: " + formatNumber(totalParameters - trainableParameters));
        System.out.println("=".repeat(70));
    }

    /**
     * 打印模型结构（抽象方法）
     */
    protected abstract void printModelStructure();

    /**
     * 计算模型占用内存
     */
    public long getMemoryUsage() {
        long memoryBytes = 0;
        
        for (Variable param : parameters.values()) {
            memoryBytes += param.getMemoryUsage();
        }
        
        for (Variable buffer : buffers.values()) {
            memoryBytes += buffer.getMemoryUsage();
        }
        
        return memoryBytes;
    }

    /**
     * 验证输入维度
     */
    protected void validateInput(Variable input) {
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        
        if (!input.getDevice().equals(this.device)) {
            throw new IllegalArgumentException(
                String.format("Input device (%s) doesn't match model device (%s)", 
                             input.getDevice(), this.device));
        }
    }

    // 私有辅助方法

    private void loadParameters(Map<String, Variable> parameterState) {
        for (Map.Entry<String, Variable> entry : parameterState.entrySet()) {
            String name = entry.getKey();
            Variable newParam = entry.getValue();
            
            if (parameters.containsKey(name)) {
                Variable currentParam = parameters.get(name);
                if (Arrays.equals(currentParam.getShape(), newParam.getShape())) {
                    currentParam.setData(newParam.getData());
                } else {
                    System.out.println("Warning: Parameter shape mismatch for " + name);
                }
            } else {
                System.out.println("Warning: Unknown parameter " + name);
            }
        }
    }

    private void loadBuffers(Map<String, Variable> bufferState) {
        for (Map.Entry<String, Variable> entry : bufferState.entrySet()) {
            String name = entry.getKey();
            Variable newBuffer = entry.getValue();
            
            if (buffers.containsKey(name)) {
                Variable currentBuffer = buffers.get(name);
                if (Arrays.equals(currentBuffer.getShape(), newBuffer.getShape())) {
                    currentBuffer.setData(newBuffer.getData());
                } else {
                    System.out.println("Warning: Buffer shape mismatch for " + name);
                }
            }
        }
    }

    private void updateParameterStatistics() {
        totalParameters = 0;
        trainableParameters = 0;
        
        for (Variable param : parameters.values()) {
            long paramCount = param.getElementCount();
            totalParameters += paramCount;
            
            if (param.requiresGrad()) {
                trainableParameters += paramCount;
            }
        }
    }

    private String formatNumber(long number) {
        if (number >= 1_000_000) {
            return String.format("%.1fM", number / 1_000_000.0);
        } else if (number >= 1_000) {
            return String.format("%.1fK", number / 1_000.0);
        } else {
            return String.valueOf(number);
        }
    }

    // 内部类

    /**
     * 模型状态类，用于序列化
     */
    private static class ModelState implements Serializable {
        private static final long serialVersionUID = 1L;
        
        String modelName;
        Map<String, Variable> parameters;
        Map<String, Variable> buffers;
    }

    /**
     * 模型信息类
     */
    public static class ModelInfo {
        public final String name;
        public final long totalParameters;
        public final long trainableParameters;
        public final String device;
        public final boolean training;

        public ModelInfo(String name, long totalParameters, long trainableParameters, 
                        String device, boolean training) {
            this.name = name;
            this.totalParameters = totalParameters;
            this.trainableParameters = trainableParameters;
            this.device = device;
            this.training = training;
        }

        @Override
        public String toString() {
            return String.format("ModelInfo{name='%s', totalParams=%d, trainableParams=%d, device='%s', training=%b}",
                               name, totalParameters, trainableParameters, device, training);
        }
    }
}
```

## 6.1.3 Sequential模型的Model实现

```java
/**
 * Sequential模型的Model实现
 */
public class SequentialModel extends Model {
    private final Sequential network;

    public SequentialModel(String modelName) {
        super(modelName);
        this.network = new Sequential();
    }

    public SequentialModel(String modelName, Layer... layers) {
        super(modelName);
        this.network = new Sequential(layers);
    }

    /**
     * 添加层
     */
    public SequentialModel add(Layer layer) {
        network.add(layer);
        return this;
    }

    @Override
    public Variable forward(Variable input) {
        validateInput(input);
        return network.forward(input);
    }

    @Override
    public int[] computeOutputShape(int[] inputShape) {
        return network.computeOutputShape(inputShape);
    }

    @Override
    public void initializeParameters(int[] inputShape) {
        network.initializeParameters(inputShape);
        
        // 注册网络中的所有参数
        registerNetworkParameters();
    }

    @Override
    protected void applyTrainingMode(boolean training) {
        network.setTraining(training);
    }

    @Override
    protected void printModelStructure() {
        List<Layer> layers = network.getLayers();
        
        System.out.printf("%-20s %-25s %-15s%n", "Layer (type)", "Output Shape", "Param #");
        System.out.println("-".repeat(70));
        
        int[] currentShape = new int[]{1, 1}; // 假设输入形状
        long totalParams = 0;
        
        for (int i = 0; i < layers.size(); i++) {
            Layer layer = layers.get(i);
            currentShape = layer.computeOutputShape(currentShape);
            long layerParams = layer.getParameterCount();
            totalParams += layerParams;
            
            System.out.printf("%-20s %-25s %-15s%n", 
                            layer.getName() + "_" + i,
                            Arrays.toString(currentShape),
                            formatNumber(layerParams));
        }
        
        System.out.println("-".repeat(70));
    }

    @Override
    public Model clone() {
        SequentialModel cloned = new SequentialModel(this.modelName + "_clone");
        
        // 深拷贝网络结构
        for (Layer layer : network.getLayers()) {
            cloned.add(layer.clone());
        }
        
        return cloned;
    }

    /**
     * 注册网络参数
     */
    private void registerNetworkParameters() {
        network.getParameters().forEach(this::addParameter);
        network.getBuffers().forEach(this::addBuffer);
    }

    /**
     * 获取底层Sequential网络
     */
    public Sequential getNetwork() {
        return network;
    }

    private String formatNumber(long number) {
        if (number >= 1_000_000) {
            return String.format("%.1fM", number / 1_000_000.0);
        } else if (number >= 1_000) {
            return String.format("%.1fK", number / 1_000.0);
        } else {
            return String.valueOf(number);
        }
    }
}
```

## 6.1.4 函数式模型实现

```java
/**
 * 函数式模型实现
 * 支持复杂的网络拓扑结构
 */
public class FunctionalModel extends Model {
    private final Map<String, Layer> layers;
    private final Map<String, List<String>> connections;
    private final List<String> inputLayers;
    private final List<String> outputLayers;
    private final List<String> executionOrder;

    public FunctionalModel(String modelName) {
        super(modelName);
        this.layers = new LinkedHashMap<>();
        this.connections = new HashMap<>();
        this.inputLayers = new ArrayList<>();
        this.outputLayers = new ArrayList<>();
        this.executionOrder = new ArrayList<>();
    }

    /**
     * 添加层
     */
    public FunctionalModel addLayer(String name, Layer layer) {
        if (layers.containsKey(name)) {
            throw new IllegalArgumentException("Layer name already exists: " + name);
        }
        layers.put(name, layer);
        connections.put(name, new ArrayList<>());
        return this;
    }

    /**
     * 连接两个层
     */
    public FunctionalModel connect(String fromLayer, String toLayer) {
        if (!layers.containsKey(fromLayer) || !layers.containsKey(toLayer)) {
            throw new IllegalArgumentException("Layer not found");
        }
        connections.get(fromLayer).add(toLayer);
        return this;
    }

    /**
     * 设置输入层
     */
    public FunctionalModel setInputLayers(String... layerNames) {
        inputLayers.clear();
        inputLayers.addAll(Arrays.asList(layerNames));
        return this;
    }

    /**
     * 设置输出层
     */
    public FunctionalModel setOutputLayers(String... layerNames) {
        outputLayers.clear();
        outputLayers.addAll(Arrays.asList(layerNames));
        return this;
    }

    /**
     * 编译模型（构建执行顺序）
     */
    public FunctionalModel compile() {
        executionOrder.clear();
        buildExecutionOrder();
        return this;
    }

    @Override
    public Variable forward(Variable input) {
        validateInput(input);
        
        if (executionOrder.isEmpty()) {
            throw new IllegalStateException("Model not compiled");
        }
        
        Map<String, Variable> layerOutputs = new HashMap<>();
        
        // 设置输入层输出
        for (String inputLayer : inputLayers) {
            layerOutputs.put(inputLayer, input);
        }
        
        // 按执行顺序处理每一层
        for (String layerName : executionOrder) {
            if (inputLayers.contains(layerName)) {
                continue; // 跳过输入层
            }
            
            Layer layer = layers.get(layerName);
            List<String> inputs = getLayerInputs(layerName);
            
            Variable layerInput;
            if (inputs.size() == 1) {
                layerInput = layerOutputs.get(inputs.get(0));
            } else {
                // 多输入情况，需要concatenate或其他融合策略
                List<Variable> multiInputs = new ArrayList<>();
                for (String inputName : inputs) {
                    multiInputs.add(layerOutputs.get(inputName));
                }
                layerInput = Variable.concatenate(multiInputs, 1); // 默认在通道维度连接
            }
            
            Variable layerOutput = layer.forward(layerInput);
            layerOutputs.put(layerName, layerOutput);
        }
        
        // 返回输出层结果
        if (outputLayers.size() == 1) {
            return layerOutputs.get(outputLayers.get(0));
        } else {
            // 多输出情况
            List<Variable> outputs = new ArrayList<>();
            for (String outputLayer : outputLayers) {
                outputs.add(layerOutputs.get(outputLayer));
            }
            return Variable.concatenate(outputs, 1);
        }
    }

    @Override
    public int[] computeOutputShape(int[] inputShape) {
        // 简化实现，实际需要更复杂的形状推导
        return inputShape.clone();
    }

    @Override
    public void initializeParameters(int[] inputShape) {
        // 为每一层初始化参数
        for (Map.Entry<String, Layer> entry : layers.entrySet()) {
            Layer layer = entry.getValue();
            layer.initializeParameters(inputShape);
            
            // 注册参数
            layer.getParameters().forEach((name, param) -> {
                String fullName = entry.getKey() + "." + name;
                addParameter(fullName, param);
            });
        }
    }

    @Override
    protected void applyTrainingMode(boolean training) {
        for (Layer layer : layers.values()) {
            layer.setTraining(training);
        }
    }

    @Override
    protected void printModelStructure() {
        System.out.println("Functional Model Structure:");
        System.out.println("Layers:");
        for (String layerName : layers.keySet()) {
            System.out.println("  " + layerName + ": " + layers.get(layerName).getClass().getSimpleName());
        }
        
        System.out.println("Connections:");
        for (Map.Entry<String, List<String>> entry : connections.entrySet()) {
            if (!entry.getValue().isEmpty()) {
                System.out.println("  " + entry.getKey() + " -> " + entry.getValue());
            }
        }
    }

    @Override
    public Model clone() {
        FunctionalModel cloned = new FunctionalModel(this.modelName + "_clone");
        
        // 深拷贝层
        for (Map.Entry<String, Layer> entry : layers.entrySet()) {
            cloned.addLayer(entry.getKey(), entry.getValue().clone());
        }
        
        // 复制连接
        for (Map.Entry<String, List<String>> entry : connections.entrySet()) {
            for (String target : entry.getValue()) {
                cloned.connect(entry.getKey(), target);
            }
        }
        
        // 复制输入输出层设置
        cloned.setInputLayers(inputLayers.toArray(new String[0]));
        cloned.setOutputLayers(outputLayers.toArray(new String[0]));
        
        return cloned;
    }

    // 私有辅助方法

    private void buildExecutionOrder() {
        Set<String> visited = new HashSet<>();
        Set<String> visiting = new HashSet<>();
        
        for (String layerName : layers.keySet()) {
            if (!visited.contains(layerName)) {
                topologicalSort(layerName, visited, visiting);
            }
        }
    }

    private void topologicalSort(String layerName, Set<String> visited, Set<String> visiting) {
        if (visiting.contains(layerName)) {
            throw new IllegalStateException("Circular dependency detected");
        }
        
        if (visited.contains(layerName)) {
            return;
        }
        
        visiting.add(layerName);
        
        List<String> dependencies = getLayerInputs(layerName);
        for (String dependency : dependencies) {
            topologicalSort(dependency, visited, visiting);
        }
        
        visiting.remove(layerName);
        visited.add(layerName);
        executionOrder.add(layerName);
    }

    private List<String> getLayerInputs(String layerName) {
        List<String> inputs = new ArrayList<>();
        for (Map.Entry<String, List<String>> entry : connections.entrySet()) {
            if (entry.getValue().contains(layerName)) {
                inputs.add(entry.getKey());
            }
        }
        return inputs;
    }
}
```

## 6.1.5 Model的实际应用示例

### 创建简单的Sequential模型

```java
/**
 * 创建简单分类模型的示例
 */
public class ModelExample {
    
    public static SequentialModel createSimpleCNN(int numClasses) {
        SequentialModel model = new SequentialModel("SimpleCNN");
        
        model.add(new Conv2D(3, 32, new int[]{3, 3}, new int[]{1, 1}, new int[]{1, 1}, true, "zeros"))
             .add(new ReLU())
             .add(new MaxPool2D(new int[]{2, 2}, new int[]{2, 2}))
             .add(new Conv2D(32, 64, new int[]{3, 3}, new int[]{1, 1}, new int[]{1, 1}, true, "zeros"))
             .add(new ReLU())
             .add(new MaxPool2D(new int[]{2, 2}, new int[]{2, 2}))
             .add(new Flatten())
             .add(new Dense(64 * 7 * 7, 128))
             .add(new ReLU())
             .add(new Dense(128, numClasses));
        
        // 初始化模型
        model.initializeParameters(new int[]{1, 3, 28, 28});
        
        return model;
    }
    
    public static void demonstrateModelUsage() {
        // 创建模型
        SequentialModel model = createSimpleCNN(10);
        
        // 打印模型信息
        model.summary();
        
        // 设置训练模式
        model.train();
        
        // 创建示例输入
        Variable input = Variable.randn(new int[]{32, 3, 28, 28}); // batch_size=32
        
        // 前向传播
        Variable output = model.forward(input);
        System.out.println("Output shape: " + Arrays.toString(output.getShape()));
        
        // 保存模型
        try {
            model.save("simple_cnn.model");
            System.out.println("Model saved successfully");
        } catch (IOException e) {
            System.err.println("Failed to save model: " + e.getMessage());
        }
    }
}
```

Model抽象作为深度学习框架的最高层接口，提供了训练和推理的统一框架。通过合理的设计，Model类不仅简化了用户的使用体验，还为复杂的模型管理提供了强大的支持。

下一节我们将探讨模型状态管理，学习如何实现高效的参数保存与加载机制。