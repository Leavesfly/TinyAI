# 11.6 综合项目：模型评估与优化系统

在前面的章节中，我们学习了模型评估的各种方法和超参数调优的技术。现在，我们将把这些知识整合到一个完整的项目中，构建一个模型评估与优化系统。这个系统将提供从数据加载、模型训练、性能评估到超参数优化的全流程支持。

## 本节内容概览

- 系统架构设计
- 核心模块实现
- 模型评估流水线
- 超参数优化引擎
- 可视化界面设计
- 系统集成与测试

## 设计思考与技术理念

在设计一个完整的模型评估与优化系统时，我们需要考虑以下几个关键因素：

1. **模块化设计**：将系统分解为独立的模块，便于维护和扩展
2. **可配置性**：支持不同的模型、评估指标和优化算法
3. **可扩展性**：易于添加新的模型类型和评估方法
4. **用户友好性**：提供清晰的接口和可视化结果
5. **性能效率**：优化计算过程，支持并行处理

我们的系统将采用分层架构，包括数据层、核心逻辑层、优化层和用户接口层。

## 11.6.1 系统架构设计

让我们首先设计系统的整体架构：

```java
/**
 * 模型评估与优化系统架构
 * 
 * 系统层次结构：
 * 
 * +--------------------------------------------------+
 * |                用户接口层                         |
 * |  - 命令行界面                                   |
 * |  - Web界面(可选)                                |
 * +--------------------------------------------------+
 * |                服务编排层                         |
 * |  - 工作流引擎                                   |
 * |  - 任务调度器                                   |
 * +--------------------------------------------------+
 * |                核心业务层                         |
 * |  - 模型评估引擎                                 |
 * |  - 超参数优化器                                 |
 * |  - 结果分析器                                   |
 * +--------------------------------------------------+
 * |                数据处理层                         |
 * |  - 数据加载器                                   |
 * |  - 特征工程                                     |
 * |  - 数据分割器                                   |
 * +--------------------------------------------------+
 * |                基础设施层                         |
 * |  - 模型库                                       |
 * |  - 评估指标库                                   |
 * |  - 优化算法库                                   |
 * +--------------------------------------------------+
 */

/**
 * 系统核心配置类
 */
public class SystemConfig {
    // 数据相关配置
    private String dataPath;
    private String delimiter;
    private boolean hasHeader;
    
    // 模型相关配置
    private String modelType;
    private Map<String, Object> modelParams;
    
    // 评估相关配置
    private String[] evaluationMetrics;
    private int cvFolds;
    
    // 优化相关配置
    private String optimizerType;
    private int maxIterations;
    private Map<String, Object> optimizerParams;
    
    // 系统相关配置
    private int parallelThreads;
    private String outputPath;
    
    // 构造函数
    public SystemConfig() {
        this.modelParams = new HashMap<>();
        this.evaluationMetrics = new String[]{"accuracy"};
        this.cvFolds = 5;
        this.optimizerParams = new HashMap<>();
        this.parallelThreads = Runtime.getRuntime().availableProcessors();
    }
    
    // Getters and Setters
    public String getDataPath() { return dataPath; }
    public SystemConfig setDataPath(String dataPath) {
        this.dataPath = dataPath;
        return this;
    }
    
    public String getDelimiter() { return delimiter; }
    public SystemConfig setDelimiter(String delimiter) {
        this.delimiter = delimiter;
        return this;
    }
    
    public boolean isHasHeader() { return hasHeader; }
    public SystemConfig setHasHeader(boolean hasHeader) {
        this.hasHeader = hasHeader;
        return this;
    }
    
    public String getModelType() { return modelType; }
    public SystemConfig setModelType(String modelType) {
        this.modelType = modelType;
        return this;
    }
    
    public Map<String, Object> getModelParams() { return modelParams; }
    public SystemConfig setModelParam(String key, Object value) {
        this.modelParams.put(key, value);
        return this;
    }
    
    public String[] getEvaluationMetrics() { return evaluationMetrics; }
    public SystemConfig setEvaluationMetrics(String[] evaluationMetrics) {
        this.evaluationMetrics = evaluationMetrics;
        return this;
    }
    
    public int getCvFolds() { return cvFolds; }
    public SystemConfig setCvFolds(int cvFolds) {
        this.cvFolds = cvFolds;
        return this;
    }
    
    public String getOptimizerType() { return optimizerType; }
    public SystemConfig setOptimizerType(String optimizerType) {
        this.optimizerType = optimizerType;
        return this;
    }
    
    public int getMaxIterations() { return maxIterations; }
    public SystemConfig setMaxIterations(int maxIterations) {
        this.maxIterations = maxIterations;
        return this;
    }
    
    public Map<String, Object> getOptimizerParams() { return optimizerParams; }
    public SystemConfig setOptimizerParam(String key, Object value) {
        this.optimizerParams.put(key, value);
        return this;
    }
    
    public int getParallelThreads() { return parallelThreads; }
    public SystemConfig setParallelThreads(int parallelThreads) {
        this.parallelThreads = parallelThreads;
        return this;
    }
    
    public String getOutputPath() { return outputPath; }
    public SystemConfig setOutputPath(String outputPath) {
        this.outputPath = outputPath;
        return this;
    }
}
```

## 11.6.2 数据处理模块

数据处理是整个系统的基础，我们需要实现数据加载、预处理和分割功能：

```java
import java.io.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * 数据处理模块
 */
public class DataProcessor {
    
    /**
     * 数据集类
     */
    public static class Dataset {
        private double[][] features;
        private int[] labels;
        private String[] featureNames;
        private int numSamples;
        private int numFeatures;
        
        public Dataset(double[][] features, int[] labels) {
            this.features = features;
            this.labels = labels;
            this.numSamples = features.length;
            this.numFeatures = features[0].length;
        }
        
        public Dataset(double[][] features, int[] labels, String[] featureNames) {
            this(features, labels);
            this.featureNames = featureNames;
        }
        
        // Getters
        public double[][] getFeatures() { return features; }
        public int[] getLabels() { return labels; }
        public String[] getFeatureNames() { return featureNames; }
        public int getNumSamples() { return numSamples; }
        public int getNumFeatures() { return numFeatures; }
        
        /**
         * 获取数据集的基本统计信息
         */
        public DatasetStats getStats() {
            return new DatasetStats(this);
        }
    }
    
    /**
     * 数据集统计信息
     */
    public static class DatasetStats {
        private int numSamples;
        private int numFeatures;
        private int numClasses;
        private Map<Integer, Integer> classDistribution;
        private double[] featureMeans;
        private double[] featureStds;
        
        public DatasetStats(Dataset dataset) {
            this.numSamples = dataset.getNumSamples();
            this.numFeatures = dataset.getNumFeatures();
            
            // 计算类别分布
            this.classDistribution = new HashMap<>();
            for (int label : dataset.getLabels()) {
                classDistribution.put(label, classDistribution.getOrDefault(label, 0) + 1);
            }
            this.numClasses = classDistribution.size();
            
            // 计算特征统计信息
            this.featureMeans = new double[numFeatures];
            this.featureStds = new double[numFeatures];
            
            for (int j = 0; j < numFeatures; j++) {
                double sum = 0;
                for (int i = 0; i < numSamples; i++) {
                    sum += dataset.getFeatures()[i][j];
                }
                featureMeans[j] = sum / numSamples;
                
                double sumSquares = 0;
                for (int i = 0; i < numSamples; i++) {
                    double diff = dataset.getFeatures()[i][j] - featureMeans[j];
                    sumSquares += diff * diff;
                }
                featureStds[j] = Math.sqrt(sumSquares / numSamples);
            }
        }
        
        // Getters
        public int getNumSamples() { return numSamples; }
        public int getNumFeatures() { return numFeatures; }
        public int getNumClasses() { return numClasses; }
        public Map<Integer, Integer> getClassDistribution() { return classDistribution; }
        public double[] getFeatureMeans() { return featureMeans; }
        public double[] getFeatureStds() { return featureStds; }
    }
    
    /**
     * 从CSV文件加载数据
     */
    public static Dataset loadFromCSV(String filePath, String delimiter, boolean hasHeader) 
            throws IOException {
        List<double[]> featuresList = new ArrayList<>();
        List<Integer> labelsList = new ArrayList<>();
        String[] featureNames = null;
        
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            int lineNumber = 0;
            
            while ((line = reader.readLine()) != null) {
                lineNumber++;
                if (hasHeader && lineNumber == 1) {
                    // 读取特征名称
                    featureNames = line.split(delimiter);
                    continue;
                }
                
                String[] parts = line.split(delimiter);
                if (parts.length < 2) {
                    continue; // 跳过无效行
                }
                
                // 解析特征和标签
                double[] features = new double[parts.length - 1];
                for (int i = 0; i < parts.length - 1; i++) {
                    try {
                        features[i] = Double.parseDouble(parts[i]);
                    } catch (NumberFormatException e) {
                        features[i] = 0.0; // 默认值
                    }
                }
                
                int label;
                try {
                    label = Integer.parseInt(parts[parts.length - 1]);
                } catch (NumberFormatException e) {
                    label = 0; // 默认标签
                }
                
                featuresList.add(features);
                labelsList.add(label);
            }
        }
        
        // 转换为数组
        double[][] features = featuresList.toArray(new double[0][0]);
        int[] labels = labelsList.stream().mapToInt(Integer::intValue).toArray();
        
        return featureNames != null ? 
            new Dataset(features, labels, featureNames) : 
            new Dataset(features, labels);
    }
    
    /**
     * 数据标准化
     */
    public static Dataset standardize(Dataset dataset) {
        DatasetStats stats = dataset.getStats();
        double[] means = stats.getFeatureMeans();
        double[] stds = stats.getFeatureStds();
        
        double[][] standardizedFeatures = new double[dataset.getNumSamples()][dataset.getNumFeatures()];
        
        for (int i = 0; i < dataset.getNumSamples(); i++) {
            for (int j = 0; j < dataset.getNumFeatures(); j++) {
                if (stds[j] > 0) {
                    standardizedFeatures[i][j] = (dataset.getFeatures()[i][j] - means[j]) / stds[j];
                } else {
                    standardizedFeatures[i][j] = dataset.getFeatures()[i][j] - means[j];
                }
            }
        }
        
        return new Dataset(standardizedFeatures, dataset.getLabels(), dataset.getFeatureNames());
    }
    
    /**
     * 数据分割器
     */
    public static class DataSplitter {
        
        /**
         * 训练测试分割结果
         */
        public static class SplitResult {
            private Dataset trainDataset;
            private Dataset testDataset;
            private double trainRatio;
            
            public SplitResult(Dataset trainDataset, Dataset testDataset, double trainRatio) {
                this.trainDataset = trainDataset;
                this.testDataset = testDataset;
                this.trainRatio = trainRatio;
            }
            
            // Getters
            public Dataset getTrainDataset() { return trainDataset; }
            public Dataset getTestDataset() { return testDataset; }
            public double getTrainRatio() { return trainRatio; }
        }
        
        /**
         * 随机分割数据集
         */
        public static SplitResult trainTestSplit(Dataset dataset, double trainRatio, long seed) {
            int numSamples = dataset.getNumSamples();
            int trainSize = (int) (numSamples * trainRatio);
            
            // 创建索引数组并打乱
            Integer[] indices = new Integer[numSamples];
            for (int i = 0; i < numSamples; i++) {
                indices[i] = i;
            }
            
            Random random = new Random(seed);
            Collections.shuffle(Arrays.asList(indices), random);
            
            // 分割索引
            int[] trainIndices = new int[trainSize];
            int[] testIndices = new int[numSamples - trainSize];
            
            for (int i = 0; i < trainSize; i++) {
                trainIndices[i] = indices[i];
            }
            
            for (int i = 0; i < numSamples - trainSize; i++) {
                testIndices[i] = indices[trainSize + i];
            }
            
            // 构造分割后的数据集
            Dataset trainDataset = selectSamples(dataset, trainIndices);
            Dataset testDataset = selectSamples(dataset, testIndices);
            
            return new SplitResult(trainDataset, testDataset, trainRatio);
        }
        
        /**
         * 选择指定索引的样本
         */
        private static Dataset selectSamples(Dataset dataset, int[] indices) {
            double[][] features = new double[indices.length][];
            int[] labels = new int[indices.length];
            
            for (int i = 0; i < indices.length; i++) {
                features[i] = dataset.getFeatures()[indices[i]];
                labels[i] = dataset.getLabels()[indices[i]];
            }
            
            return new Dataset(features, labels, dataset.getFeatureNames());
        }
    }
}
```

## 11.6.3 模型评估引擎

模型评估引擎是系统的核心组件，负责执行各种评估任务：

```java
import java.util.*;
import java.util.concurrent.*;

/**
 * 模型评估引擎
 */
public class ModelEvaluationEngine {
    
    /**
     * 评估结果
     */
    public static class EvaluationResult {
        private String modelType;
        private Map<String, Object> modelParams;
        private Map<String, Double> metrics;
        private long evaluationTime;
        private int numFolds;
        
        public EvaluationResult(String modelType, Map<String, Object> modelParams) {
            this.modelType = modelType;
            this.modelParams = modelParams;
            this.metrics = new HashMap<>();
        }
        
        // Getters and Setters
        public String getModelType() { return modelType; }
        public Map<String, Object> getModelParams() { return modelParams; }
        public Map<String, Double> getMetrics() { return metrics; }
        public EvaluationResult setMetric(String name, double value) {
            this.metrics.put(name, value);
            return this;
        }
        public long getEvaluationTime() { return evaluationTime; }
        public EvaluationResult setEvaluationTime(long evaluationTime) {
            this.evaluationTime = evaluationTime;
            return this;
        }
        public int getNumFolds() { return numFolds; }
        public EvaluationResult setNumFolds(int numFolds) {
            this.numFolds = numFolds;
            return this;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Model: ").append(modelType).append("\n");
            sb.append("Parameters: ").append(modelParams).append("\n");
            sb.append("Metrics:\n");
            for (Map.Entry<String, Double> entry : metrics.entrySet()) {
                sb.append("  ").append(entry.getKey()).append(": ").append(String.format("%.4f", entry.getValue())).append("\n");
            }
            sb.append("Evaluation Time: ").append(evaluationTime).append("ms\n");
            if (numFolds > 0) {
                sb.append("CV Folds: ").append(numFolds).append("\n");
            }
            return sb.toString();
        }
    }
    
    /**
     * 交叉验证评估器
     */
    public static class CrossValidationEvaluator {
        private int numFolds;
        private long randomSeed;
        private int numThreads;
        
        public CrossValidationEvaluator(int numFolds, long randomSeed, int numThreads) {
            this.numFolds = numFolds;
            this.randomSeed = randomSeed;
            this.numThreads = numThreads;
        }
        
        /**
         * 执行交叉验证评估
         */
        public EvaluationResult evaluate(Model model, DataProcessor.Dataset dataset, 
                                       String[] metrics) {
            long startTime = System.currentTimeMillis();
            
            // 生成K折分割
            KFoldGenerator kf = new KFoldGenerator(numFolds, randomSeed);
            List<KFoldGenerator.FoldIndices> folds = kf.generate(dataset.getNumSamples());
            
            // 存储每折的评估结果
            List<Map<String, Double>> foldResults = new ArrayList<>();
            
            // 创建线程池
            ExecutorService executor = Executors.newFixedThreadPool(
                Math.min(numThreads, folds.size()));
            List<Future<Map<String, Double>>> futures = new ArrayList<>();
            
            // 并行执行每折评估
            for (KFoldGenerator.FoldIndices fold : folds) {
                Future<Map<String, Double>> future = executor.submit(() -> {
                    // 构造训练集和验证集
                    DataProcessor.Dataset trainDataset = createSubset(dataset, fold.getTrainIndices());
                    DataProcessor.Dataset valDataset = createSubset(dataset, fold.getValidationIndices());
                    
                    // 训练模型
                    model.train(trainDataset.getFeatures(), trainDataset.getLabels());
                    
                    // 预测
                    int[] predictions = model.predict(valDataset.getFeatures());
                    
                    // 计算评估指标
                    return calculateMetrics(valDataset.getLabels(), predictions, metrics);
                });
                futures.add(future);
            }
            
            // 收集结果
            for (Future<Map<String, Double>> future : futures) {
                try {
                    foldResults.add(future.get());
                } catch (Exception e) {
                    throw new RuntimeException("评估过程中发生错误", e);
                }
            }
            
            // 关闭线程池
            executor.shutdown();
            
            // 计算平均指标
            Map<String, Double> avgMetrics = calculateAverageMetrics(foldResults);
            
            long endTime = System.currentTimeMillis();
            
            EvaluationResult result = new EvaluationResult(
                model.getClass().getSimpleName(), model.getParameters());
            result.setNumFolds(numFolds);
            result.setEvaluationTime(endTime - startTime);
            
            for (Map.Entry<String, Double> entry : avgMetrics.entrySet()) {
                result.setMetric(entry.getKey(), entry.getValue());
            }
            
            return result;
        }
        
        /**
         * 创建数据子集
         */
        private DataProcessor.Dataset createSubset(DataProcessor.Dataset dataset, int[] indices) {
            double[][] features = new double[indices.length][];
            int[] labels = new int[indices.length];
            
            for (int i = 0; i < indices.length; i++) {
                features[i] = dataset.getFeatures()[indices[i]];
                labels[i] = dataset.getLabels()[indices[i]];
            }
            
            return new DataProcessor.Dataset(features, labels, dataset.getFeatureNames());
        }
        
        /**
         * 计算评估指标
         */
        private Map<String, Double> calculateMetrics(int[] trueLabels, int[] predictions, String[] metrics) {
            Map<String, Double> results = new HashMap<>();
            
            for (String metric : metrics) {
                switch (metric.toLowerCase()) {
                    case "accuracy":
                        results.put("accuracy", calculateAccuracy(trueLabels, predictions));
                        break;
                    case "precision":
                        results.put("precision", calculatePrecision(trueLabels, predictions));
                        break;
                    case "recall":
                        results.put("recall", calculateRecall(trueLabels, predictions));
                        break;
                    case "f1":
                        results.put("f1", calculateF1Score(trueLabels, predictions));
                        break;
                    default:
                        results.put(metric, 0.0);
                }
            }
            
            return results;
        }
        
        /**
         * 计算准确率
         */
        private double calculateAccuracy(int[] trueLabels, int[] predictions) {
            if (trueLabels.length != predictions.length) {
                throw new IllegalArgumentException("标签长度不匹配");
            }
            
            int correct = 0;
            for (int i = 0; i < trueLabels.length; i++) {
                if (trueLabels[i] == predictions[i]) {
                    correct++;
                }
            }
            
            return (double) correct / trueLabels.length;
        }
        
        /**
         * 计算精确率
         */
        private double calculatePrecision(int[] trueLabels, int[] predictions) {
            int tp = 0, fp = 0;
            for (int i = 0; i < trueLabels.length; i++) {
                if (predictions[i] == 1 && trueLabels[i] == 1) {
                    tp++;
                } else if (predictions[i] == 1 && trueLabels[i] == 0) {
                    fp++;
                }
            }
            return (tp + fp) == 0 ? 0 : (double) tp / (tp + fp);
        }
        
        /**
         * 计算召回率
         */
        private double calculateRecall(int[] trueLabels, int[] predictions) {
            int tp = 0, fn = 0;
            for (int i = 0; i < trueLabels.length; i++) {
                if (predictions[i] == 1 && trueLabels[i] == 1) {
                    tp++;
                } else if (predictions[i] == 0 && trueLabels[i] == 1) {
                    fn++;
                }
            }
            return (tp + fn) == 0 ? 0 : (double) tp / (tp + fn);
        }
        
        /**
         * 计算F1分数
         */
        private double calculateF1Score(int[] trueLabels, int[] predictions) {
            double precision = calculatePrecision(trueLabels, predictions);
            double recall = calculateRecall(trueLabels, predictions);
            return (precision + recall) == 0 ? 0 : 2 * precision * recall / (precision + recall);
        }
        
        /**
         * 计算平均指标
         */
        private Map<String, Double> calculateAverageMetrics(List<Map<String, Double>> foldResults) {
            if (foldResults.isEmpty()) {
                return new HashMap<>();
            }
            
            Map<String, Double> avgMetrics = new HashMap<>();
            int numFolds = foldResults.size();
            
            // 初始化指标
            for (String metric : foldResults.get(0).keySet()) {
                avgMetrics.put(metric, 0.0);
            }
            
            // 累加各折结果
            for (Map<String, Double> foldResult : foldResults) {
                for (Map.Entry<String, Double> entry : foldResult.entrySet()) {
                    avgMetrics.put(entry.getKey(), 
                        avgMetrics.get(entry.getKey()) + entry.getValue());
                }
            }
            
            // 计算平均值
            for (Map.Entry<String, Double> entry : avgMetrics.entrySet()) {
                avgMetrics.put(entry.getKey(), entry.getValue() / numFolds);
            }
            
            return avgMetrics;
        }
    }
    
    /**
     * K折生成器
     */
    public static class KFoldGenerator {
        private int k;
        private long seed;
        
        public KFoldGenerator(int k, long seed) {
            this.k = k;
            this.seed = seed;
        }
        
        /**
         * 生成K折分割索引
         */
        public List<FoldIndices> generate(int dataSize) {
            // 创建数据索引数组
            Integer[] indices = new Integer[dataSize];
            for (int i = 0; i < dataSize; i++) {
                indices[i] = i;
            }
            
            // 随机打乱索引
            Random random = new Random(seed);
            Collections.shuffle(Arrays.asList(indices), random);
            
            // 计算每折的大小
            int foldSize = dataSize / k;
            int remainder = dataSize % k;
            
            List<FoldIndices> folds = new ArrayList<>();
            
            for (int fold = 0; fold < k; fold++) {
                // 计算当前折的起始和结束位置
                int start = fold * foldSize + Math.min(fold, remainder);
                int end = start + foldSize + (fold < remainder ? 1 : 0);
                
                // 提取验证集索引
                int[] validationIndices = new int[end - start];
                for (int i = 0; i < validationIndices.length; i++) {
                    validationIndices[i] = indices[start + i];
                }
                
                // 提取训练集索引
                int[] trainIndices = new int[dataSize - validationIndices.length];
                int trainIndex = 0;
                
                // 添加验证集之前的索引
                for (int i = 0; i < start; i++) {
                    trainIndices[trainIndex++] = indices[i];
                }
                
                // 添加验证集之后的索引
                for (int i = end; i < dataSize; i++) {
                    trainIndices[trainIndex++] = indices[i];
                }
                
                folds.add(new FoldIndices(trainIndices, validationIndices));
            }
            
            return folds;
        }
        
        /**
         * 折索引类
         */
        public static class FoldIndices {
            private int[] trainIndices;
            private int[] validationIndices;
            
            public FoldIndices(int[] trainIndices, int[] validationIndices) {
                this.trainIndices = trainIndices;
                this.validationIndices = validationIndices;
            }
            
            public int[] getTrainIndices() { return trainIndices; }
            public int[] getValidationIndices() { return validationIndices; }
        }
    }
}
```

## 11.6.4 超参数优化引擎

超参数优化引擎负责自动寻找最优的模型参数配置：

```java
import java.util.*;
import java.util.concurrent.*;

/**
 * 超参数优化引擎
 */
public class HyperparameterOptimizationEngine {
    
    /**
     * 优化结果
     */
    public static class OptimizationResult {
        private Map<String, Object> bestParameters;
        private double bestScore;
        private List<OptimizationTrial> trials;
        private long optimizationTime;
        
        public OptimizationResult() {
            this.trials = new ArrayList<>();
        }
        
        // Getters and Setters
        public Map<String, Object> getBestParameters() { return bestParameters; }
        public OptimizationResult setBestParameters(Map<String, Object> bestParameters) {
            this.bestParameters = bestParameters;
            return this;
        }
        
        public double getBestScore() { return bestScore; }
        public OptimizationResult setBestScore(double bestScore) {
            this.bestScore = bestScore;
            return this;
        }
        
        public List<OptimizationTrial> getTrials() { return trials; }
        public OptimizationResult addTrial(OptimizationTrial trial) {
            this.trials.add(trial);
            return this;
        }
        
        public long getOptimizationTime() { return optimizationTime; }
        public OptimizationResult setOptimizationTime(long optimizationTime) {
            this.optimizationTime = optimizationTime;
            return this;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Best Parameters: ").append(bestParameters).append("\n");
            sb.append("Best Score: ").append(String.format("%.4f", bestScore)).append("\n");
            sb.append("Trials: ").append(trials.size()).append("\n");
            sb.append("Optimization Time: ").append(optimizationTime).append("ms\n");
            return sb.toString();
        }
    }
    
    /**
     * 优化试验
     */
    public static class OptimizationTrial {
        private Map<String, Object> parameters;
        private double score;
        private long evaluationTime;
        
        public OptimizationTrial(Map<String, Object> parameters, double score, long evaluationTime) {
            this.parameters = parameters;
            this.score = score;
            this.evaluationTime = evaluationTime;
        }
        
        // Getters
        public Map<String, Object> getParameters() { return parameters; }
        public double getScore() { return score; }
        public long getEvaluationTime() { return evaluationTime; }
        
        @Override
        public String toString() {
            return String.format("Trial{params=%s, score=%.4f, time=%dms}", 
                               parameters, score, evaluationTime);
        }
    }
    
    /**
     * 超参数空间定义
     */
    public static class HyperparameterSpace {
        private Map<String, ParameterRange> parameterRanges;
        
        public HyperparameterSpace() {
            this.parameterRanges = new HashMap<>();
        }
        
        public HyperparameterSpace addRange(String name, ParameterRange range) {
            this.parameterRanges.put(name, range);
            return this;
        }
        
        public Map<String, ParameterRange> getParameterRanges() {
            return parameterRanges;
        }
        
        public Set<String> getParameterNames() {
            return parameterRanges.keySet();
        }
    }
    
    /**
     * 参数范围接口
     */
    public interface ParameterRange {
        Object sample(Random random);
        List<Object> getGridValues();
    }
    
    /**
     * 整数范围
     */
    public static class IntegerRange implements ParameterRange {
        private int min;
        private int max;
        private boolean logScale;
        
        public IntegerRange(int min, int max) {
            this(min, max, false);
        }
        
        public IntegerRange(int min, int max, boolean logScale) {
            this.min = min;
            this.max = max;
            this.logScale = logScale;
        }
        
        @Override
        public Object sample(Random random) {
            if (logScale) {
                double logMin = Math.log(min);
                double logMax = Math.log(max);
                double logValue = logMin + random.nextDouble() * (logMax - logMin);
                return (int) Math.round(Math.exp(logValue));
            } else {
                return min + random.nextInt(max - min + 1);
            }
        }
        
        @Override
        public List<Object> getGridValues() {
            List<Object> values = new ArrayList<>();
            for (int i = min; i <= max; i++) {
                values.add(i);
            }
            return values;
        }
    }
    
    /**
     * 浮点数范围
     */
    public static class DoubleRange implements ParameterRange {
        private double min;
        private double max;
        private boolean logScale;
        
        public DoubleRange(double min, double max) {
            this(min, max, false);
        }
        
        public DoubleRange(double min, double max, boolean logScale) {
            this.min = min;
            this.max = max;
            this.logScale = logScale;
        }
        
        @Override
        public Object sample(Random random) {
            if (logScale) {
                double logMin = Math.log(min);
                double logMax = Math.log(max);
                double logValue = logMin + random.nextDouble() * (logMax - logMin);
                return Math.exp(logValue);
            } else {
                return min + random.nextDouble() * (max - min);
            }
        }
        
        @Override
        public List<Object> getGridValues() {
            List<Object> values = new ArrayList<>();
            // 简化处理，返回5个均匀分布的值
            for (int i = 0; i <= 4; i++) {
                values.add(min + (max - min) * i / 4.0);
            }
            return values;
        }
    }
    
    /**
     * 离散值范围
     */
    public static class DiscreteRange implements ParameterRange {
        private List<Object> values;
        
        public DiscreteRange(List<Object> values) {
            this.values = new ArrayList<>(values);
        }
        
        @Override
        public Object sample(Random random) {
            return values.get(random.nextInt(values.size()));
        }
        
        @Override
        public List<Object> getGridValues() {
            return new ArrayList<>(values);
        }
    }
    
    /**
     * 网格搜索优化器
     */
    public static class GridSearchOptimizer {
        private int maxEvaluations;
        private int numThreads;
        
        public GridSearchOptimizer(int maxEvaluations, int numThreads) {
            this.maxEvaluations = maxEvaluations;
            this.numThreads = numThreads;
        }
        
        /**
         * 执行网格搜索
         */
        public OptimizationResult optimize(
                ModelFactory modelFactory,
                DataProcessor.Dataset dataset,
                HyperparameterSpace space,
                String objectiveMetric,
                boolean maximize) {
            
            long startTime = System.currentTimeMillis();
            OptimizationResult result = new OptimizationResult();
            
            // 生成所有参数组合
            List<Map<String, Object>> paramCombinations = generateParameterCombinations(space);
            
            // 限制评估次数
            if (paramCombinations.size() > maxEvaluations) {
                // 随机采样子集
                Random random = new Random();
                Collections.shuffle(paramCombinations, random);
                paramCombinations = paramCombinations.subList(0, maxEvaluations);
            }
            
            // 创建线程池
            ExecutorService executor = Executors.newFixedThreadPool(
                Math.min(numThreads, paramCombinations.size()));
            List<Future<OptimizationTrial>> futures = new ArrayList<>();
            
            // 并行评估每个参数组合
            for (Map<String, Object> params : paramCombinations) {
                Future<OptimizationTrial> future = executor.submit(() -> {
                    long evalStartTime = System.currentTimeMillis();
                    
                    // 创建模型
                    Model model = modelFactory.createModel(params);
                    
                    // 交叉验证评估
                    ModelEvaluationEngine.CrossValidationEvaluator evaluator = 
                        new ModelEvaluationEngine.CrossValidationEvaluator(5, System.currentTimeMillis(), 1);
                    
                    ModelEvaluationEngine.EvaluationResult evalResult = 
                        evaluator.evaluate(model, dataset, new String[]{objectiveMetric});
                    
                    double score = evalResult.getMetrics().get(objectiveMetric);
                    long evalTime = System.currentTimeMillis() - evalStartTime;
                    
                    return new OptimizationTrial(new HashMap<>(params), score, evalTime);
                });
                futures.add(future);
            }
            
            // 收集结果
            double bestScore = maximize ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
            Map<String, Object> bestParams = null;
            
            for (Future<OptimizationTrial> future : futures) {
                try {
                    OptimizationTrial trial = future.get();
                    result.addTrial(trial);
                    
                    boolean isBetter = maximize ? 
                        trial.getScore() > bestScore : 
                        trial.getScore() < bestScore;
                    
                    if (isBetter) {
                        bestScore = trial.getScore();
                        bestParams = trial.getParameters();
                    }
                } catch (Exception e) {
                    throw new RuntimeException("优化过程中发生错误", e);
                }
            }
            
            // 关闭线程池
            executor.shutdown();
            
            result.setBestParameters(bestParams)
                  .setBestScore(bestScore)
                  .setOptimizationTime(System.currentTimeMillis() - startTime);
            
            return result;
        }
        
        /**
         * 生成参数组合
         */
        private List<Map<String, Object>> generateParameterCombinations(HyperparameterSpace space) {
            List<Map<String, Object>> combinations = new ArrayList<>();
            List<String> paramNames = new ArrayList<>(space.getParameterNames());
            
            generateCombinationsRecursive(space, paramNames, 0, new HashMap<>(), combinations);
            return combinations;
        }
        
        /**
         * 递归生成参数组合
         */
        private void generateCombinationsRecursive(
                HyperparameterSpace space,
                List<String> paramNames,
                int index,
                Map<String, Object> currentCombination,
                List<Map<String, Object>> combinations) {
            
            if (index == paramNames.size()) {
                combinations.add(new HashMap<>(currentCombination));
                return;
            }
            
            String paramName = paramNames.get(index);
            ParameterRange range = space.getParameterRanges().get(paramName);
            List<Object> values = range.getGridValues();
            
            for (Object value : values) {
                currentCombination.put(paramName, value);
                generateCombinationsRecursive(space, paramNames, index + 1, currentCombination, combinations);
                currentCombination.remove(paramName);
            }
        }
    }
    
    /**
     * 随机搜索优化器
     */
    public static class RandomSearchOptimizer {
        private int maxEvaluations;
        private int numThreads;
        private long randomSeed;
        
        public RandomSearchOptimizer(int maxEvaluations, int numThreads, long randomSeed) {
            this.maxEvaluations = maxEvaluations;
            this.numThreads = numThreads;
            this.randomSeed = randomSeed;
        }
        
        /**
         * 执行随机搜索
         */
        public OptimizationResult optimize(
                ModelFactory modelFactory,
                DataProcessor.Dataset dataset,
                HyperparameterSpace space,
                String objectiveMetric,
                boolean maximize) {
            
            long startTime = System.currentTimeMillis();
            OptimizationResult result = new OptimizationResult();
            Random random = new Random(randomSeed);
            
            // 创建线程池
            ExecutorService executor = Executors.newFixedThreadPool(
                Math.min(numThreads, maxEvaluations));
            List<Future<OptimizationTrial>> futures = new ArrayList<>();
            
            // 并行评估随机参数组合
            for (int i = 0; i < maxEvaluations; i++) {
                Future<OptimizationTrial> future = executor.submit(() -> {
                    long evalStartTime = System.currentTimeMillis();
                    
                    // 随机采样参数
                    Map<String, Object> params = sampleParameters(space, random);
                    
                    // 创建模型
                    Model model = modelFactory.createModel(params);
                    
                    // 交叉验证评估
                    ModelEvaluationEngine.CrossValidationEvaluator evaluator = 
                        new ModelEvaluationEngine.CrossValidationEvaluator(5, System.currentTimeMillis(), 1);
                    
                    ModelEvaluationEngine.EvaluationResult evalResult = 
                        evaluator.evaluate(model, dataset, new String[]{objectiveMetric});
                    
                    double score = evalResult.getMetrics().get(objectiveMetric);
                    long evalTime = System.currentTimeMillis() - evalStartTime;
                    
                    return new OptimizationTrial(params, score, evalTime);
                });
                futures.add(future);
            }
            
            // 收集结果
            double bestScore = maximize ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
            Map<String, Object> bestParams = null;
            
            for (Future<OptimizationTrial> future : futures) {
                try {
                    OptimizationTrial trial = future.get();
                    result.addTrial(trial);
                    
                    boolean isBetter = maximize ? 
                        trial.getScore() > bestScore : 
                        trial.getScore() < bestScore;
                    
                    if (isBetter) {
                        bestScore = trial.getScore();
                        bestParams = trial.getParameters();
                    }
                } catch (Exception e) {
                    throw new RuntimeException("优化过程中发生错误", e);
                }
            }
            
            // 关闭线程池
            executor.shutdown();
            
            result.setBestParameters(bestParams)
                  .setBestScore(bestScore)
                  .setOptimizationTime(System.currentTimeMillis() - startTime);
            
            return result;
        }
        
        /**
         * 随机采样参数
         */
        private Map<String, Object> sampleParameters(HyperparameterSpace space, Random random) {
            Map<String, Object> params = new HashMap<>();
            for (Map.Entry<String, ParameterRange> entry : space.getParameterRanges().entrySet()) {
                String paramName = entry.getKey();
                ParameterRange range = entry.getValue();
                params.put(paramName, range.sample(random));
            }
            return params;
        }
    }
}
```

## 11.6.5 模型接口和工厂

为了支持不同的模型类型，我们需要定义通用的模型接口和工厂模式：

```java
/**
 * 通用模型接口
 */
interface Model {
    /**
     * 训练模型
     * @param features 特征数据
     * @param labels 标签数据
     */
    void train(double[][] features, int[] labels);
    
    /**
     * 预测
     * @param features 特征数据
     * @return 预测标签
     */
    int[] predict(double[][] features);
    
    /**
     * 获取模型参数
     * @return 参数映射
     */
    Map<String, Object> getParameters();
}

/**
 * 模型工厂接口
 */
interface ModelFactory {
    /**
     * 创建模型实例
     * @param parameters 模型参数
     * @return 模型实例
     */
    Model createModel(Map<String, Object> parameters);
}

/**
 * 简单的逻辑回归模型实现
 */
class LogisticRegressionModel implements Model {
    private Map<String, Object> parameters;
    private double[] weights;
    private double bias;
    private int numFeatures;
    
    public LogisticRegressionModel(Map<String, Object> parameters) {
        this.parameters = new HashMap<>(parameters);
        this.numFeatures = (int) parameters.getOrDefault("numFeatures", 1);
        this.weights = new double[numFeatures];
        this.bias = 0.0;
    }
    
    @Override
    public void train(double[][] features, int[] labels) {
        // 简化的训练实现
        double learningRate = (double) parameters.getOrDefault("learningRate", 0.01);
        int epochs = (int) parameters.getOrDefault("epochs", 100);
        
        // 随机初始化权重
        Random random = new Random();
        for (int i = 0; i < numFeatures; i++) {
            weights[i] = random.nextGaussian() * 0.01;
        }
        
        // 简化的梯度下降
        for (int epoch = 0; epoch < epochs; epoch++) {
            for (int i = 0; i < features.length; i++) {
                double prediction = predictProbability(features[i]);
                double error = labels[i] - prediction;
                
                // 更新权重
                for (int j = 0; j < numFeatures; j++) {
                    weights[j] += learningRate * error * features[i][j];
                }
                bias += learningRate * error;
            }
        }
    }
    
    @Override
    public int[] predict(double[][] features) {
        int[] predictions = new int[features.length];
        for (int i = 0; i < features.length; i++) {
            predictions[i] = predictProbability(features[i]) > 0.5 ? 1 : 0;
        }
        return predictions;
    }
    
    private double predictProbability(double[] features) {
        double z = bias;
        for (int i = 0; i < numFeatures; i++) {
            z += weights[i] * features[i];
        }
        return sigmoid(z);
    }
    
    private double sigmoid(double z) {
        return 1.0 / (1.0 + Math.exp(-z));
    }
    
    @Override
    public Map<String, Object> getParameters() {
        return parameters;
    }
}

/**
 * 逻辑回归模型工厂
 */
class LogisticRegressionFactory implements ModelFactory {
    @Override
    public Model createModel(Map<String, Object> parameters) {
        return new LogisticRegressionModel(parameters);
    }
}

/**
 * 决策树模型实现
 */
class DecisionTreeModel implements Model {
    private Map<String, Object> parameters;
    private TreeNode root;
    private int numFeatures;
    
    public DecisionTreeModel(Map<String, Object> parameters) {
        this.parameters = new HashMap<>(parameters);
        this.numFeatures = (int) parameters.getOrDefault("numFeatures", 1);
    }
    
    @Override
    public void train(double[][] features, int[] labels) {
        // 简化的决策树训练
        root = buildTree(features, labels, 0);
    }
    
    private TreeNode buildTree(double[][] features, int[] labels, int depth) {
        // 简化的实现，总是返回一个叶子节点
        int maxDepth = (int) parameters.getOrDefault("maxDepth", 5);
        if (depth >= maxDepth) {
            return new TreeNode(majorityClass(labels));
        }
        
        // 简单的多数类决策
        return new TreeNode(majorityClass(labels));
    }
    
    private int majorityClass(int[] labels) {
        Map<Integer, Integer> classCount = new HashMap<>();
        for (int label : labels) {
            classCount.put(label, classCount.getOrDefault(label, 0) + 1);
        }
        
        return classCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(0);
    }
    
    @Override
    public int[] predict(double[][] features) {
        int[] predictions = new int[features.length];
        for (int i = 0; i < features.length; i++) {
            predictions[i] = predictSample(features[i]);
        }
        return predictions;
    }
    
    private int predictSample(double[] features) {
        TreeNode node = root;
        while (node != null && !node.isLeaf()) {
            // 简化的预测逻辑
            node = node.getLeftChild(); // 简化处理
        }
        return node != null ? node.getPrediction() : 0;
    }
    
    @Override
    public Map<String, Object> getParameters() {
        return parameters;
    }
    
    /**
     * 树节点类
     */
    private static class TreeNode {
        private int prediction;
        private TreeNode leftChild;
        private TreeNode rightChild;
        private boolean isLeaf;
        
        public TreeNode(int prediction) {
            this.prediction = prediction;
            this.isLeaf = true;
        }
        
        public TreeNode(int prediction, TreeNode leftChild, TreeNode rightChild) {
            this.prediction = prediction;
            this.leftChild = leftChild;
            this.rightChild = rightChild;
            this.isLeaf = false;
        }
        
        public int getPrediction() { return prediction; }
        public TreeNode getLeftChild() { return leftChild; }
        public TreeNode getRightChild() { return rightChild; }
        public boolean isLeaf() { return isLeaf; }
    }
}

/**
 * 决策树模型工厂
 */
class DecisionTreeFactory implements ModelFactory {
    @Override
    public Model createModel(Map<String, Object> parameters) {
        return new DecisionTreeModel(parameters);
    }
}
```

## 11.6.6 系统主控制器

最后，我们需要一个主控制器来协调整个系统的运行：

```java
import java.io.*;
import java.util.*;

/**
 * 模型评估与优化系统主控制器
 */
public class ModelEvaluationOptimizationSystem {
    
    private SystemConfig config;
    private DataProcessor.Dataset dataset;
    private ModelFactory modelFactory;
    
    public ModelEvaluationOptimizationSystem(SystemConfig config) {
        this.config = config;
    }
    
    /**
     * 运行完整的评估与优化流程
     */
    public void run() throws Exception {
        System.out.println("开始运行模型评估与优化系统...");
        
        // 1. 加载数据
        System.out.println("1. 加载数据...");
        loadData();
        
        // 2. 数据预处理
        System.out.println("2. 数据预处理...");
        preprocessData();
        
        // 3. 创建模型工厂
        System.out.println("3. 创建模型工厂...");
        createModelFactory();
        
        // 4. 模型评估
        System.out.println("4. 模型评估...");
        evaluateModel();
        
        // 5. 超参数优化
        System.out.println("5. 超参数优化...");
        optimizeHyperparameters();
        
        // 6. 生成报告
        System.out.println("6. 生成报告...");
        generateReport();
        
        System.out.println("系统运行完成!");
    }
    
    /**
     * 加载数据
     */
    private void loadData() throws IOException {
        this.dataset = DataProcessor.loadFromCSV(
            config.getDataPath(), 
            config.getDelimiter(), 
            config.isHasHeader());
        System.out.println("数据加载完成，样本数: " + dataset.getNumSamples() + 
                          ", 特征数: " + dataset.getNumFeatures());
    }
    
    /**
     * 数据预处理
     */
    private void preprocessData() {
        // 标准化特征
        this.dataset = DataProcessor.standardize(dataset);
        System.out.println("数据预处理完成");
    }
    
    /**
     * 创建模型工厂
     */
    private void createModelFactory() {
        switch (config.getModelType().toLowerCase()) {
            case "logisticregression":
                this.modelFactory = new LogisticRegressionFactory();
                break;
            case "decisiontree":
                this.modelFactory = new DecisionTreeFactory();
                break;
            default:
                throw new IllegalArgumentException("不支持的模型类型: " + config.getModelType());
        }
        System.out.println("模型工厂创建完成: " + config.getModelType());
    }
    
    /**
     * 模型评估
     */
    private void evaluateModel() {
        // 创建模型实例
        Model model = modelFactory.createModel(config.getModelParams());
        
        // 创建评估引擎
        ModelEvaluationEngine.CrossValidationEvaluator evaluator = 
            new ModelEvaluationEngine.CrossValidationEvaluator(
                config.getCvFolds(), 
                System.currentTimeMillis(), 
                config.getParallelThreads());
        
        // 执行评估
        ModelEvaluationEngine.EvaluationResult result = 
            evaluator.evaluate(model, dataset, config.getEvaluationMetrics());
        
        // 输出结果
        System.out.println("模型评估结果:");
        System.out.println(result);
        
        // 保存结果
        saveEvaluationResult(result);
    }
    
    /**
     * 超参数优化
     */
    private void optimizeHyperparameters() {
        // 定义超参数空间
        HyperparameterOptimizationEngine.HyperparameterSpace space = 
            defineHyperparameterSpace();
        
        // 选择优化器
        HyperparameterOptimizationEngine.OptimizationResult result;
        switch (config.getOptimizerType().toLowerCase()) {
            case "gridsearch":
                HyperparameterOptimizationEngine.GridSearchOptimizer gridOptimizer = 
                    new HyperparameterOptimizationEngine.GridSearchOptimizer(
                        config.getMaxIterations(), 
                        config.getParallelThreads());
                result = gridOptimizer.optimize(
                    modelFactory, 
                    dataset, 
                    space, 
                    config.getEvaluationMetrics()[0], 
                    true);
                break;
            case "randomsearch":
                HyperparameterOptimizationEngine.RandomSearchOptimizer randomOptimizer = 
                    new HyperparameterOptimizationEngine.RandomSearchOptimizer(
                        config.getMaxIterations(), 
                        config.getParallelThreads(), 
                        System.currentTimeMillis());
                result = randomOptimizer.optimize(
                    modelFactory, 
                    dataset, 
                    space, 
                    config.getEvaluationMetrics()[0], 
                    true);
                break;
            default:
                throw new IllegalArgumentException("不支持的优化器类型: " + config.getOptimizerType());
        }
        
        // 输出结果
        System.out.println("超参数优化结果:");
        System.out.println(result);
        
        // 保存结果
        saveOptimizationResult(result);
    }
    
    /**
     * 定义超参数空间
     */
    private HyperparameterOptimizationEngine.HyperparameterSpace defineHyperparameterSpace() {
        HyperparameterOptimizationEngine.HyperparameterSpace space = 
            new HyperparameterOptimizationEngine.HyperparameterSpace();
        
        // 根据模型类型定义不同的超参数空间
        switch (config.getModelType().toLowerCase()) {
            case "logisticregression":
                space.addRange("learningRate", 
                    new HyperparameterOptimizationEngine.DoubleRange(0.001, 0.1, true))
                     .addRange("epochs", 
                    new HyperparameterOptimizationEngine.IntegerRange(10, 1000));
                break;
            case "decisiontree":
                space.addRange("maxDepth", 
                    new HyperparameterOptimizationEngine.IntegerRange(1, 20))
                     .addRange("minSamplesSplit", 
                    new HyperparameterOptimizationEngine.IntegerRange(2, 20));
                break;
        }
        
        // 添加通用参数
        space.addRange("numFeatures", 
            new HyperparameterOptimizationEngine.IntegerRange(dataset.getNumFeatures(), dataset.getNumFeatures()));
        
        return space;
    }
    
    /**
     * 保存评估结果
     */
    private void saveEvaluationResult(ModelEvaluationEngine.EvaluationResult result) {
        if (config.getOutputPath() != null) {
            try (PrintWriter writer = new PrintWriter(new FileWriter(
                    config.getOutputPath() + "/evaluation_result.txt"))) {
                writer.println(result.toString());
            } catch (IOException e) {
                System.err.println("保存评估结果失败: " + e.getMessage());
            }
        }
    }
    
    /**
     * 保存优化结果
     */
    private void saveOptimizationResult(HyperparameterOptimizationEngine.OptimizationResult result) {
        if (config.getOutputPath() != null) {
            try (PrintWriter writer = new PrintWriter(new FileWriter(
                    config.getOutputPath() + "/optimization_result.txt"))) {
                writer.println(result.toString());
                
                // 保存所有试验结果
                writer.println("\n详细试验结果:");
                for (HyperparameterOptimizationEngine.OptimizationTrial trial : result.getTrials()) {
                    writer.println(trial.toString());
                }
            } catch (IOException e) {
                System.err.println("保存优化结果失败: " + e.getMessage());
            }
        }
    }
    
    /**
     * 生成报告
     */
    private void generateReport() {
        if (config.getOutputPath() != null) {
            try (PrintWriter writer = new PrintWriter(new FileWriter(
                    config.getOutputPath() + "/system_report.md"))) {
                writer.println("# 模型评估与优化系统报告");
                writer.println();
                writer.println("## 系统配置");
                writer.println("- 数据路径: " + config.getDataPath());
                writer.println("- 模型类型: " + config.getModelType());
                writer.println("- 评估指标: " + Arrays.toString(config.getEvaluationMetrics()));
                writer.println("- 交叉验证折数: " + config.getCvFolds());
                writer.println("- 优化器类型: " + config.getOptimizerType());
                writer.println("- 最大迭代次数: " + config.getMaxIterations());
                writer.println();
                writer.println("## 数据集信息");
                writer.println("- 样本数: " + dataset.getNumSamples());
                writer.println("- 特征数: " + dataset.getNumFeatures());
                DataProcessor.DatasetStats stats = dataset.getStats();
                writer.println("- 类别数: " + stats.getNumClasses());
                writer.println("- 类别分布: " + stats.getClassDistribution());
                writer.println();
                writer.println("## 运行完成");
                writer.println("报告生成时间: " + new Date());
            } catch (IOException e) {
                System.err.println("生成报告失败: " + e.getMessage());
            }
        }
    }
    
    /**
     * 主方法 - 系统入口点
     */
    public static void main(String[] args) {
        try {
            // 创建系统配置
            SystemConfig config = new SystemConfig()
                .setDataPath("data/sample.csv")
                .setDelimiter(",")
                .setHasHeader(true)
                .setModelType("logisticregression")
                .setModelParam("learningRate", 0.01)
                .setModelParam("epochs", 100)
                .setEvaluationMetrics(new String[]{"accuracy", "precision", "recall", "f1"})
                .setCvFolds(5)
                .setOptimizerType("randomsearch")
                .setMaxIterations(20)
                .setParallelThreads(4)
                .setOutputPath("output");
            
            // 运行系统
            ModelEvaluationOptimizationSystem system = 
                new ModelEvaluationOptimizationSystem(config);
            system.run();
            
        } catch (Exception e) {
            System.err.println("系统运行失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

## 总结

在本章中，我们构建了一个完整的模型评估与优化系统，涵盖了以下关键组件：

1. **系统架构设计**：采用分层架构，确保模块化和可扩展性
2. **数据处理模块**：实现了数据加载、预处理和分割功能
3. **模型评估引擎**：支持交叉验证和多种评估指标
4. **超参数优化引擎**：提供了网格搜索和随机搜索两种优化方法
5. **模型接口和工厂**：支持多种模型类型，便于扩展
6. **系统主控制器**：协调整个流程的执行

这个系统具有以下特点：

- **模块化设计**：各组件独立，便于维护和扩展
- **并行处理**：支持多线程并行评估，提高效率
- **灵活配置**：支持多种模型、评估指标和优化算法
- **完整流程**：从数据加载到结果报告的全流程支持

通过这个综合项目，我们不仅实践了前面章节学到的理论知识，还构建了一个可以实际应用的系统。这个系统可以作为机器学习项目的基础框架，帮助开发者快速进行模型评估和优化工作。