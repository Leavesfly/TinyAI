# 6.2 模型状态管理：参数保存与加载

模型状态管理是深度学习框架中至关重要的功能，涉及模型参数的持久化存储、版本管理和跨平台兼容性。本节将深入探讨模型状态管理的设计理念和实现方案。

## 6.2.1 状态管理核心挑战

模型状态管理需要解决以下关键问题：
- **数据一致性**：确保保存和加载的参数完全一致
- **版本兼容**：支持不同版本间的模型迁移
- **存储效率**：优化存储空间和I/O性能
- **安全性**：防止模型参数被恶意篡改

## 6.2.2 ModelStateManager实现

```java
package com.tinyai.serialization;

import com.tinyai.core.Variable;
import com.tinyai.models.Model;
import java.io.*;
import java.util.*;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

/**
 * 模型状态管理器
 */
public class ModelStateManager {
    
    private static final String VERSION = "1.0";
    private static final int MAGIC_NUMBER = 0x54494E59;
    
    /**
     * 保存模型状态
     */
    public static void saveModel(Model model, String filePath, SaveConfig config) throws IOException {
        ModelState state = createModelState(model, config);
        
        try (FileOutputStream fos = new FileOutputStream(filePath);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            
            if (config.useCompression) {
                try (GZIPOutputStream gzos = new GZIPOutputStream(bos)) {
                    writeModelState(state, gzos);
                }
            } else {
                writeModelState(state, bos);
            }
        }
    }

    /**
     * 加载模型状态
     */
    public static void loadModel(Model model, String filePath, LoadConfig config) throws IOException {
        try (FileInputStream fis = new FileInputStream(filePath);
             BufferedInputStream bis = new BufferedInputStream(fis)) {
            
            ModelState state;
            if (isCompressed(filePath)) {
                try (GZIPInputStream gzis = new GZIPInputStream(bis)) {
                    state = readModelState(gzis);
                }
            } else {
                state = readModelState(bis);
            }
            
            applyModelState(model, state, config);
        }
    }

    private static ModelState createModelState(Model model, SaveConfig config) {
        ModelState state = new ModelState();
        state.version = VERSION;
        state.magicNumber = MAGIC_NUMBER;
        state.modelName = model.getModelName();
        state.timestamp = System.currentTimeMillis();
        
        // 保存参数
        if (config.saveParameters) {
            state.parameters = new HashMap<>();
            for (Map.Entry<String, Variable> entry : model.getParameters().entrySet()) {
                String key = entry.getKey();
                Variable param = entry.getValue();
                
                if (config.saveOnlyTrainable && !param.requiresGrad()) {
                    continue;
                }
                
                state.parameters.put(key, serializeVariable(param));
            }
        }
        
        // 保存缓冲区
        if (config.saveBuffers) {
            state.buffers = new HashMap<>();
            for (Map.Entry<String, Variable> entry : model.getBuffers().entrySet()) {
                state.buffers.put(entry.getKey(), serializeVariable(entry.getValue()));
            }
        }
        
        return state;
    }

    private static SerializedVariable serializeVariable(Variable var) {
        SerializedVariable serialized = new SerializedVariable();
        serialized.shape = var.getShape().clone();
        serialized.dtype = var.getDtype();
        serialized.device = var.getDevice();
        serialized.requiresGrad = var.requiresGrad();
        serialized.data = var.getData();
        return serialized;
    }

    private static void writeModelState(ModelState state, OutputStream os) throws IOException {
        try (ObjectOutputStream oos = new ObjectOutputStream(os)) {
            // 写入头部信息
            oos.writeInt(state.magicNumber);
            oos.writeUTF(state.version);
            oos.writeLong(state.timestamp);
            oos.writeUTF(state.modelName);
            
            // 写入参数
            if (state.parameters != null) {
                oos.writeInt(state.parameters.size());
                for (Map.Entry<String, SerializedVariable> entry : state.parameters.entrySet()) {
                    oos.writeUTF(entry.getKey());
                    oos.writeObject(entry.getValue());
                }
            } else {
                oos.writeInt(0);
            }
            
            // 写入缓冲区
            if (state.buffers != null) {
                oos.writeInt(state.buffers.size());
                for (Map.Entry<String, SerializedVariable> entry : state.buffers.entrySet()) {
                    oos.writeUTF(entry.getKey());
                    oos.writeObject(entry.getValue());
                }
            } else {
                oos.writeInt(0);
            }
        }
    }

    private static ModelState readModelState(InputStream is) throws IOException {
        try (ObjectInputStream ois = new ObjectInputStream(is)) {
            ModelState state = new ModelState();
            
            // 读取头部信息
            state.magicNumber = ois.readInt();
            if (state.magicNumber != MAGIC_NUMBER) {
                throw new IOException("Invalid file format");
            }
            
            state.version = ois.readUTF();
            state.timestamp = ois.readLong();
            state.modelName = ois.readUTF();
            
            // 读取参数
            int paramCount = ois.readInt();
            if (paramCount > 0) {
                state.parameters = new HashMap<>();
                for (int i = 0; i < paramCount; i++) {
                    String key = ois.readUTF();
                    SerializedVariable var = (SerializedVariable) ois.readObject();
                    state.parameters.put(key, var);
                }
            }
            
            // 读取缓冲区
            int bufferCount = ois.readInt();
            if (bufferCount > 0) {
                state.buffers = new HashMap<>();
                for (int i = 0; i < bufferCount; i++) {
                    String key = ois.readUTF();
                    SerializedVariable var = (SerializedVariable) ois.readObject();
                    state.buffers.put(key, var);
                }
            }
            
            return state;
        } catch (ClassNotFoundException e) {
            throw new IOException("Failed to read model state", e);
        }
    }

    private static void applyModelState(Model model, ModelState state, LoadConfig config) {
        // 加载参数
        if (state.parameters != null && config.loadParameters) {
            Map<String, Variable> modelParams = model.getParameters();
            
            for (Map.Entry<String, SerializedVariable> entry : state.parameters.entrySet()) {
                String key = entry.getKey();
                SerializedVariable serializedVar = entry.getValue();
                
                if (modelParams.containsKey(key)) {
                    Variable modelParam = modelParams.get(key);
                    Variable loadedParam = deserializeVariable(serializedVar);
                    
                    if (Arrays.equals(modelParam.getShape(), loadedParam.getShape())) {
                        modelParam.setData(loadedParam.getData());
                    } else if (config.allowShapeMismatch) {
                        System.out.println("Warning: Shape mismatch for parameter " + key);
                    } else {
                        throw new RuntimeException("Shape mismatch for parameter " + key);
                    }
                } else if (!config.strictMode) {
                    System.out.println("Warning: Ignoring unknown parameter " + key);
                }
            }
        }
        
        // 加载缓冲区
        if (state.buffers != null && config.loadBuffers) {
            Map<String, Variable> modelBuffers = model.getBuffers();
            for (Map.Entry<String, SerializedVariable> entry : state.buffers.entrySet()) {
                String key = entry.getKey();
                if (modelBuffers.containsKey(key)) {
                    Variable buffer = deserializeVariable(entry.getValue());
                    modelBuffers.get(key).setData(buffer.getData());
                }
            }
        }
    }

    private static Variable deserializeVariable(SerializedVariable serialized) {
        Variable var = new Variable(serialized.data, serialized.requiresGrad);
        var.setDevice(serialized.device);
        return var;
    }

    private static boolean isCompressed(String filePath) {
        return filePath.toLowerCase().endsWith(".gz");
    }

    // 配置类
    public static class SaveConfig implements Serializable {
        public boolean saveParameters = true;
        public boolean saveBuffers = true;
        public boolean saveOnlyTrainable = false;
        public boolean useCompression = true;

        public static SaveConfig defaultConfig() {
            return new SaveConfig();
        }

        public static SaveConfig compactConfig() {
            SaveConfig config = new SaveConfig();
            config.saveOnlyTrainable = true;
            config.useCompression = true;
            return config;
        }
    }

    public static class LoadConfig {
        public boolean loadParameters = true;
        public boolean loadBuffers = true;
        public boolean allowShapeMismatch = false;
        public boolean strictMode = false;

        public static LoadConfig defaultConfig() {
            return new LoadConfig();
        }
    }

    // 内部数据结构
    private static class ModelState {
        int magicNumber;
        String version;
        long timestamp;
        String modelName;
        Map<String, SerializedVariable> parameters;
        Map<String, SerializedVariable> buffers;
    }

    private static class SerializedVariable implements Serializable {
        int[] shape;
        String dtype;
        String device;
        boolean requiresGrad;
        Object data;
    }
}
```

## 6.2.3 检查点管理系统

```java
/**
 * 检查点管理系统
 */
public class CheckpointManager {
    private final String checkpointDir;
    private final int maxCheckpoints;
    private final Queue<CheckpointInfo> checkpoints;

    public CheckpointManager(String checkpointDir, int maxCheckpoints) {
        this.checkpointDir = checkpointDir;
        this.maxCheckpoints = maxCheckpoints;
        this.checkpoints = new LinkedList<>();
        createCheckpointDirectory();
    }

    /**
     * 保存检查点
     */
    public void saveCheckpoint(Model model, int epoch, double loss) throws IOException {
        String filename = String.format("checkpoint_epoch_%d_loss_%.4f.model", epoch, loss);
        String filepath = checkpointDir + "/" + filename;
        
        CheckpointInfo info = new CheckpointInfo(filename, filepath, epoch, loss, System.currentTimeMillis());
        
        // 保存模型
        ModelStateManager.SaveConfig config = ModelStateManager.SaveConfig.defaultConfig();
        ModelStateManager.saveModel(model, filepath, config);
        
        // 添加到检查点列表
        checkpoints.offer(info);
        
        // 清理旧检查点
        while (checkpoints.size() > maxCheckpoints) {
            CheckpointInfo oldest = checkpoints.poll();
            if (oldest != null) {
                new File(oldest.filepath).delete();
            }
        }
        
        System.out.println("Checkpoint saved: " + filename);
    }

    /**
     * 加载最佳检查点
     */
    public void loadBestCheckpoint(Model model) throws IOException {
        CheckpointInfo best = checkpoints.stream()
                .min((a, b) -> Double.compare(a.loss, b.loss))
                .orElse(null);
        
        if (best == null) {
            throw new IOException("No checkpoint found");
        }
        
        ModelStateManager.LoadConfig config = ModelStateManager.LoadConfig.defaultConfig();
        ModelStateManager.loadModel(model, best.filepath, config);
        
        System.out.println("Loaded best checkpoint: " + best.filename);
    }

    private void createCheckpointDirectory() {
        File dir = new File(checkpointDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }

    public static class CheckpointInfo {
        public final String filename;
        public final String filepath;
        public final int epoch;
        public final double loss;
        public final long timestamp;

        public CheckpointInfo(String filename, String filepath, int epoch, double loss, long timestamp) {
            this.filename = filename;
            this.filepath = filepath;
            this.epoch = epoch;
            this.loss = loss;
            this.timestamp = timestamp;
        }
    }
}
```

## 6.2.4 使用示例

```java
/**
 * 模型状态管理使用示例
 */
public class StateManagementExample {
    
    public static void demonstrateBasicSaveLoad() throws IOException {
        // 创建模型
        SequentialModel model = new SequentialModel("TestModel");
        model.add(new Dense(784, 128))
             .add(new ReLU())
             .add(new Dense(128, 10));
        
        model.initializeParameters(new int[]{1, 784});
        
        // 保存模型
        ModelStateManager.saveModel(model, "test_model.bin", 
                                   ModelStateManager.SaveConfig.defaultConfig());
        
        // 创建新模型实例并加载参数
        SequentialModel newModel = new SequentialModel("TestModel");
        newModel.add(new Dense(784, 128))
                .add(new ReLU())
                .add(new Dense(128, 10));
        
        newModel.initializeParameters(new int[]{1, 784});
        ModelStateManager.loadModel(newModel, "test_model.bin", 
                                   ModelStateManager.LoadConfig.defaultConfig());
        
        System.out.println("Model saved and loaded successfully!");
    }
    
    public static void demonstrateCheckpointManager() throws IOException {
        SequentialModel model = new SequentialModel("TrainingModel");
        model.add(new Dense(784, 128)).add(new ReLU()).add(new Dense(128, 10));
        model.initializeParameters(new int[]{1, 784});
        
        CheckpointManager checkpointManager = new CheckpointManager("./checkpoints", 5);
        
        // 模拟训练过程中保存检查点
        for (int epoch = 1; epoch <= 10; epoch++) {
            double loss = 1.0 / epoch; // 模拟损失下降
            
            if (epoch % 2 == 0) { // 每2个epoch保存一次
                checkpointManager.saveCheckpoint(model, epoch, loss);
            }
        }
        
        // 加载最佳检查点
        checkpointManager.loadBestCheckpoint(model);
    }
    
    public static void main(String[] args) {
        try {
            demonstrateBasicSaveLoad();
            demonstrateCheckpointManager();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

模型状态管理系统提供了完整的参数保存、加载和版本控制功能。通过合理的设计，该系统不仅保证了数据的一致性和安全性，还提供了灵活的配置选项来满足不同场景的需求。

下一节我们将探讨优化器集成，学习如何将各种梯度下降算法集成到训练框架中。