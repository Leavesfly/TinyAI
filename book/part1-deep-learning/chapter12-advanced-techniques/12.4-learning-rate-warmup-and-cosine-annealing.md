# 12.4 学习率预热与余弦退火

学习率是深度学习模型训练中最重要的超参数之一，直接影响模型的收敛速度和最终性能。学习率预热（Learning Rate Warmup）和余弦退火（Cosine Annealing）是两种现代深度学习中广泛使用的学习率调度策略，它们能够显著提升模型训练的稳定性和效果。

## 本节内容概览

- 学习率预热技术的原理和实现
- 余弦退火调度策略的数学基础
- 周期性学习率调度方法
- 自适应学习率调整技术

## 设计思考与技术理念

学习率调度的核心思想是根据训练过程的进展动态调整学习率，以在训练初期快速收敛，在训练后期精细调优。学习率预热通过在训练初期使用较小的学习率，避免模型在初始阶段因学习率过大而不稳定；余弦退火则通过周期性地调整学习率，帮助模型跳出局部最优并找到更好的解。

在设计学习率调度策略时，我们需要考虑以下因素：
1. **训练稳定性**：避免学习率过大导致训练不稳定
2. **收敛速度**：在训练初期使用较大的学习率加速收敛
3. **精细调优**：在训练后期使用较小的学习率进行精细调优
4. **跳出局部最优**：通过周期性调整帮助模型找到更好的解

## 12.4.1 学习率预热技术

学习率预热在训练初期逐步增加学习率，避免模型在训练开始时因学习率过大而不稳定。

### 预热原理

学习率预热的基本思想是：
1. 在前几个训练轮次中，使用较小的学习率
2. 逐步线性增加学习率到目标值
3. 在预热结束后使用正常的学习率调度策略

```java
/**
 * 学习率预热调度器
 */
public class LearningRateWarmup {
    
    /**
     * 线性预热调度器
     */
    public static class LinearWarmupScheduler {
        private double initialLearningRate;
        private double targetLearningRate;
        private int warmupSteps;
        private int currentStep;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param targetLearningRate 目标学习率
         * @param warmupSteps 预热步数
         */
        public LinearWarmupScheduler(double initialLearningRate, double targetLearningRate, int warmupSteps) {
            this.initialLearningRate = initialLearningRate;
            this.targetLearningRate = targetLearningRate;
            this.warmupSteps = warmupSteps;
            this.currentStep = 0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            if (currentStep < warmupSteps) {
                // 线性预热
                double progress = (double) currentStep / warmupSteps;
                return initialLearningRate + (targetLearningRate - initialLearningRate) * progress;
            } else {
                // 预热结束后返回目标学习率
                return targetLearningRate;
            }
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            currentStep = 0;
        }
        
        /**
         * 获取当前步数
         */
        public int getCurrentStep() {
            return currentStep;
        }
        
        /**
         * 获取预热步数
         */
        public int getWarmupSteps() {
            return warmupSteps;
        }
    }
    
    /**
     * 指数预热调度器
     */
    public static class ExponentialWarmupScheduler {
        private double initialLearningRate;
        private double targetLearningRate;
        private int warmupSteps;
        private int currentStep;
        private double growthRate;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param targetLearningRate 目标学习率
         * @param warmupSteps 预热步数
         */
        public ExponentialWarmupScheduler(double initialLearningRate, double targetLearningRate, int warmupSteps) {
            this.initialLearningRate = initialLearningRate;
            this.targetLearningRate = targetLearningRate;
            this.warmupSteps = warmupSteps;
            this.currentStep = 0;
            
            // 计算增长率
            if (warmupSteps > 0) {
                this.growthRate = Math.pow(targetLearningRate / initialLearningRate, 1.0 / warmupSteps);
            } else {
                this.growthRate = 1.0;
            }
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            if (currentStep < warmupSteps) {
                // 指数预热
                return initialLearningRate * Math.pow(growthRate, currentStep);
            } else {
                // 预热结束后返回目标学习率
                return targetLearningRate;
            }
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            currentStep = 0;
        }
    }
    
    /**
     * 余弦预热调度器
     */
    public static class CosineWarmupScheduler {
        private double initialLearningRate;
        private double targetLearningRate;
        private int warmupSteps;
        private int currentStep;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param targetLearningRate 目标学习率
         * @param warmupSteps 预热步数
         */
        public CosineWarmupScheduler(double initialLearningRate, double targetLearningRate, int warmupSteps) {
            this.initialLearningRate = initialLearningRate;
            this.targetLearningRate = targetLearningRate;
            this.warmupSteps = warmupSteps;
            this.currentStep = 0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            if (currentStep < warmupSteps) {
                // 余弦预热
                double progress = (double) currentStep / warmupSteps;
                return initialLearningRate + (targetLearningRate - initialLearningRate) * 
                       (1 - Math.cos(Math.PI * progress)) / 2;
            } else {
                // 预热结束后返回目标学习率
                return targetLearningRate;
            }
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            currentStep = 0;
        }
    }
}
```

## 12.4.2 余弦退火调度

余弦退火通过余弦函数周期性地调整学习率，帮助模型跳出局部最优。

### 余弦退火原理

余弦退火的学习率计算公式为：

$$\eta_t = \eta_{min} + \frac{1}{2}(\eta_{max} - \eta_{min})(1 + \cos(\frac{T_{cur}}{T_{max}}\pi))$$

其中：
- $\eta_t$ 是当前学习率
- $\eta_{max}$ 是最大学习率
- $\eta_{min}$ 是最小学习率
- $T_{cur}$ 是当前周期内的步数
- $T_{max}$ 是周期长度

```java
/**
 * 余弦退火调度器
 */
public class CosineAnnealingScheduler {
    
    /**
     * 基础余弦退火调度器
     */
    public static class BasicCosineAnnealingScheduler {
        private double etaMax;
        private double etaMin;
        private int tMax;
        private int tCur;
        
        /**
         * 构造函数
         * @param etaMax 最大学习率
         * @param etaMin 最小学习率
         * @param tMax 周期长度
         */
        public BasicCosineAnnealingScheduler(double etaMax, double etaMin, int tMax) {
            this.etaMax = etaMax;
            this.etaMin = etaMin;
            this.tMax = tMax;
            this.tCur = 0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            double cosineValue = Math.cos(Math.PI * tCur / tMax);
            return etaMin + 0.5 * (etaMax - etaMin) * (1 + cosineValue);
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            tCur = (tCur + 1) % tMax;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            tCur = 0;
        }
        
        /**
         * 获取当前周期步数
         */
        public int getCurrentStep() {
            return tCur;
        }
        
        /**
         * 获取周期长度
         */
        public int getTMax() {
            return tMax;
        }
    }
    
    /**
     * 带重启的余弦退火调度器
     */
    public static class CosineAnnealingWithRestartsScheduler {
        private double etaMax;
        private double etaMin;
        private int tMax;
        private int tCur;
        private int currentRestart;
        private int[] restartPoints;
        
        /**
         * 构造函数
         * @param etaMax 最大学习率
         * @param etaMin 最小学习率
         * @param tMax 初始周期长度
         * @param restartPoints 重启点数组
         */
        public CosineAnnealingWithRestartsScheduler(double etaMax, double etaMin, int tMax, int[] restartPoints) {
            this.etaMax = etaMax;
            this.etaMin = etaMin;
            this.tMax = tMax;
            this.tCur = 0;
            this.currentRestart = 0;
            this.restartPoints = restartPoints != null ? restartPoints.clone() : new int[0];
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            // 计算当前周期的周期长度
            int currentTMax = getCurrentTMax();
            
            // 计算余弦值
            double cosineValue = Math.cos(Math.PI * tCur / currentTMax);
            return etaMin + 0.5 * (etaMax - etaMin) * (1 + cosineValue);
        }
        
        /**
         * 获取当前周期长度
         */
        private int getCurrentTMax() {
            if (currentRestart < restartPoints.length) {
                return restartPoints[currentRestart];
            } else {
                // 如果没有更多重启点，使用最后一个周期长度
                return restartPoints.length > 0 ? restartPoints[restartPoints.length - 1] : tMax;
            }
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            tCur++;
            
            // 检查是否需要重启
            int currentTMax = getCurrentTMax();
            if (tCur >= currentTMax) {
                tCur = 0;
                currentRestart++;
            }
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            tCur = 0;
            currentRestart = 0;
        }
    }
    
    /**
     * 余弦退火衰减调度器
     */
    public static class CosineAnnealingDecayScheduler {
        private double etaMax;
        private double etaMin;
        private int tMax;
        private int tCur;
        private double decayRate;
        
        /**
         * 构造函数
         * @param etaMax 初始最大学习率
         * @param etaMin 最小学习率
         * @param tMax 周期长度
         * @param decayRate 衰减率
         */
        public CosineAnnealingDecayScheduler(double etaMax, double etaMin, int tMax, double decayRate) {
            this.etaMax = etaMax;
            this.etaMin = etaMin;
            this.tMax = tMax;
            this.tCur = 0;
            this.decayRate = decayRate;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            // 计算衰减后的最大学习率
            double currentEtaMax = etaMax * Math.pow(decayRate, tCur / tMax);
            
            // 计算余弦值
            double cosineValue = Math.cos(Math.PI * (tCur % tMax) / tMax);
            return etaMin + 0.5 * (currentEtaMax - etaMin) * (1 + cosineValue);
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            tCur++;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            tCur = 0;
        }
    }
}
```

## 12.4.3 周期性学习率调度

周期性学习率调度通过周期性地调整学习率范围，帮助模型探索不同的参数空间。

```java
/**
 * 周期性学习率调度器
 */
public class CyclicalLearningRateScheduler {
    
    /**
     * 三角形周期调度器
     */
    public static class TriangularScheduler {
        private double baseLearningRate;
        private double maxLearningRate;
        private int stepSize;
        private int currentStep;
        private double scaleFunctionValue;
        
        /**
         * 构造函数
         * @param baseLearningRate 基础学习率
         * @param maxLearningRate 最大学习率
         * @param stepSize 半周期步数
         */
        public TriangularScheduler(double baseLearningRate, double maxLearningRate, int stepSize) {
            this.baseLearningRate = baseLearningRate;
            this.maxLearningRate = maxLearningRate;
            this.stepSize = stepSize;
            this.currentStep = 0;
            this.scaleFunctionValue = 1.0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            // 计算当前周期内的位置
            int cycle = (int) Math.floor(1 + (double) currentStep / (2 * stepSize));
            double x = Math.abs((double) currentStep / stepSize - 2 * cycle + 1);
            
            // 计算学习率
            double learningRate = baseLearningRate + (maxLearningRate - baseLearningRate) * 
                                Math.max(0, (1 - x)) * scaleFunctionValue;
            
            return learningRate;
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
        
        /**
         * 设置缩放函数值
         */
        public void setScaleFunctionValue(double scaleFunctionValue) {
            this.scaleFunctionValue = scaleFunctionValue;
        }
    }
    
    /**
     * 三角形2周期调度器
     */
    public static class Triangular2Scheduler {
        private double baseLearningRate;
        private double maxLearningRate;
        private int stepSize;
        private int currentStep;
        
        /**
         * 构造函数
         * @param baseLearningRate 基础学习率
         * @param maxLearningRate 最大学习率
         * @param stepSize 半周期步数
         */
        public Triangular2Scheduler(double baseLearningRate, double maxLearningRate, int stepSize) {
            this.baseLearningRate = baseLearningRate;
            this.maxLearningRate = maxLearningRate;
            this.stepSize = stepSize;
            this.currentStep = 0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            // 计算当前周期内的位置
            int cycle = (int) Math.floor(1 + (double) currentStep / (2 * stepSize));
            double x = Math.abs((double) currentStep / stepSize - 2 * cycle + 1);
            
            // 计算缩放因子
            double scale = Math.pow(0.5, cycle - 1);
            
            // 计算学习率
            double learningRate = baseLearningRate + (maxLearningRate - baseLearningRate) * 
                                Math.max(0, (1 - x)) * scale;
            
            return learningRate;
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
    }
    
    /**
     * 指数范围周期调度器
     */
    public static class ExponentialRangeScheduler {
        private double baseLearningRate;
        private double maxLearningRate;
        private int stepSize;
        private int currentStep;
        private double gamma;
        
        /**
         * 构造函数
         * @param baseLearningRate 基础学习率
         * @param maxLearningRate 最大学习率
         * @param stepSize 半周期步数
         * @param gamma 指数衰减因子
         */
        public ExponentialRangeScheduler(double baseLearningRate, double maxLearningRate, 
                                       int stepSize, double gamma) {
            this.baseLearningRate = baseLearningRate;
            this.maxLearningRate = maxLearningRate;
            this.stepSize = stepSize;
            this.currentStep = 0;
            this.gamma = gamma;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            // 计算当前周期内的位置
            int cycle = (int) Math.floor(1 + (double) currentStep / (2 * stepSize));
            double x = Math.abs((double) currentStep / stepSize - 2 * cycle + 1);
            
            // 计算指数衰减因子
            double scale = Math.pow(gamma, currentStep);
            
            // 计算学习率
            double learningRate = baseLearningRate + (maxLearningRate - baseLearningRate) * 
                                Math.max(0, (1 - x)) * scale;
            
            return learningRate;
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
        }
    }
}
```

## 12.4.4 自适应学习率调整

自适应学习率调整根据训练过程中的性能指标动态调整学习率。

```java
/**
 * 自适应学习率调整器
 */
public class AdaptiveLearningRateScheduler {
    
    /**
     * 基于验证损失的调度器
     */
    public static class ValidationBasedScheduler {
        private double initialLearningRate;
        private double currentLearningRate;
        private double decayFactor;
        private int patience;
        private double minDelta;
        private int patienceCounter;
        private double bestLoss;
        private boolean bestLossSet;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param decayFactor 衰减因子
         * @param patience 容忍轮次数
         * @param minDelta 最小改善阈值
         */
        public ValidationBasedScheduler(double initialLearningRate, double decayFactor, 
                                      int patience, double minDelta) {
            this.initialLearningRate = initialLearningRate;
            this.currentLearningRate = initialLearningRate;
            this.decayFactor = decayFactor;
            this.patience = patience;
            this.minDelta = minDelta;
            this.patienceCounter = 0;
            this.bestLoss = Double.MAX_VALUE;
            this.bestLossSet = false;
        }
        
        /**
         * 根据验证损失调整学习率
         * @param validationLoss 当前验证损失
         * @return 调整后的学习率
         */
        public double adjustLearningRate(double validationLoss) {
            if (!bestLossSet || validationLoss < bestLoss - minDelta) {
                // 有显著改善
                bestLoss = validationLoss;
                bestLossSet = true;
                patienceCounter = 0;
            } else {
                // 没有改善
                patienceCounter++;
                if (patienceCounter >= patience) {
                    // 衰减学习率
                    currentLearningRate *= decayFactor;
                    patienceCounter = 0;
                    System.out.println("学习率衰减至: " + currentLearningRate);
                }
            }
            
            return currentLearningRate;
        }
        
        /**
         * 获取当前学习率
         */
        public double getCurrentLearningRate() {
            return currentLearningRate;
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            currentLearningRate = initialLearningRate;
            patienceCounter = 0;
            bestLoss = Double.MAX_VALUE;
            bestLossSet = false;
        }
    }
    
    /**
     * 基于训练损失的调度器
     */
    public static class TrainingLossBasedScheduler {
        private double initialLearningRate;
        private double currentLearningRate;
        private double decayFactor;
        private double lossThreshold;
        private double previousLoss;
        private boolean previousLossSet;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param decayFactor 衰减因子
         * @param lossThreshold 损失阈值
         */
        public TrainingLossBasedScheduler(double initialLearningRate, double decayFactor, 
                                        double lossThreshold) {
            this.initialLearningRate = initialLearningRate;
            this.currentLearningRate = initialLearningRate;
            this.decayFactor = decayFactor;
            this.lossThreshold = lossThreshold;
            this.previousLoss = 0.0;
            this.previousLossSet = false;
        }
        
        /**
         * 根据训练损失调整学习率
         * @param trainingLoss 当前训练损失
         * @return 调整后的学习率
         */
        public double adjustLearningRate(double trainingLoss) {
            if (previousLossSet) {
                double lossChange = previousLoss - trainingLoss;
                if (lossChange < lossThreshold) {
                    // 损失改善不足，衰减学习率
                    currentLearningRate *= decayFactor;
                    System.out.println("学习率衰减至: " + currentLearningRate);
                }
            }
            
            previousLoss = trainingLoss;
            previousLossSet = true;
            
            return currentLearningRate;
        }
        
        /**
         * 获取当前学习率
         */
        public double getCurrentLearningRate() {
            return currentLearningRate;
        }
    }
    
    /**
     * 基于梯度范数的调度器
     */
    public static class GradientNormBasedScheduler {
        private double initialLearningRate;
        private double currentLearningRate;
        private double increaseFactor;
        private double decreaseFactor;
        private double gradientThreshold;
        
        /**
         * 构造函数
         * @param initialLearningRate 初始学习率
         * @param increaseFactor 增加因子
         * @param decreaseFactor 衰减因子
         * @param gradientThreshold 梯度范数阈值
         */
        public GradientNormBasedScheduler(double initialLearningRate, double increaseFactor, 
                                        double decreaseFactor, double gradientThreshold) {
            this.initialLearningRate = initialLearningRate;
            this.currentLearningRate = initialLearningRate;
            this.increaseFactor = increaseFactor;
            this.decreaseFactor = decreaseFactor;
            this.gradientThreshold = gradientThreshold;
        }
        
        /**
         * 根据梯度范数调整学习率
         * @param gradientNorm 当前梯度范数
         * @return 调整后的学习率
         */
        public double adjustLearningRate(double gradientNorm) {
            if (gradientNorm < gradientThreshold) {
                // 梯度范数较小，增加学习率
                currentLearningRate *= increaseFactor;
                System.out.println("学习率增加至: " + currentLearningRate);
            } else if (gradientNorm > gradientThreshold * 2) {
                // 梯度范数较大，减少学习率
                currentLearningRate *= decreaseFactor;
                System.out.println("学习率减少至: " + currentLearningRate);
            }
            
            return currentLearningRate;
        }
        
        /**
         * 获取当前学习率
         */
        public double getCurrentLearningRate() {
            return currentLearningRate;
        }
    }
}
```

## 12.4.5 综合调度器与最佳实践

```java
/**
 * 综合学习率调度器
 */
public class ComprehensiveLRScheduler {
    
    /**
     * 组合调度器
     */
    public static class CombinedScheduler {
        private LearningRateWarmup.LinearWarmupScheduler warmupScheduler;
        private CosineAnnealingScheduler.BasicCosineAnnealingScheduler cosineScheduler;
        private boolean inWarmupPhase;
        private int totalSteps;
        private int currentStep;
        
        /**
         * 构造函数
         * @param initialLr 初始学习率
         * @param targetLr 目标学习率
         * @param warmupSteps 预热步数
         * @param cosineSteps 余弦退火步数
         */
        public CombinedScheduler(double initialLr, double targetLr, int warmupSteps, int cosineSteps) {
            this.warmupScheduler = new LearningRateWarmup.LinearWarmupScheduler(
                initialLr, targetLr, warmupSteps);
            this.cosineScheduler = new CosineAnnealingScheduler.BasicCosineAnnealingScheduler(
                targetLr, initialLr * 0.1, cosineSteps);
            this.inWarmupPhase = true;
            this.totalSteps = warmupSteps + cosineSteps;
            this.currentStep = 0;
        }
        
        /**
         * 获取当前学习率
         * @return 当前学习率
         */
        public double getCurrentLearningRate() {
            if (inWarmupPhase) {
                return warmupScheduler.getCurrentLearningRate();
            } else {
                return cosineScheduler.getCurrentLearningRate();
            }
        }
        
        /**
         * 进入下一步
         */
        public void step() {
            currentStep++;
            
            if (inWarmupPhase) {
                warmupScheduler.step();
                if (warmupScheduler.getCurrentStep() >= warmupScheduler.getWarmupSteps()) {
                    inWarmupPhase = false;
                    // 重置余弦调度器
                    cosineScheduler.reset();
                }
            } else {
                cosineScheduler.step();
            }
        }
        
        /**
         * 重置调度器
         */
        public void reset() {
            warmupScheduler.reset();
            cosineScheduler.reset();
            inWarmupPhase = true;
            currentStep = 0;
        }
    }
    
    /**
     * 学习率调度器工厂
     */
    public static class SchedulerFactory {
        
        /**
         * 创建线性预热调度器
         */
        public static LearningRateWarmup.LinearWarmupScheduler createLinearWarmup(
                double initialLr, double targetLr, int warmupSteps) {
            return new LearningRateWarmup.LinearWarmupScheduler(initialLr, targetLr, warmupSteps);
        }
        
        /**
         * 创建余弦退火调度器
         */
        public static CosineAnnealingScheduler.BasicCosineAnnealingScheduler createCosineAnnealing(
                double etaMax, double etaMin, int tMax) {
            return new CosineAnnealingScheduler.BasicCosineAnnealingScheduler(etaMax, etaMin, tMax);
        }
        
        /**
         * 创建组合调度器
         */
        public static CombinedScheduler createCombinedScheduler(
                double initialLr, double targetLr, int warmupSteps, int cosineSteps) {
            return new CombinedScheduler(initialLr, targetLr, warmupSteps, cosineSteps);
        }
    }
    
    /**
     * 学习率调度器演示
     */
    public static class LRSchedulerDemo {
        
        /**
         * 演示线性预热
         */
        public static void demonstrateLinearWarmup() {
            System.out.println("=== 线性预热演示 ===");
            
            LearningRateWarmup.LinearWarmupScheduler scheduler = 
                new LearningRateWarmup.LinearWarmupScheduler(0.001, 0.01, 10);
            
            for (int i = 0; i < 15; i++) {
                double lr = scheduler.getCurrentLearningRate();
                System.out.printf("步骤 %d: 学习率 = %.6f%n", i, lr);
                scheduler.step();
            }
            System.out.println();
        }
        
        /**
         * 演示余弦退火
         */
        public static void demonstrateCosineAnnealing() {
            System.out.println("=== 余弦退火演示 ===");
            
            CosineAnnealingScheduler.BasicCosineAnnealingScheduler scheduler = 
                new CosineAnnealingScheduler.BasicCosineAnnealingScheduler(0.01, 0.001, 20);
            
            for (int i = 0; i < 25; i++) {
                double lr = scheduler.getCurrentLearningRate();
                System.out.printf("步骤 %d: 学习率 = %.6f%n", i, lr);
                scheduler.step();
            }
            System.out.println();
        }
        
        /**
         * 演示组合调度器
         */
        public static void demonstrateCombinedScheduler() {
            System.out.println("=== 组合调度器演示 ===");
            
            CombinedScheduler scheduler = new CombinedScheduler(0.001, 0.01, 10, 20);
            
            for (int i = 0; i < 35; i++) {
                double lr = scheduler.getCurrentLearningRate();
                System.out.printf("步骤 %d: 学习率 = %.6f%n", i, lr);
                scheduler.step();
            }
            System.out.println();
        }
        
        /**
         * 演示周期性学习率
         */
        public static void demonstrateCyclicalLR() {
            System.out.println("=== 周期性学习率演示 ===");
            
            CyclicalLearningRateScheduler.TriangularScheduler scheduler = 
                new CyclicalLearningRateScheduler.TriangularScheduler(0.001, 0.01, 10);
            
            for (int i = 0; i < 30; i++) {
                double lr = scheduler.getCurrentLearningRate();
                System.out.printf("步骤 %d: 学习率 = %.6f%n", i, lr);
                scheduler.step();
            }
            System.out.println();
        }
        
        /**
         * 演示自适应学习率
         */
        public static void demonstrateAdaptiveLR() {
            System.out.println("=== 自适应学习率演示 ===");
            
            AdaptiveLearningRateScheduler.ValidationBasedScheduler scheduler = 
                new AdaptiveLearningRateScheduler.ValidationBasedScheduler(0.01, 0.5, 3, 0.01);
            
            // 模拟验证损失序列
            double[] validationLosses = {1.0, 0.9, 0.85, 0.84, 0.84, 0.83, 0.83, 0.83, 0.82};
            
            for (int i = 0; i < validationLosses.length; i++) {
                double lr = scheduler.adjustLearningRate(validationLosses[i]);
                System.out.printf("轮次 %d: 验证损失 = %.4f, 学习率 = %.6f%n", 
                                i + 1, validationLosses[i], lr);
            }
            System.out.println();
        }
    }
}
```

## 综合示例与最佳实践

```java
/**
 * 学习率调度综合示例
 */
public class LearningRateSchedulingExample {
    
    public static void main(String[] args) {
        // 演示各种学习率调度策略
        demonstrateAllSchedulers();
        
        // 演示实际应用场景
        demonstratePracticalUsage();
    }
    
    /**
     * 演示所有调度器
     */
    private static void demonstrateAllSchedulers() {
        ComprehensiveLRScheduler.LRSchedulerDemo.demonstrateLinearWarmup();
        ComprehensiveLRScheduler.LRSchedulerDemo.demonstrateCosineAnnealing();
        ComprehensiveLRScheduler.LRSchedulerDemo.demonstrateCombinedScheduler();
        ComprehensiveLRScheduler.LRSchedulerDemo.demonstrateCyclicalLR();
        ComprehensiveLRScheduler.LRSchedulerDemo.demonstrateAdaptiveLR();
    }
    
    /**
     * 演示实际应用场景
     */
    private static void demonstratePracticalUsage() {
        System.out.println("=== 实际应用场景演示 ===");
        
        // 创建组合调度器用于实际训练
        ComprehensiveLRScheduler.CombinedScheduler scheduler = 
            ComprehensiveLRScheduler.SchedulerFactory.createCombinedScheduler(
                0.001, 0.01, 100, 900);
        
        // 模拟训练过程
        int totalEpochs = 20;
        int stepsPerEpoch = 50;
        
        System.out.println("模拟训练过程:");
        for (int epoch = 0; epoch < totalEpochs; epoch++) {
            double epochLrSum = 0.0;
            int stepsInEpoch = 0;
            
            for (int step = 0; step < stepsPerEpoch; step++) {
                double lr = scheduler.getCurrentLearningRate();
                epochLrSum += lr;
                stepsInEpoch++;
                scheduler.step();
            }
            
            double avgLr = epochLrSum / stepsInEpoch;
            System.out.printf("轮次 %d: 平均学习率 = %.6f%n", epoch + 1, avgLr);
        }
        
        System.out.println();
    }
}
```

## 总结

本节详细介绍了现代深度学习中的重要学习率调度技术：

1. **学习率预热**：
   - **线性预热**：在训练初期线性增加学习率
   - **指数预热**：按指数函数增加学习率
   - **余弦预热**：按余弦函数增加学习率

2. **余弦退火调度**：
   - **基础余弦退火**：周期性地按余弦函数调整学习率
   - **带重启的余弦退火**：在周期结束后重启学习率
   - **衰减余弦退火**：在每个周期中衰减学习率范围

3. **周期性学习率调度**：
   - **三角形调度**：在固定范围内周期性调整学习率
   - **三角形2调度**：每个周期衰减学习率范围
   - **指数范围调度**：按指数函数衰减学习率范围

4. **自适应学习率调整**：
   - **基于验证损失**：根据验证集性能调整学习率
   - **基于训练损失**：根据训练集损失调整学习率
   - **基于梯度范数**：根据梯度大小调整学习率

5. **最佳实践**：
   - 结合多种调度策略以获得最佳效果
   - 根据具体任务和数据集特点选择合适的调度器
   - 监控训练过程中的学习率变化和模型性能

这些学习率调度技术能够显著提升模型训练的稳定性和最终性能，在实际应用中应根据具体场景选择合适的策略组合。