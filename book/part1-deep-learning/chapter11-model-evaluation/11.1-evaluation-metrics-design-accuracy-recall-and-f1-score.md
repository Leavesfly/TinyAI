# 11.1 评估指标设计：准确率、召回率与F1分数

> **本节学习目标**：掌握分类问题的评估指标体系，理解各种评估指标的含义和适用场景

## 内容概览

在机器学习项目中，选择合适的评估指标对于衡量模型性能至关重要。不同的问题类型需要不同的评估指标，即使是同一类型的问题，在不同的业务场景下也可能需要关注不同的指标。本节将详细介绍分类问题中最常用的评估指标，包括准确率、精确率、召回率、F1分数等，并探讨它们在实际应用中的意义。

## 11.1.1 分类问题评估指标概述

分类问题是机器学习中最常见的任务类型之一，其目标是将输入样本分配到预定义的类别中。评估分类模型的性能需要使用适当的指标来衡量模型预测结果与真实标签之间的一致性。

### 基本概念

在二分类问题中，我们通常将类别标记为正类（Positive）和负类（Negative）。模型的预测结果与真实标签的组合可以分为四种情况：

1. **真正例（True Positive, TP）**：模型预测为正类，实际也是正类
2. **假正例（False Positive, FP）**：模型预测为正类，实际是负类
3. **真负例（True Negative, TN）**：模型预测为负类，实际也是负类
4. **假负例（False Negative, FN）**：模型预测为负类，实际是正类

这些基本概念构成了混淆矩阵的基础，是理解和计算各种评估指标的前提。

### 混淆矩阵实现

```java
/**
 * 混淆矩阵实现
 */
public class ConfusionMatrix {
    private int tp; // 真正例
    private int fp; // 假正例
    private int tn; // 真负例
    private int fn; // 假负例
    
    /**
     * 构造函数
     */
    public ConfusionMatrix() {
        this.tp = 0;
        this.fp = 0;
        this.tn = 0;
        this.fn = 0;
    }
    
    /**
     * 根据预测结果和真实标签更新混淆矩阵
     */
    public void update(int[] predictions, int[] trueLabels) {
        if (predictions.length != trueLabels.length) {
            throw new IllegalArgumentException("预测结果和真实标签长度不匹配");
        }
        
        for (int i = 0; i < predictions.length; i++) {
            update(predictions[i], trueLabels[i]);
        }
    }
    
    /**
     * 更新单个样本的混淆矩阵
     */
    public void update(int prediction, int trueLabel) {
        if (prediction == 1 && trueLabel == 1) {
            tp++;
        } else if (prediction == 1 && trueLabel == 0) {
            fp++;
        } else if (prediction == 0 && trueLabel == 0) {
            tn++;
        } else if (prediction == 0 && trueLabel == 1) {
            fn++;
        }
    }
    
    /**
     * 从预测概率和阈值构建混淆矩阵
     */
    public void updateFromProbabilities(double[] probabilities, int[] trueLabels, double threshold) {
        if (probabilities.length != trueLabels.length) {
            throw new IllegalArgumentException("概率数组和真实标签长度不匹配");
        }
        
        for (int i = 0; i < probabilities.length; i++) {
            int prediction = probabilities[i] >= threshold ? 1 : 0;
            update(prediction, trueLabels[i]);
        }
    }
    
    /**
     * 获取真正例数
     */
    public int getTruePositives() {
        return tp;
    }
    
    /**
     * 获取假正例数
     */
    public int getFalsePositives() {
        return fp;
    }
    
    /**
     * 获取真负例数
     */
    public int getTrueNegatives() {
        return tn;
    }
    
    /**
     * 获取假负例数
     */
    public int getFalseNegatives() {
        return fn;
    }
    
    /**
     * 计算准确率
     */
    public double getAccuracy() {
        int total = tp + fp + tn + fn;
        return total == 0 ? 0 : (double) (tp + tn) / total;
    }
    
    /**
     * 计算精确率
     */
    public double getPrecision() {
        int predictedPositives = tp + fp;
        return predictedPositives == 0 ? 0 : (double) tp / predictedPositives;
    }
    
    /**
     * 计算召回率
     */
    public double getRecall() {
        int actualPositives = tp + fn;
        return actualPositives == 0 ? 0 : (double) tp / actualPositives;
    }
    
    /**
     * 计算F1分数
     */
    public double getF1Score() {
        double precision = getPrecision();
        double recall = getRecall();
        double sum = precision + recall;
        return sum == 0 ? 0 : 2 * precision * recall / sum;
    }
    
    /**
     * 计算特异性
     */
    public double getSpecificity() {
        int actualNegatives = tn + fp;
        return actualNegatives == 0 ? 0 : (double) tn / actualNegatives;
    }
    
    /**
     * 计算FPR（假正例率）
     */
    public double getFalsePositiveRate() {
        int actualNegatives = tn + fp;
        return actualNegatives == 0 ? 0 : (double) fp / actualNegatives;
    }
    
    /**
     * 打印混淆矩阵
     */
    public void printMatrix() {
        System.out.println("混淆矩阵:");
        System.out.println("真实\\预测\t负类\t正类");
        System.out.printf("负类\t\t%d\t%d%n", tn, fp);
        System.out.printf("正类\t\t%d\t%d%n", fn, tp);
    }
    
    /**
     * 打印所有评估指标
     */
    public void printMetrics() {
        System.out.println("=== 评估指标 ===");
        System.out.printf("准确率 (Accuracy): %.4f%n", getAccuracy());
        System.out.printf("精确率 (Precision): %.4f%n", getPrecision());
        System.out.printf("召回率 (Recall): %.4f%n", getRecall());
        System.out.printf("F1分数 (F1-Score): %.4f%n", getF1Score());
        System.out.printf("特异性 (Specificity): %.4f%n", getSpecificity());
        System.out.printf("假正例率 (FPR): %.4f%n", getFalsePositiveRate());
    }
    
    /**
     * 重置混淆矩阵
     */
    public void reset() {
        this.tp = 0;
        this.fp = 0;
        this.tn = 0;
        this.fn = 0;
    }
    
    @Override
    public String toString() {
        return String.format("ConfusionMatrix[TP=%d, FP=%d, TN=%d, FN=%d]", tp, fp, tn, fn);
    }
}
```

## 11.1.2 准确率（Accuracy）

准确率是最直观的评估指标，表示模型预测正确的样本占总样本数的比例。

### 数学定义

$$Accuracy = \frac{TP + TN}{TP + FP + TN + FN}$$

### 特点与局限性

准确率虽然是最常用的指标，但它在某些情况下可能会产生误导：

1. **优点**：
   - 直观易懂，便于解释
   - 适用于类别平衡的数据集

2. **缺点**：
   - 在类别不平衡的数据集中容易产生误导
   - 无法反映模型在不同类别上的表现差异

### 准确率计算器实现

```java
/**
 * 准确率计算器
 */
public class AccuracyCalculator {
    
    /**
     * 计算准确率
     */
    public static double calculateAccuracy(int[] predictions, int[] trueLabels) {
        if (predictions.length != trueLabels.length) {
            throw new IllegalArgumentException("预测结果和真实标签长度不匹配");
        }
        
        int correct = 0;
        for (int i = 0; i < predictions.length; i++) {
            if (predictions[i] == trueLabels[i]) {
                correct++;
            }
        }
        
        return (double) correct / predictions.length;
    }
    
    /**
     * 计算加权准确率（多分类）
     */
    public static double calculateWeightedAccuracy(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        int totalSamples = 0;
        int correctSamples = 0;
        
        // 计算总样本数和正确分类样本数
        for (int i = 0; i < numClasses; i++) {
            for (int j = 0; j < numClasses; j++) {
                totalSamples += confusionMatrix[i][j];
                if (i == j) {
                    correctSamples += confusionMatrix[i][j];
                }
            }
        }
        
        return totalSamples == 0 ? 0 : (double) correctSamples / totalSamples;
    }
    
    /**
     * 计算宏平均准确率（多分类）
     */
    public static double calculateMacroAccuracy(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double sumAccuracy = 0;
        int validClasses = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int truePositives = confusionMatrix[i][i];
            int totalClassSamples = 0;
            
            // 计算该类别的总样本数
            for (int j = 0; j < numClasses; j++) {
                totalClassSamples += confusionMatrix[i][j];
            }
            
            if (totalClassSamples > 0) {
                double classAccuracy = (double) truePositives / totalClassSamples;
                sumAccuracy += classAccuracy;
                validClasses++;
            }
        }
        
        return validClasses == 0 ? 0 : sumAccuracy / validClasses;
    }
    
    /**
     * 评估准确率的置信区间
     */
    public static double[] calculateConfidenceInterval(double accuracy, int sampleSize, double confidenceLevel) {
        // 使用正态分布近似计算置信区间
        double zScore = getZScore(confidenceLevel);
        double standardError = Math.sqrt(accuracy * (1 - accuracy) / sampleSize);
        double marginOfError = zScore * standardError;
        
        double lowerBound = Math.max(0, accuracy - marginOfError);
        double upperBound = Math.min(1, accuracy + marginOfError);
        
        return new double[]{lowerBound, upperBound};
    }
    
    /**
     * 获取Z分数
     */
    private static double getZScore(double confidenceLevel) {
        // 常用置信水平对应的Z分数
        switch ((int) (confidenceLevel * 100)) {
            case 90: return 1.645;
            case 95: return 1.96;
            case 99: return 2.576;
            default: return 1.96; // 默认95%置信水平
        }
    }
}
```

## 11.1.3 精确率（Precision）与召回率（Recall）

精确率和召回率是两个互补的指标，它们从不同角度衡量模型的性能。

### 精确率（Precision）

精确率关注的是模型预测为正类的样本中有多少是真正的正类：

$$Precision = \frac{TP}{TP + FP}$$

### 召回率（Recall）

召回率关注的是实际为正类的样本中有多少被模型正确预测：

$$Recall = \frac{TP}{TP + FN}$$

### 权衡关系

精确率和召回率之间存在权衡关系：
- 提高精确率通常会降低召回率
- 提高召回率通常会降低精确率

### Precision-Recall计算器实现

```java
/**
 * Precision-Recall计算器
 */
public class PrecisionRecallCalculator {
    
    /**
     * 计算精确率
     */
    public static double calculatePrecision(int tp, int fp) {
        int denominator = tp + fp;
        return denominator == 0 ? 0 : (double) tp / denominator;
    }
    
    /**
     * 计算召回率
     */
    public static double calculateRecall(int tp, int fn) {
        int denominator = tp + fn;
        return denominator == 0 ? 0 : (double) tp / denominator;
    }
    
    /**
     * 计算F1分数
     */
    public static double calculateF1Score(double precision, double recall) {
        double sum = precision + recall;
        return sum == 0 ? 0 : 2 * precision * recall / sum;
    }
    
    /**
     * 计算Fβ分数
     */
    public static double calculateFBetaScore(double precision, double recall, double beta) {
        double betaSquared = beta * beta;
        double numerator = (1 + betaSquared) * precision * recall;
        double denominator = betaSquared * precision + recall;
        return denominator == 0 ? 0 : numerator / denominator;
    }
    
    /**
     * 计算多分类的宏平均Precision
     */
    public static double calculateMacroPrecision(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double sumPrecision = 0;
        int validClasses = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fp = 0;
            
            // 计算该类别的假正例数
            for (int j = 0; j < numClasses; j++) {
                if (j != i) {
                    fp += confusionMatrix[j][i];
                }
            }
            
            double precision = calculatePrecision(tp, fp);
            if (tp + fp > 0) {
                sumPrecision += precision;
                validClasses++;
            }
        }
        
        return validClasses == 0 ? 0 : sumPrecision / validClasses;
    }
    
    /**
     * 计算多分类的宏平均Recall
     */
    public static double calculateMacroRecall(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double sumRecall = 0;
        int validClasses = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fn = 0;
            
            // 计算该类别的假负例数
            for (int j = 0; j < numClasses; j++) {
                if (j != i) {
                    fn += confusionMatrix[i][j];
                }
            }
            
            double recall = calculateRecall(tp, fn);
            if (tp + fn > 0) {
                sumRecall += recall;
                validClasses++;
            }
        }
        
        return validClasses == 0 ? 0 : sumRecall / validClasses;
    }
    
    /**
     * 计算多分类的加权平均Precision
     */
    public static double calculateWeightedPrecision(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double weightedSum = 0;
        int totalSamples = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fp = 0;
            int classSupport = 0;
            
            // 计算该类别的假正例数和支持数
            for (int j = 0; j < numClasses; j++) {
                classSupport += confusionMatrix[i][j];
                if (j != i) {
                    fp += confusionMatrix[j][i];
                }
            }
            
            double precision = calculatePrecision(tp, fp);
            weightedSum += precision * classSupport;
            totalSamples += classSupport;
        }
        
        return totalSamples == 0 ? 0 : weightedSum / totalSamples;
    }
}
```

## 11.1.4 F1分数与其他综合指标

F1分数是精确率和召回率的调和平均数，是平衡这两个指标的常用方法。

### F1分数

$$F1 = 2 \times \frac{Precision \times Recall}{Precision + Recall} = \frac{2 \times TP}{2 \times TP + FP + FN}$$

### Fβ分数

Fβ分数是F1分数的泛化形式，通过参数β来调整精确率和召回率的相对重要性：

$$F_\beta = (1 + \beta^2) \times \frac{Precision \times Recall}{\beta^2 \times Precision + Recall}$$

当β>1时，召回率更重要；当β<1时，精确率更重要。

### 综合指标计算器实现

```java
/**
 * 综合指标计算器
 */
public class ComprehensiveMetricsCalculator {
    
    /**
     * 计算F1分数
     */
    public static double calculateF1Score(int tp, int fp, int fn) {
        int numerator = 2 * tp;
        int denominator = 2 * tp + fp + fn;
        return denominator == 0 ? 0 : (double) numerator / denominator;
    }
    
    /**
     * 计算Fβ分数
     */
    public static double calculateFBetaScore(int tp, int fp, int fn, double beta) {
        double betaSquared = beta * beta;
        double precision = PrecisionRecallCalculator.calculatePrecision(tp, fp);
        double recall = PrecisionRecallCalculator.calculateRecall(tp, fn);
        
        double numerator = (1 + betaSquared) * precision * recall;
        double denominator = betaSquared * precision + recall;
        return denominator == 0 ? 0 : numerator / denominator;
    }
    
    /**
     * 计算Matthews相关系数（MCC）
     */
    public static double calculateMCC(int tp, int fp, int tn, int fn) {
        double numerator = (double) tp * tn - fp * fn;
        double denominator = Math.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn));
        return denominator == 0 ? 0 : numerator / denominator;
    }
    
    /**
     * 计算Cohen's Kappa系数
     */
    public static double calculateKappa(int tp, int fp, int tn, int fn) {
        int total = tp + fp + tn + fn;
        if (total == 0) return 0;
        
        double observedAgreement = (double) (tp + tn) / total;
        double expectedAgreement = ((double) (tp + fp) * (tp + fn) + (tn + fp) * (tn + fn)) / (total * total);
        
        return expectedAgreement == 1 ? 0 : (observedAgreement - expectedAgreement) / (1 - expectedAgreement);
    }
    
    /**
     * 计算多分类的F1分数（宏平均）
     */
    public static double calculateMacroF1(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double sumF1 = 0;
        int validClasses = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fp = 0;
            int fn = 0;
            
            // 计算该类别的FP和FN
            for (int j = 0; j < numClasses; j++) {
                if (j != i) {
                    fp += confusionMatrix[j][i];
                    fn += confusionMatrix[i][j];
                }
            }
            
            double f1 = calculateF1Score(tp, fp, fn);
            if (tp + fp + fn > 0) {
                sumF1 += f1;
                validClasses++;
            }
        }
        
        return validClasses == 0 ? 0 : sumF1 / validClasses;
    }
    
    /**
     * 计算多分类的F1分数（加权平均）
     */
    public static double calculateWeightedF1(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        double weightedSum = 0;
        int totalSamples = 0;
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fp = 0;
            int fn = 0;
            int classSupport = 0;
            
            // 计算该类别的FP、FN和支持数
            for (int j = 0; j < numClasses; j++) {
                classSupport += confusionMatrix[i][j];
                if (j != i) {
                    fp += confusionMatrix[j][i];
                    fn += confusionMatrix[i][j];
                }
            }
            
            double f1 = calculateF1Score(tp, fp, fn);
            weightedSum += f1 * classSupport;
            totalSamples += classSupport;
        }
        
        return totalSamples == 0 ? 0 : weightedSum / totalSamples;
    }
}
```

## 11.1.5 多分类和多标签评估

在实际应用中，我们经常遇到多分类和多标签问题，需要使用专门的评估方法。

### 多分类评估

对于多分类问题，每个样本属于且仅属于一个类别。

```java
/**
 * 多分类评估器
 */
public class MulticlassEvaluator {
    
    /**
     * 计算多分类混淆矩阵
     */
    public static int[][] calculateConfusionMatrix(int[] predictions, int[] trueLabels, int numClasses) {
        if (predictions.length != trueLabels.length) {
            throw new IllegalArgumentException("预测结果和真实标签长度不匹配");
        }
        
        int[][] confusionMatrix = new int[numClasses][numClasses];
        
        for (int i = 0; i < predictions.length; i++) {
            int predictedClass = predictions[i];
            int trueClass = trueLabels[i];
            
            if (predictedClass >= 0 && predictedClass < numClasses && 
                trueClass >= 0 && trueClass < numClasses) {
                confusionMatrix[trueClass][predictedClass]++;
            }
        }
        
        return confusionMatrix;
    }
    
    /**
     * 打印多分类混淆矩阵
     */
    public static void printConfusionMatrix(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        
        System.out.println("多分类混淆矩阵:");
        System.out.print("真实\\预测\t");
        for (int i = 0; i < numClasses; i++) {
            System.out.printf("类别%d\t", i);
        }
        System.out.println();
        
        for (int i = 0; i < numClasses; i++) {
            System.out.printf("类别%d\t\t", i);
            for (int j = 0; j < numClasses; j++) {
                System.out.printf("%d\t", confusionMatrix[i][j]);
            }
            System.out.println();
        }
    }
    
    /**
     * 计算多分类评估指标
     */
    public static MulticlassMetrics calculateMetrics(int[][] confusionMatrix) {
        int numClasses = confusionMatrix.length;
        
        // 计算各类别的指标
        double[] precisions = new double[numClasses];
        double[] recalls = new double[numClasses];
        double[] f1Scores = new double[numClasses];
        int[] supports = new int[numClasses];
        
        for (int i = 0; i < numClasses; i++) {
            int tp = confusionMatrix[i][i];
            int fp = 0;
            int fn = 0;
            int support = 0;
            
            // 计算FP、FN和支持数
            for (int j = 0; j < numClasses; j++) {
                support += confusionMatrix[i][j];
                if (j != i) {
                    fp += confusionMatrix[j][i];
                    fn += confusionMatrix[i][j];
                }
            }
            
            precisions[i] = PrecisionRecallCalculator.calculatePrecision(tp, fp);
            recalls[i] = PrecisionRecallCalculator.calculateRecall(tp, fn);
            f1Scores[i] = ComprehensiveMetricsCalculator.calculateF1Score(tp, fp, fn);
            supports[i] = support;
        }
        
        // 计算宏平均和加权平均
        double macroPrecision = Arrays.stream(precisions).average().orElse(0);
        double macroRecall = Arrays.stream(recalls).average().orElse(0);
        double macroF1 = Arrays.stream(f1Scores).average().orElse(0);
        
        double weightedPrecision = calculateWeightedAverage(precisions, supports);
        double weightedRecall = calculateWeightedAverage(recalls, supports);
        double weightedF1 = calculateWeightedAverage(f1Scores, supports);
        
        // 计算准确率
        int totalCorrect = 0;
        int totalSamples = 0;
        for (int i = 0; i < numClasses; i++) {
            totalCorrect += confusionMatrix[i][i];
            for (int j = 0; j < numClasses; j++) {
                totalSamples += confusionMatrix[i][j];
            }
        }
        double accuracy = totalSamples == 0 ? 0 : (double) totalCorrect / totalSamples;
        
        return new MulticlassMetrics(precisions, recalls, f1Scores, supports,
                                   macroPrecision, macroRecall, macroF1,
                                   weightedPrecision, weightedRecall, weightedF1,
                                   accuracy);
    }
    
    /**
     * 计算加权平均
     */
    private static double calculateWeightedAverage(double[] values, int[] weights) {
        double weightedSum = 0;
        int totalWeight = 0;
        
        for (int i = 0; i < values.length; i++) {
            weightedSum += values[i] * weights[i];
            totalWeight += weights[i];
        }
        
        return totalWeight == 0 ? 0 : weightedSum / totalWeight;
    }
}

/**
 * 多分类评估指标
 */
class MulticlassMetrics {
    private double[] precisions;
    private double[] recalls;
    private double[] f1Scores;
    private int[] supports;
    private double macroPrecision;
    private double macroRecall;
    private double macroF1;
    private double weightedPrecision;
    private double weightedRecall;
    private double weightedF1;
    private double accuracy;
    
    public MulticlassMetrics(double[] precisions, double[] recalls, double[] f1Scores, int[] supports,
                           double macroPrecision, double macroRecall, double macroF1,
                           double weightedPrecision, double weightedRecall, double weightedF1,
                           double accuracy) {
        this.precisions = precisions;
        this.recalls = recalls;
        this.f1Scores = f1Scores;
        this.supports = supports;
        this.macroPrecision = macroPrecision;
        this.macroRecall = macroRecall;
        this.macroF1 = macroF1;
        this.weightedPrecision = weightedPrecision;
        this.weightedRecall = weightedRecall;
        this.weightedF1 = weightedF1;
        this.accuracy = accuracy;
    }
    
    public void printReport() {
        System.out.println("=== 多分类评估报告 ===");
        System.out.printf("准确率: %.4f%n", accuracy);
        System.out.println();
        System.out.println("类别\t精确率\t召回率\tF1分数\t支持数");
        System.out.println("----\t------\t------\t------\t------");
        
        for (int i = 0; i < precisions.length; i++) {
            System.out.printf("类别%d\t%.4f\t%.4f\t%.4f\t%d%n", 
                            i, precisions[i], recalls[i], f1Scores[i], supports[i]);
        }
        
        System.out.println();
        System.out.printf("宏平均\t%.4f\t%.4f\t%.4f%n", macroPrecision, macroRecall, macroF1);
        System.out.printf("加权平均\t%.4f\t%.4f\t%.4f%n", weightedPrecision, weightedRecall, weightedF1);
    }
    
    // Getter方法
    public double[] getPrecisions() { return precisions; }
    public double[] getRecalls() { return recalls; }
    public double[] getF1Scores() { return f1Scores; }
    public int[] getSupports() { return supports; }
    public double getMacroPrecision() { return macroPrecision; }
    public double getMacroRecall() { return macroRecall; }
    public double getMacroF1() { return macroF1; }
    public double getWeightedPrecision() { return weightedPrecision; }
    public double getWeightedRecall() { return weightedRecall; }
    public double getWeightedF1() { return weightedF1; }
    public double getAccuracy() { return accuracy; }
}
```

## 11.1.6 完整示例：分类模型评估

让我们通过一个完整的示例来演示如何使用这些评估指标：

```java
/**
 * 分类模型评估示例
 */
public class ClassificationEvaluationExample {
    public static void main(String[] args) {
        System.out.println("=== 分类模型评估示例 ===");
        
        // 示例1：二分类问题
        System.out.println("\n1. 二分类问题评估:");
        binaryClassificationExample();
        
        // 示例2：多分类问题
        System.out.println("\n2. 多分类问题评估:");
        multiclassClassificationExample();
        
        // 示例3：不同阈值下的评估
        System.out.println("\n3. 不同阈值下的评估:");
        thresholdAnalysisExample();
    }
    
    /**
     * 二分类问题示例
     */
    private static void binaryClassificationExample() {
        // 模拟预测结果和真实标签
        int[] predictions = {1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0};
        int[] trueLabels = {1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0};
        
        // 创建混淆矩阵
        ConfusionMatrix cm = new ConfusionMatrix();
        cm.update(predictions, trueLabels);
        
        // 打印结果
        cm.printMatrix();
        System.out.println();
        cm.printMetrics();
        
        // 计算置信区间
        double accuracy = cm.getAccuracy();
        double[] confidenceInterval = AccuracyCalculator.calculateConfidenceInterval(accuracy, predictions.length, 0.95);
        System.out.printf("准确率95%%置信区间: [%.4f, %.4f]%n", confidenceInterval[0], confidenceInterval[1]);
    }
    
    /**
     * 多分类问题示例
     */
    private static void multiclassClassificationExample() {
        // 模拟三分类问题的预测结果和真实标签
        int[] predictions = {0, 1, 2, 0, 1, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2};
        int[] trueLabels = {0, 1, 1, 0, 2, 2, 1, 0, 2, 1, 1, 2, 0, 0, 2};
        int numClasses = 3;
        
        // 计算混淆矩阵
        int[][] confusionMatrix = MulticlassEvaluator.calculateConfusionMatrix(predictions, trueLabels, numClasses);
        MulticlassEvaluator.printConfusionMatrix(confusionMatrix);
        
        // 计算评估指标
        MulticlassMetrics metrics = MulticlassEvaluator.calculateMetrics(confusionMatrix);
        System.out.println();
        metrics.printReport();
    }
    
    /**
     * 阈值分析示例
     */
    private static void thresholdAnalysisExample() {
        // 模拟预测概率
        double[] probabilities = {0.9, 0.8, 0.7, 0.6, 0.55, 0.5, 0.45, 0.4, 0.3, 0.2};
        int[] trueLabels = {1, 1, 1, 0, 1, 0, 0, 0, 0, 0};
        
        System.out.println("不同阈值下的评估结果:");
        System.out.println("阈值\t准确率\t精确率\t召回率\tF1分数");
        System.out.println("----\t------\t------\t------\t------");
        
        // 测试不同阈值
        double[] thresholds = {0.3, 0.4, 0.5, 0.6, 0.7};
        for (double threshold : thresholds) {
            ConfusionMatrix cm = new ConfusionMatrix();
            cm.updateFromProbabilities(probabilities, trueLabels, threshold);
            
            double accuracy = cm.getAccuracy();
            double precision = cm.getPrecision();
            double recall = cm.getRecall();
            double f1 = cm.getF1Score();
            
            System.out.printf("%.1f\t%.4f\t%.4f\t%.4f\t%.4f%n", 
                            threshold, accuracy, precision, recall, f1);
        }
    }
}
```

## 本节小结

在本节中，我们深入学习了分类问题的评估指标体系：

1. **基础概念**：理解了TP、FP、TN、FN等基本概念和混淆矩阵
2. **准确率**：掌握了准确率的计算方法和适用场景
3. **精确率与召回率**：理解了这两个互补指标的含义和权衡关系
4. **F1分数**：学习了平衡精确率和召回率的综合指标
5. **多分类评估**：掌握了多分类问题的评估方法
6. **实际应用**：通过完整示例演示了评估指标的使用

通过Java代码实现，我们不仅掌握了理论知识，还获得了实际的编程经验。这些评估指标是模型评估的基础，为后续学习更高级的评估技术奠定了基础。

## 下一步计划

在下一节中，我们将学习交叉验证与数据分割策略，掌握科学的数据验证方法。